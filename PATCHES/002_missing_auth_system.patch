# Patch - Système d'Authentification Triple Portail

## Problème
Le système d'authentification triple portail (Admin/Prof/Élève) n'est pas complètement implémenté, empêchant la séparation des rôles.

## Solution
Implémenter un système d'authentification complet avec rôles distincts et interfaces séparées.

## Fichiers à créer/modifier

### 1. backend/core/auth.py
```python
from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
from django.contrib.auth import get_user_model
from rest_framework.permissions import BasePermission

User = get_user_model()

class UserRole:
    ADMIN = 'admin'
    TEACHER = 'teacher'
    STUDENT = 'student'

def create_user_roles():
    """
    Crée les groupes et permissions pour les rôles utilisateurs
    """
    # Groupe Admin - Accès complet
    admin_group, created = Group.objects.get_or_create(name=UserRole.ADMIN)
    
    # Groupe Prof - Accès limité à la correction
    teacher_group, created = Group.objects.get_or_create(name=UserRole.TEACHER)
    
    # Groupe Élève - Accès lecture seule à ses copies
    student_group, created = Group.objects.get_or_create(name=UserRole.STUDENT)
    
    # Permissions pour professeurs
    from exams.models import Copy
    from grading.models import Annotation
    
    copy_content_type = ContentType.objects.get_for_model(Copy)
    annotation_content_type = ContentType.objects.get_for_model(Annotation)
    
    # Ajouter des permissions spécifiques pour les profs
    # (à adapter selon les besoins exacts)
    
    return admin_group, teacher_group, student_group

class IsAdmin(BasePermission):
    """
    Permission pour les administrateurs
    """
    def has_permission(self, request, view):
        if request.user.is_authenticated:
            return request.user.groups.filter(name='admin').exists()
        return False

class IsTeacher(BasePermission):
    """
    Permission pour les enseignants
    """
    def has_permission(self, request, view):
        if request.user.is_authenticated:
            return request.user.groups.filter(name='teacher').exists()
        return False

class IsStudent(BasePermission):
    """
    Permission pour les élèves
    """
    def has_permission(self, request, view):
        if request.user.is_authenticated:
            return request.user.groups.filter(name='student').exists()
        return False

class IsAdminOrTeacher(BasePermission):
    """
    Permission pour admin ou teacher
    """
    def has_permission(self, request, view):
        if request.user.is_authenticated:
            return (request.user.groups.filter(name='admin').exists() or 
                   request.user.groups.filter(name='teacher').exists())
        return False

class IsOwnerOrReadOnly(BasePermission):
    """
    Permission pour propriétaire de copie
    """
    def has_object_permission(self, request, view, obj):
        # Pour les copies - vérifier si c'est le propriétaire
        if hasattr(obj, 'student'):
            return obj.student.user == request.user if obj.student else False
        return True
```

### 2. backend/exams/permissions.py (mise à jour)
```python
from rest_framework.permissions import BasePermission, IsAuthenticated
from .models import Copy
from core.auth import IsAdmin, IsTeacher, IsStudent, IsAdminOrTeacher

class IsTeacherOrAdmin(BasePermission):
    """
    Permission pour enseignant ou admin
    """
    def has_permission(self, request, view):
        if request.user.is_authenticated:
            return (request.user.groups.filter(name='teacher').exists() or 
                   request.user.groups.filter(name='admin').exists())
        return False

class IsStudentForOwnData(BasePermission):
    """
    Permission pour élève accédant à ses propres données
    """
    def has_object_permission(self, request, view, obj):
        if isinstance(obj, Copy):
            # Vérifier que l'élève ne voit que ses propres copies
            if request.user.groups.filter(name='student').exists():
                # Associer l'utilisateur élève à un modèle Student
                from students.models import Student
                try:
                    student = Student.objects.get(user=request.user)
                    return obj.student == student
                except Student.DoesNotExist:
                    return False
        return True

class AdminOnly(BasePermission):
    """
    Permission pour admin seulement
    """
    def has_permission(self, request, view):
        if request.user.is_authenticated:
            return request.user.groups.filter(name='admin').exists()
        return False
```

### 3. backend/students/models.py (mise à jour)
```python
from django.db import models
from django.contrib.auth.models import User

class Student(models.Model):
    ine = models.CharField(max_length=50, unique=True, verbose_name="Identifiant National Élève")
    first_name = models.CharField(max_length=100, verbose_name="Prénom")
    last_name = models.CharField(max_length=100, verbose_name="Nom")
    class_name = models.CharField(max_length=50, verbose_name="Classe")
    email = models.EmailField(blank=True, null=True, verbose_name="Email")
    
    # Lien vers utilisateur Django pour authentification
    user = models.OneToOneField(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='student_profile',
        verbose_name="Utilisateur associé"
    )

    def __str__(self):
        return f"{self.last_name} {self.first_name} ({self.class_name})"

    class Meta:
        verbose_name = "Élève"
        verbose_name_plural = "Élèves"
```

### 4. backend/students/views.py (mise à jour)
```python
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth.models import User, Group
from django.contrib.auth import authenticate, login
from .models import Student
from core.auth import UserRole

@api_view(['POST'])
def student_login(request):
    """
    Endpoint de login pour les élèves
    """
    ine = request.data.get('ine')
    birth_date = request.data.get('birth_date')  # ou autre méthode d'authentification
    
    if not ine or not birth_date:
        return Response(
            {'error': 'INE et date de naissance requis'}, 
            status=status.HTTP_400_BAD_REQUEST
        )
    
    try:
        student = Student.objects.get(ine=ine)
        # Ici, on pourrait vérifier la date de naissance ou autre méthode d'authentification
        # Pour simplifier, on suppose que l'INE est suffisant pour l'identification
        
        # Créer ou récupérer l'utilisateur associé
        user, created = User.objects.get_or_create(
            username=f"student_{student.ine}",
            defaults={
                'first_name': student.first_name,
                'last_name': student.last_name,
                'email': student.email or ''
            }
        )
        
        if created:
            # Assigner au groupe élève
            student_group = Group.objects.get(name=UserRole.STUDENT)
            user.groups.add(student_group)
        
        # Associer l'utilisateur au profil élève
        if not student.user:
            student.user = user
            student.save()
        
        # Authentifier l'utilisateur (simulé)
        request.session['student_id'] = student.id
        request.session['user_id'] = user.id
        
        return Response({
            'success': True,
            'student_id': student.id,
            'name': f"{student.first_name} {student.last_name}",
            'class': student.class_name
        })
        
    except Student.DoesNotExist:
        return Response(
            {'error': 'Élève non trouvé'}, 
            status=status.HTTP_404_NOT_FOUND
        )

class StudentDashboardView(APIView):
    """
    Dashboard pour les élèves - accès à leurs copies
    """
    def get(self, request):
        # Vérifier que l'utilisateur est authentifié en tant qu'élève
        student_id = request.session.get('student_id')
        if not student_id:
            return Response(
                {'error': 'Authentification requise'}, 
                status=status.HTTP_401_UNAUTHORIZED
            )
        
        try:
            from exams.models import Copy
            student = Student.objects.get(id=student_id)
            
            # Récupérer les copies de l'élève
            copies = Copy.objects.filter(
                student=student, 
                status=Copy.Status.GRADED
            ).select_related('exam')
            
            data = []
            for copy in copies:
                # Calculer le score
                from grading.services import GradingService
                total_score = GradingService.compute_score(copy)
                
                data.append({
                    'id': copy.id,
                    'exam_name': copy.exam.name,
                    'exam_date': copy.exam.date,
                    'total_score': total_score,
                    'status': copy.get_status_display(),
                    'final_pdf_url': copy.final_pdf.url if copy.final_pdf else None
                })
            
            return Response(data)
            
        except Student.DoesNotExist:
            return Response(
                {'error': 'Élève non trouvé'}, 
                status=status.HTTP_404_NOT_FOUND
            )
```

### 5. backend/students/urls.py (mise à jour)
```python
from django.urls import path
from . import views

urlpatterns = [
    path('login/', views.student_login, name='student-login'),
    path('dashboard/', views.StudentDashboardView.as_view(), name='student-dashboard'),
    # autres endpoints pour élèves
]
```

### 6. backend/core/management/commands/init_pmf.py (nouveau)
```python
from django.core.management.base import BaseCommand
from django.contrib.auth.models import User, Group
from core.auth import create_user_roles, UserRole

class Command(BaseCommand):
    help = 'Initialise les données PMF (rôles, utilisateurs de base)'

    def handle(self, *args, **options):
        self.stdout.write('Création des rôles utilisateurs...')
        admin_group, teacher_group, student_group = create_user_roles()
        
        # Créer un utilisateur admin par défaut si aucun admin existe
        if not User.objects.filter(is_superuser=True).exists():
            admin_user = User.objects.create_superuser(
                username='admin',
                email='admin@pmf.edu',
                password='admin123'  # Devrait être changé en production
            )
            admin_user.groups.add(admin_group)
            self.stdout.write(f'Utilisateur admin créé: {admin_user.username}')
        
        # Créer un utilisateur professeur de test
        if not User.objects.filter(username='teacher').exists():
            teacher_user = User.objects.create_user(
                username='teacher',
                email='teacher@pmf.edu',
                password='teacher123'
            )
            teacher_user.groups.add(teacher_group)
            self.stdout.write(f'Utilisateur teacher créé: {teacher_user.username}')
        
        # Créer un utilisateur élève de test
        if not User.objects.filter(username='student').exists():
            student_user = User.objects.create_user(
                username='student',
                email='student@pmf.edu',
                password='student123'
            )
            student_user.groups.add(student_group)
            self.stdout.write(f'Utilisateur student créé: {student_user.username}')
        
        self.stdout.write(
            self.style.SUCCESS('Initialisation PMF terminée avec succès!')
        )
```

### 7. backend/exams/views.py (mise à jour pour permissions)
```python
# Dans les vues existantes, s'assurer que les permissions sont correctement appliquées
from .permissions import IsTeacherOrAdmin, IsStudentForOwnData

class StudentCopiesView(ListAPIView):
    """
    Vue pour que les élèves consultent leurs copies
    """
    permission_classes = [IsStudent]  # Seuls les élèves peuvent accéder
    serializer_class = CopySerializer

    def get_queryset(self):
        # Filtrer pour que l'élève ne voie que ses propres copies
        student_id = self.request.session.get('student_id')
        if not student_id:
            return Copy.objects.none()
        
        return Copy.objects.filter(
            student_id=student_id, 
            status=Copy.Status.GRADED
        ).select_related('exam', 'student')
```

## Tests à ajouter

### backend/students/tests/test_auth.py
```python
from django.test import TestCase, Client
from django.contrib.auth.models import User, Group
from django.urls import reverse
from .models import Student
from core.auth import UserRole

class StudentAuthTest(TestCase):
    def setUp(self):
        # Créer les groupes
        self.admin_group = Group.objects.create(name=UserRole.ADMIN)
        self.teacher_group = Group.objects.create(name=UserRole.TEACHER)
        self.student_group = Group.objects.create(name=UserRole.STUDENT)
        
        # Créer un élève de test
        self.student = Student.objects.create(
            ine="1234567890A",
            first_name="Jean",
            last_name="Dupont",
            class_name="TG2"
        )
        
        # Créer un utilisateur élève
        self.student_user = User.objects.create_user(
            username="jean.dupont",
            password="password123"
        )
        self.student_user.groups.add(self.student_group)
        self.student.user = self.student_user
        self.student.save()
        
        self.client = Client()

    def test_student_login(self):
        # Test de connexion élève
        response = self.client.post(reverse('student-login'), {
            'ine': '1234567890A',
            'birth_date': '2005-01-01'  # exemple
        })
        
        # Selon notre implémentation, cela devrait réussir
        self.assertEqual(response.status_code, 200)
        self.assertTrue(response.json()['success'])

    def test_student_dashboard_access(self):
        # Authentifier l'élève
        self.client.login(username='jean.dupont', password='password123')
        
        # Accéder au dashboard
        response = self.client.get(reverse('student-dashboard'))
        self.assertEqual(response.status_code, 200)
```