# 03.4 - API Identification des Copies

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Vue d'Ensemble

L'API Identification permet aux **enseignants et administrateurs** de g√©rer l'identification des copies via OCR (modes AUTO, SEMI-AUTO, MANUAL).

### Modes d'Identification

| Mode | Confidence | Action |
|------|-----------|--------|
| **AUTO** | > 0.7 | Assignation automatique |
| **SEMI-AUTO** | 0.4 - 0.7 | S√©lection parmi top-5 candidats OCR |
| **MANUAL** | < 0.4 | Recherche manuelle compl√®te |

### Base URL

```
http://localhost:8088/api/identification/
```

---

## üìã Endpoints

### 1. GET /api/identification/copies/

**Description** : Lister les copies non identifi√©es (bureau d'identification)

**Permissions** : Admin et Teacher uniquement

**Query Parameters** :
- `exam_id` (optionnel) : Filtrer par examen
- `ocr_mode` (optionnel) : Filtrer par mode (`AUTO`, `SEMI_AUTO`, `MANUAL`)

**R√©ponse Success (200 OK)** :

```json
[
  {
    "id": "copy-uuid-1",
    "exam": {
      "id": "exam-uuid-1",
      "name": "Bac Blanc Math√©matiques 2026"
    },
    "anonymous_id": "A3-015",
    "is_identified": false,
    "header_image_url": "http://localhost:8088/media/copies/headers/copy_uuid_1.jpg",
    "ocr_result": {
      "detected_text": "DUPONT Jean 15/05/2008",
      "confidence": 0.65,
      "ocr_mode": "SEMI_AUTO",
      "top_candidates_count": 5
    },
    "created_at": "2026-02-03T10:30:00Z"
  },
  {
    "id": "copy-uuid-2",
    "anonymous_id": "A3-022",
    "is_identified": false,
    "ocr_result": {
      "detected_text": "",
      "confidence": 0.0,
      "ocr_mode": "MANUAL",
      "top_candidates_count": 0
    }
  }
]
```

**Code Backend** :

```python
from rest_framework import viewsets
from exams.models import Copy
from identification.serializers import CopyIdentificationSerializer

class IdentificationViewSet(viewsets.ViewSet):
    """ViewSet pour identification copies."""

    permission_classes = [IsAuthenticated, IsTeacher]

    def list(self, request):
        """Liste copies non identifi√©es."""

        # Filtrer copies non identifi√©es
        queryset = Copy.objects.filter(is_identified=False)

        # Filtres
        exam_id = request.query_params.get('exam_id')
        if exam_id:
            queryset = queryset.filter(exam_id=exam_id)

        ocr_mode = request.query_params.get('ocr_mode')
        if ocr_mode:
            queryset = queryset.filter(ocrresult__ocr_mode=ocr_mode)

        # Pr√©charger OCR results
        queryset = queryset.select_related('exam').prefetch_related('ocrresult')

        serializer = CopyIdentificationSerializer(queryset, many=True)
        return Response(serializer.data)
```

---

### 2. GET /api/identification/copies/{id}/ocr-candidates/

**Description** : R√©cup√©rer les top-5 candidats OCR (mode SEMI-AUTO)

**Permissions** : Admin et Teacher uniquement

**R√©ponse Success (200 OK)** :

```json
{
  "copy_id": "copy-uuid-1",
  "anonymous_id": "A3-015",
  "ocr_mode": "SEMI_AUTO",
  "header_image_url": "http://localhost:8088/media/copies/headers/copy_uuid_1.jpg",
  "candidates": [
    {
      "rank": 1,
      "student": {
        "id": "student-uuid-1",
        "first_name": "Jean",
        "last_name": "DUPONT",
        "email": "jean.dupont@korrigo.local",
        "date_of_birth": "2008-05-15",
        "class_name": "G3"
      },
      "confidence": 0.85,
      "vote_count": 9,
      "vote_agreement": 0.75,
      "ocr_sources": [
        {
          "engine": "tesseract",
          "variant": 0,
          "text": "DUPONT JEAN 15/05/2008",
          "score": 0.82
        },
        {
          "engine": "easyocr",
          "variant": 1,
          "text": "Jean Dupont 15-05-2008",
          "score": 0.88
        },
        {
          "engine": "paddleocr",
          "variant": 0,
          "text": "DUPONT Jean 15/05/2008",
          "score": 0.85
        }
      ]
    },
    {
      "rank": 2,
      "student": {
        "id": "student-uuid-2",
        "first_name": "Jeanne",
        "last_name": "DUPOND",
        "email": "jeanne.dupond@korrigo.local",
        "date_of_birth": "2008-05-16"
      },
      "confidence": 0.52,
      "vote_count": 3,
      "vote_agreement": 0.25,
      "ocr_sources": [...]
    }
  ]
}
```

**R√©ponse Error (404 Not Found)** :

```json
{
  "error": "No OCR result found for this copy"
}
```

**Code Backend** :

```python
from identification.models import OCRResult
from students.models import Student

@action(detail=True, methods=['get'])
def ocr_candidates(self, request, pk=None):
    """R√©cup√©rer candidats OCR pour s√©lection."""

    copy = get_object_or_404(Copy, id=pk)

    # V√©rifier permissions
    if not request.user.is_superuser and copy.corrector != request.user:
        return Response({'error': 'Access denied'}, status=403)

    # R√©cup√©rer OCR result
    try:
        ocr_result = OCRResult.objects.get(copy=copy)
    except OCRResult.DoesNotExist:
        return Response({'error': 'No OCR result found'}, status=404)

    # Formater candidats
    candidates = []
    for idx, candidate_data in enumerate(ocr_result.top_candidates[:5], 1):
        student = Student.objects.get(id=candidate_data['student_id'])

        candidates.append({
            'rank': idx,
            'student': {
                'id': str(student.id),
                'first_name': student.first_name,
                'last_name': student.last_name,
                'email': student.email,
                'date_of_birth': student.date_of_birth.isoformat(),
                'class_name': student.class_name
            },
            'confidence': candidate_data['confidence'],
            'vote_count': candidate_data.get('vote_count', 0),
            'vote_agreement': candidate_data.get('vote_agreement', 0.0),
            'ocr_sources': candidate_data.get('sources', [])
        })

    return Response({
        'copy_id': str(copy.id),
        'anonymous_id': copy.anonymous_id,
        'ocr_mode': ocr_result.ocr_mode,
        'header_image_url': request.build_absolute_uri(
            f'/media/copies/headers/{copy.id}.jpg'
        ),
        'candidates': candidates
    })
```

**Exemple cURL** :

```bash
curl -X GET http://localhost:8088/api/identification/copies/copy-uuid-1/ocr-candidates/ \
  -b cookies.txt
```

---

### 3. POST /api/identification/copies/{id}/select-candidate/

**Description** : S√©lectionner un candidat parmi les top-5 (mode SEMI-AUTO)

**Permissions** : Admin et Teacher uniquement

**Body** :

```json
{
  "rank": 2
}
```

**R√©ponse Success (200 OK)** :

```json
{
  "success": true,
  "copy": {
    "id": "copy-uuid-1",
    "anonymous_id": "A3-015",
    "student": {
      "id": "student-uuid-2",
      "first_name": "Jeanne",
      "last_name": "DUPOND"
    },
    "is_identified": true,
    "status": "READY"
  },
  "message": "Student assigned successfully"
}
```

**R√©ponse Error (400 Bad Request)** :

```json
{
  "error": "Invalid rank: must be between 1 and 5"
}
```

**Code Backend** :

```python
@action(detail=True, methods=['post'])
def select_candidate(self, request, pk=None):
    """S√©lectionner candidat OCR."""

    copy = get_object_or_404(Copy, id=pk)

    # Permissions
    if not request.user.is_superuser and copy.corrector != request.user:
        return Response({'error': 'Access denied'}, status=403)

    # V√©rifier pas d√©j√† identifi√©e
    if copy.is_identified:
        return Response({'error': 'Copy already identified'}, status=400)

    # R√©cup√©rer rank
    rank = request.data.get('rank')

    if not rank or not isinstance(rank, int) or rank < 1 or rank > 5:
        return Response({'error': 'Invalid rank: must be between 1 and 5'}, status=400)

    # R√©cup√©rer OCR result
    ocr_result = OCRResult.objects.get(copy=copy)

    if rank > len(ocr_result.top_candidates):
        return Response({'error': f'Rank {rank} exceeds available candidates'}, status=400)

    # S√©lectionner candidat
    selected_candidate = ocr_result.top_candidates[rank - 1]
    student = Student.objects.get(id=selected_candidate['student_id'])

    # Assigner
    copy.student = student
    copy.is_identified = True
    copy.status = Copy.Status.READY
    copy.save()

    # Audit trail
    ocr_result.selected_candidate_rank = rank
    ocr_result.save()

    return Response({
        'success': True,
        'copy': CopySerializer(copy).data,
        'message': 'Student assigned successfully'
    })
```

---

### 4. POST /api/identification/copies/{id}/manual-assign/

**Description** : Assigner manuellement un √©tudiant (mode MANUAL)

**Permissions** : Admin et Teacher uniquement

**Body** :

```json
{
  "student_id": "student-uuid-1"
}
```

**R√©ponse Success (200 OK)** :

```json
{
  "success": true,
  "copy": {
    "id": "copy-uuid-1",
    "anonymous_id": "A3-022",
    "student": {
      "id": "student-uuid-1",
      "first_name": "Jean",
      "last_name": "DUPONT"
    },
    "is_identified": true,
    "status": "READY"
  },
  "message": "Student assigned manually"
}
```

**Code Backend** :

```python
@action(detail=True, methods=['post'])
def manual_assign(self, request, pk=None):
    """Assignation manuelle √©tudiant."""

    copy = get_object_or_404(Copy, id=pk)

    # Permissions
    if not request.user.is_superuser and copy.corrector != request.user:
        return Response({'error': 'Access denied'}, status=403)

    # V√©rifier pas d√©j√† identifi√©e
    if copy.is_identified:
        return Response({'error': 'Copy already identified'}, status=400)

    # R√©cup√©rer student_id
    student_id = request.data.get('student_id')

    if not student_id:
        return Response({'error': 'student_id required'}, status=400)

    # R√©cup√©rer √©tudiant
    try:
        student = Student.objects.get(id=student_id)
    except Student.DoesNotExist:
        return Response({'error': 'Student not found'}, status=404)

    # V√©rifier que √©tudiant appartient au m√™me examen
    if not student.email in self._get_exam_students_emails(copy.exam):
        return Response({
            'error': 'Student not in exam student list'
        }, status=400)

    # Assigner
    copy.student = student
    copy.is_identified = True
    copy.status = Copy.Status.READY
    copy.save()

    # Audit trail (OCR result)
    ocr_result, _ = OCRResult.objects.get_or_create(
        copy=copy,
        defaults={
            'detected_text': '',
            'confidence': 0.0,
            'ocr_mode': 'MANUAL',
            'top_candidates': []
        }
    )
    ocr_result.manual_override = True
    ocr_result.save()

    return Response({
        'success': True,
        'copy': CopySerializer(copy).data,
        'message': 'Student assigned manually'
    })

def _get_exam_students_emails(self, exam):
    """R√©cup√©rer emails √©tudiants du CSV."""
    # Parser CSV si existe
    if not exam.students_csv:
        return []

    from processing.services.batch_processor import parse_student_csv
    students = parse_student_csv(exam.students_csv.path)
    return [s['email'] for s in students]
```

---

### 5. GET /api/identification/students/search/

**Description** : Rechercher √©tudiants (pour assignation manuelle)

**Permissions** : Admin et Teacher uniquement

**Query Parameters** :
- `q` (requis) : Requ√™te de recherche (nom, pr√©nom, email)
- `exam_id` (optionnel) : Filtrer √©tudiants du CSV de cet examen

**R√©ponse Success (200 OK)** :

```json
[
  {
    "id": "student-uuid-1",
    "first_name": "Jean",
    "last_name": "DUPONT",
    "email": "jean.dupont@korrigo.local",
    "date_of_birth": "2008-05-15",
    "class_name": "G3",
    "student_number": "STU001"
  },
  {
    "id": "student-uuid-2",
    "first_name": "Jeanne",
    "last_name": "DUPOND",
    "email": "jeanne.dupond@korrigo.local",
    "date_of_birth": "2008-05-16",
    "class_name": "G3"
  }
]
```

**Code Backend** :

```python
from django.db.models import Q

@action(detail=False, methods=['get'])
def search_students(self, request):
    """Rechercher √©tudiants."""

    query = request.query_params.get('q', '').strip()

    if len(query) < 2:
        return Response({'error': 'Query too short (min 2 chars)'}, status=400)

    # Recherche
    queryset = Student.objects.filter(
        Q(first_name__icontains=query) |
        Q(last_name__icontains=query) |
        Q(email__icontains=query) |
        Q(student_number__icontains=query)
    )

    # Filtrer par examen si sp√©cifi√©
    exam_id = request.query_params.get('exam_id')
    if exam_id:
        exam = Exam.objects.get(id=exam_id)
        # Filtrer par emails du CSV
        csv_emails = self._get_exam_students_emails(exam)
        queryset = queryset.filter(email__in=csv_emails)

    # Limiter r√©sultats
    queryset = queryset[:20]

    serializer = StudentSerializer(queryset, many=True)
    return Response(serializer.data)
```

**Exemple cURL** :

```bash
# Rechercher "dupont"
curl -X GET "http://localhost:8088/api/identification/students/search/?q=dupont" \
  -b cookies.txt

# Rechercher dans examen sp√©cifique
curl -X GET "http://localhost:8088/api/identification/students/search/?q=dupont&exam_id=exam-uuid-1" \
  -b cookies.txt
```

---

### 6. POST /api/identification/copies/{id}/force-reidentify/

**Description** : Forcer r√©-identification (relancer OCR)

**Permissions** : Admin uniquement

**R√©ponse Success (202 Accepted)** :

```json
{
  "success": true,
  "job_id": "abc123-def456",
  "message": "Re-identification started"
}
```

**Code Backend** :

```python
from processing.tasks import reidentify_copy

@action(detail=True, methods=['post'])
def force_reidentify(self, request, pk=None):
    """Forcer r√©-identification (admin uniquement)."""

    if not request.user.is_superuser:
        return Response({'error': 'Admin only'}, status=403)

    copy = get_object_or_404(Copy, id=pk)

    # R√©initialiser identification
    copy.student = None
    copy.is_identified = False
    copy.status = Copy.Status.PENDING
    copy.save()

    # Supprimer ancien OCR result
    OCRResult.objects.filter(copy=copy).delete()

    # Relancer OCR (Celery task)
    job = reidentify_copy.delay(str(copy.id))

    return Response({
        'success': True,
        'job_id': job.id,
        'message': 'Re-identification started'
    }, status=202)
```

---

## üìä Statistiques Identification

### GET /api/identification/statistics/

**Description** : Statistiques globales identification

**Query Parameters** :
- `exam_id` (optionnel) : Filtrer par examen

**R√©ponse Success (200 OK)** :

```json
{
  "total_copies": 28,
  "identified": 25,
  "unidentified": 3,
  "by_mode": {
    "AUTO": 20,
    "SEMI_AUTO": 5,
    "MANUAL": 3
  },
  "identification_rate": {
    "auto": 71.4,
    "semi_auto": 17.9,
    "manual": 10.7
  },
  "average_confidence": 0.78
}
```

**Code Backend** :

```python
from django.db.models import Avg, Count

@action(detail=False, methods=['get'])
def statistics(self, request):
    """Statistiques identification."""

    queryset = Copy.objects.all()

    exam_id = request.query_params.get('exam_id')
    if exam_id:
        queryset = queryset.filter(exam_id=exam_id)

    total = queryset.count()
    identified = queryset.filter(is_identified=True).count()

    # Par mode OCR
    by_mode = {}
    for mode in ['AUTO', 'SEMI_AUTO', 'MANUAL']:
        count = queryset.filter(ocrresult__ocr_mode=mode).count()
        by_mode[mode] = count

    # Taux
    rate = {
        'auto': (by_mode['AUTO'] / total * 100) if total > 0 else 0,
        'semi_auto': (by_mode['SEMI_AUTO'] / total * 100) if total > 0 else 0,
        'manual': (by_mode['MANUAL'] / total * 100) if total > 0 else 0
    }

    # Confidence moyenne
    avg_conf = OCRResult.objects.filter(
        copy__in=queryset
    ).aggregate(avg=Avg('confidence'))['avg'] or 0.0

    return Response({
        'total_copies': total,
        'identified': identified,
        'unidentified': total - identified,
        'by_mode': by_mode,
        'identification_rate': rate,
        'average_confidence': round(avg_conf, 2)
    })
```

---

## üìù Conclusion

L'API Identification fournit les outils n√©cessaires pour g√©rer l'identification des copies avec support des 3 modes (AUTO, SEMI-AUTO, MANUAL).

**Points cl√©s** :
- Top-5 candidats OCR avec sources
- S√©lection assist√©e (SEMI-AUTO)
- Recherche manuelle (MANUAL)
- Audit trail complet
- Statistiques d'identification

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
