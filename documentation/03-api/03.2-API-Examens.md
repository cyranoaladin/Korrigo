# 03.2 - API Gestion des Examens

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Vue d'Ensemble

L'API Examens permet de **cr√©er, modifier, lister et g√©rer** les examens, ainsi que d'uploader les scans PDF et listes CSV d'√©tudiants.

### Base URL

```
http://localhost:8088/api/exams/
```

### Authentification

Toutes les routes n√©cessitent une **authentification** (session Django).

### Permissions

| Action | Admin | Teacher | Student |
|--------|:-----:|:-------:|:-------:|
| Liste examens | ‚úÖ Tous | ‚úÖ Assign√©s | ‚úÖ Publi√©s |
| Cr√©er examen | ‚úÖ | ‚ùå | ‚ùå |
| Modifier examen | ‚úÖ | ‚ùå | ‚ùå |
| Supprimer examen | ‚úÖ | ‚ùå | ‚ùå |
| Upload PDF/CSV | ‚úÖ | ‚ùå | ‚ùå |

---

## üìã Endpoints

### 1. GET /api/exams/

**Description** : Lister les examens

**Permissions** : Tous les utilisateurs authentifi√©s

**Query Parameters** :
- `limit` (optionnel) : Nombre max de r√©sultats (d√©faut: 50)
- `offset` (optionnel) : Pagination offset
- `is_published` (optionnel) : Filtrer par statut publi√© (`true`/`false`)
- `creator_id` (optionnel) : Filtrer par cr√©ateur (admin uniquement)

**R√©ponse Success (200 OK)** :

```json
[
  {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "name": "Bac Blanc Math√©matiques 2026",
    "date": "2026-02-03",
    "creator": {
      "id": 1,
      "username": "test_admin",
      "email": "admin@korrigo.tn"
    },
    "grading_structure": [
      {
        "question": "1",
        "title": "√âtude de fonction",
        "max_score": 5.0,
        "sub_questions": [
          {
            "id": "1.a",
            "title": "Limites",
            "max_score": 1.5
          },
          {
            "id": "1.b",
            "title": "D√©riv√©e",
            "max_score": 2.0
          }
        ]
      }
    ],
    "is_processed": true,
    "is_published": false,
    "copies_count": 28,
    "correctors": [
      {
        "id": 2,
        "username": "test_prof",
        "email": "prof@korrigo.tn"
      }
    ],
    "created_at": "2026-02-03T10:30:00Z",
    "updated_at": "2026-02-03T14:00:00Z"
  }
]
```

**Code Backend** :

```python
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from exams.models import Exam
from exams.serializers import ExamSerializer

class ExamViewSet(viewsets.ModelViewSet):
    """ViewSet pour gestion des examens."""

    serializer_class = ExamSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        """
        Filtrer examens selon profil.

        - Admin: tous les examens
        - Teacher: examens assign√©s comme correcteur
        - Student: examens publi√©s uniquement
        """
        user = self.request.user

        if user.is_superuser:
            queryset = Exam.objects.all()
        elif user.is_staff:
            # Enseignant: examens o√π il est correcteur
            queryset = Exam.objects.filter(correctors=user)
        else:
            # √âtudiant: examens publi√©s uniquement
            queryset = Exam.objects.filter(is_published=True)

        # Filtres optionnels
        is_published = self.request.query_params.get('is_published')
        if is_published is not None:
            queryset = queryset.filter(is_published=is_published.lower() == 'true')

        return queryset.select_related('creator').prefetch_related('correctors')
```

**Exemple cURL** :

```bash
# Liste tous les examens
curl -X GET http://localhost:8088/api/exams/ \
  -b cookies.txt

# Filtrer examens publi√©s
curl -X GET "http://localhost:8088/api/exams/?is_published=true" \
  -b cookies.txt

# Pagination
curl -X GET "http://localhost:8088/api/exams/?limit=10&offset=20" \
  -b cookies.txt
```

**Exemple Axios** :

```typescript
// Liste tous les examens
const response = await api.get('/api/exams/')
const exams = response.data

// Filtrer
const publishedExams = await api.get('/api/exams/', {
  params: { is_published: true }
})
```

---

### 2. POST /api/exams/

**Description** : Cr√©er un nouvel examen

**Permissions** : Admin uniquement

**Headers** :
```
Content-Type: application/json
X-CSRFToken: <csrf-token>
```

**Body** :

```json
{
  "name": "Bac Blanc Math√©matiques 2026",
  "date": "2026-02-03",
  "grading_structure": [
    {
      "question": "1",
      "title": "√âtude de fonction",
      "max_score": 5.0,
      "sub_questions": [
        {
          "id": "1.a",
          "title": "Limites",
          "max_score": 1.5
        },
        {
          "id": "1.b",
          "title": "D√©riv√©e",
          "max_score": 2.0
        },
        {
          "id": "1.c",
          "title": "Tableau de variations",
          "max_score": 1.5
        }
      ]
    },
    {
      "question": "2",
      "title": "Probabilit√©s",
      "max_score": 4.0,
      "sub_questions": [
        {
          "id": "2.a",
          "title": "Loi binomiale",
          "max_score": 2.0
        },
        {
          "id": "2.b",
          "title": "Loi normale",
          "max_score": 2.0
        }
      ]
    }
  ]
}
```

**R√©ponse Success (201 Created)** :

```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "name": "Bac Blanc Math√©matiques 2026",
  "date": "2026-02-03",
  "creator": {
    "id": 1,
    "username": "test_admin",
    "email": "admin@korrigo.tn"
  },
  "grading_structure": [...],
  "is_processed": false,
  "is_published": false,
  "copies_count": 0,
  "correctors": [],
  "created_at": "2026-02-03T10:30:00Z",
  "updated_at": "2026-02-03T10:30:00Z"
}
```

**R√©ponse Error (400 Bad Request)** :

```json
{
  "name": ["This field is required."],
  "grading_structure": ["Invalid structure: missing max_score"]
}
```

**Code Backend** :

```python
class ExamViewSet(viewsets.ModelViewSet):

    def create(self, request):
        """
        Cr√©er un examen.

        Valide:
        - name non vide
        - date valide
        - grading_structure valide (JSON schema)
        """
        # V√©rifier permissions
        if not request.user.is_superuser:
            return Response({'error': 'Admin only'}, status=403)

        # Valider donn√©es
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        # Valider grading_structure
        grading_structure = serializer.validated_data.get('grading_structure', [])
        self._validate_grading_structure(grading_structure)

        # Cr√©er examen
        exam = serializer.save(creator=request.user)

        return Response(
            ExamSerializer(exam).data,
            status=status.HTTP_201_CREATED
        )

    def _validate_grading_structure(self, structure):
        """Valider structure de notation."""
        if not structure:
            raise ValidationError("Grading structure cannot be empty")

        total_score = 0

        for question in structure:
            # V√©rifier champs requis
            if not all(k in question for k in ['question', 'title', 'max_score', 'sub_questions']):
                raise ValidationError(f"Invalid question structure: {question}")

            # V√©rifier score positif
            if question['max_score'] <= 0:
                raise ValidationError(f"Max score must be positive: {question['question']}")

            # Valider sous-questions
            sub_total = 0
            for sub in question['sub_questions']:
                if not all(k in sub for k in ['id', 'title', 'max_score']):
                    raise ValidationError(f"Invalid sub-question: {sub}")

                if sub['max_score'] <= 0:
                    raise ValidationError(f"Sub-question max score must be positive: {sub['id']}")

                sub_total += sub['max_score']

            # V√©rifier coh√©rence scores
            if abs(sub_total - question['max_score']) > 0.01:
                raise ValidationError(
                    f"Question {question['question']}: sum of sub-questions ({sub_total}) "
                    f"does not match max_score ({question['max_score']})"
                )

            total_score += question['max_score']

        # V√©rifier score total raisonnable
        if total_score > 100:
            raise ValidationError(f"Total score ({total_score}) exceeds 100 points")
```

**Exemple cURL** :

```bash
curl -X POST http://localhost:8088/api/exams/ \
  -H "Content-Type: application/json" \
  -H "X-CSRFToken: $(grep csrftoken cookies.txt | cut -f7)" \
  -b cookies.txt \
  -d '{
    "name": "Bac Blanc Maths 2026",
    "date": "2026-02-03",
    "grading_structure": [...]
  }'
```

**Exemple Axios** :

```typescript
const newExam = await api.post('/api/exams/', {
  name: 'Bac Blanc Math√©matiques 2026',
  date: '2026-02-03',
  grading_structure: [
    {
      question: '1',
      title: '√âtude de fonction',
      max_score: 5.0,
      sub_questions: [...]
    }
  ]
})
```

---

### 3. GET /api/exams/{id}/

**Description** : R√©cup√©rer d√©tails d'un examen

**Permissions** :
- Admin: Tous les examens
- Teacher: Examens assign√©s
- Student: Examens publi√©s uniquement

**URL Parameters** :
- `id` : UUID de l'examen

**R√©ponse Success (200 OK)** :

```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "name": "Bac Blanc Math√©matiques 2026",
  "date": "2026-02-03",
  "creator": {
    "id": 1,
    "username": "test_admin",
    "email": "admin@korrigo.tn"
  },
  "grading_structure": [...],
  "is_processed": true,
  "is_published": false,
  "pdf_source": "http://localhost:8088/media/exams/pdfs/exam_123.pdf",
  "students_csv": "http://localhost:8088/media/exams/csv/students_123.csv",
  "copies": [
    {
      "id": "copy-uuid-1",
      "anonymous_id": "A3-001",
      "status": "READY",
      "is_identified": true,
      "corrector": {
        "id": 2,
        "username": "test_prof"
      }
    }
  ],
  "copies_count": 28,
  "copies_by_status": {
    "PENDING": 0,
    "READY": 15,
    "IN_PROGRESS": 8,
    "COMPLETED": 5,
    "PUBLISHED": 0
  },
  "correctors": [
    {
      "id": 2,
      "username": "test_prof",
      "assigned_copies_count": 10
    }
  ],
  "statistics": {
    "total_copies": 28,
    "identified_copies": 25,
    "auto_identified": 20,
    "semi_auto": 3,
    "manual": 2,
    "unidentified": 3,
    "corrected_copies": 5,
    "average_score": 14.2,
    "max_score": 20.0
  },
  "created_at": "2026-02-03T10:30:00Z",
  "updated_at": "2026-02-05T16:00:00Z"
}
```

**R√©ponse Error (404 Not Found)** :

```json
{
  "detail": "Not found."
}
```

**R√©ponse Error (403 Forbidden)** :

```json
{
  "error": "You do not have permission to access this exam."
}
```

**Code Backend** :

```python
class ExamViewSet(viewsets.ModelViewSet):

    def retrieve(self, request, pk=None):
        """R√©cup√©rer d√©tails examen avec statistiques."""

        exam = self.get_object()

        # V√©rifier permissions
        if not self._can_access_exam(request.user, exam):
            return Response(
                {'error': 'You do not have permission to access this exam.'},
                status=403
            )

        # Serializer avec statistiques
        serializer = ExamDetailSerializer(exam, context={'request': request})
        return Response(serializer.data)

    def _can_access_exam(self, user, exam):
        """V√©rifier si utilisateur peut acc√©der √† cet examen."""
        if user.is_superuser:
            return True
        if user.is_staff and exam.correctors.filter(id=user.id).exists():
            return True
        if not user.is_staff and exam.is_published:
            return True
        return False
```

**Exemple cURL** :

```bash
curl -X GET http://localhost:8088/api/exams/123e4567-e89b-12d3-a456-426614174000/ \
  -b cookies.txt
```

**Exemple Axios** :

```typescript
const exam = await api.get(`/api/exams/${examId}/`)
console.log(exam.data.statistics)
```

---

### 4. PUT /api/exams/{id}/

**Description** : Modifier un examen existant

**Permissions** : Admin uniquement

**Body** :

```json
{
  "name": "Bac Blanc Math√©matiques 2026 (Modifi√©)",
  "date": "2026-02-04",
  "grading_structure": [...]
}
```

**R√©ponse Success (200 OK)** :

```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "name": "Bac Blanc Math√©matiques 2026 (Modifi√©)",
  "date": "2026-02-04",
  ...
}
```

**Contraintes** :
- ‚ùå Ne peut pas modifier si `is_published=True`
- ‚ùå Ne peut pas modifier si copies d√©j√† corrig√©es
- ‚úÖ Peut modifier nom, date, grading_structure si pas encore publi√©

**Code Backend** :

```python
class ExamViewSet(viewsets.ModelViewSet):

    def update(self, request, pk=None):
        """Modifier examen."""

        exam = self.get_object()

        # V√©rifier permissions
        if not request.user.is_superuser:
            return Response({'error': 'Admin only'}, status=403)

        # V√©rifier si modifiable
        if exam.is_published:
            return Response({
                'error': 'Cannot modify published exam'
            }, status=400)

        # V√©rifier si copies corrig√©es
        if exam.copies.filter(is_locked=True).exists():
            return Response({
                'error': 'Cannot modify exam with locked copies'
            }, status=400)

        # Mettre √† jour
        serializer = self.get_serializer(exam, data=request.data, partial=False)
        serializer.is_valid(raise_exception=True)
        serializer.save()

        return Response(serializer.data)
```

---

### 5. DELETE /api/exams/{id}/

**Description** : Supprimer un examen

**Permissions** : Admin uniquement

**R√©ponse Success (204 No Content)** : Pas de body

**R√©ponse Error (400 Bad Request)** :

```json
{
  "error": "Cannot delete published exam"
}
```

**Contraintes** :
- ‚ùå Ne peut pas supprimer si `is_published=True`
- ‚ùå Ne peut pas supprimer si copies corrig√©es
- ‚úÖ Peut supprimer si aucune copie ou copies non corrig√©es

**Code Backend** :

```python
class ExamViewSet(viewsets.ModelViewSet):

    def destroy(self, request, pk=None):
        """Supprimer examen."""

        exam = self.get_object()

        # V√©rifier permissions
        if not request.user.is_superuser:
            return Response({'error': 'Admin only'}, status=403)

        # V√©rifier si supprimable
        if exam.is_published:
            return Response({
                'error': 'Cannot delete published exam'
            }, status=400)

        if exam.copies.filter(is_locked=True).exists():
            return Response({
                'error': 'Cannot delete exam with locked copies'
            }, status=400)

        # Supprimer (cascade delete copies, pages, etc.)
        exam.delete()

        return Response(status=status.HTTP_204_NO_CONTENT)
```

---

### 6. POST /api/exams/upload/

**Description** : Upload PDF scans et CSV √©tudiants, lancer traitement batch

**Permissions** : Admin uniquement

**Headers** :
```
Content-Type: multipart/form-data
X-CSRFToken: <csrf-token>
```

**Form Data** :
- `exam_id` : UUID de l'examen (string)
- `pdf_file` : Fichier PDF (max 100 MB)
- `students_csv` : Fichier CSV (max 10 MB)
- `batch_mode` : `"true"` ou `"false"` (string)

**R√©ponse Success (202 Accepted)** :

```json
{
  "job_id": "abc123-def456-ghi789",
  "status": "processing",
  "message": "Processing started",
  "estimated_time": "120s",
  "exam_id": "123e4567-e89b-12d3-a456-426614174000"
}
```

**R√©ponse Error (400 Bad Request)** :

```json
{
  "error": "Missing required field: pdf_file"
}
```

**R√©ponse Error (413 Payload Too Large)** :

```json
{
  "error": "PDF file too large (max 100 MB)"
}
```

**Code Backend** :

```python
from processing.tasks import process_batch_pdf

class ExamViewSet(viewsets.ModelViewSet):

    @action(detail=False, methods=['post'])
    def upload(self, request):
        """
        Upload PDF et CSV, lancer traitement batch.

        Form Data:
            exam_id: UUID
            pdf_file: File (PDF)
            students_csv: File (CSV)
            batch_mode: "true" | "false"
        """
        # V√©rifier permissions
        if not request.user.is_superuser:
            return Response({'error': 'Admin only'}, status=403)

        # R√©cup√©rer donn√©es
        exam_id = request.data.get('exam_id')
        pdf_file = request.FILES.get('pdf_file')
        students_csv = request.FILES.get('students_csv')
        batch_mode = request.data.get('batch_mode', 'false') == 'true'

        # Valider
        if not all([exam_id, pdf_file, students_csv]):
            return Response({
                'error': 'Missing required fields'
            }, status=400)

        # V√©rifier taille fichiers
        if pdf_file.size > 100 * 1024 * 1024:  # 100 MB
            return Response({
                'error': 'PDF file too large (max 100 MB)'
            }, status=413)

        if students_csv.size > 10 * 1024 * 1024:  # 10 MB
            return Response({
                'error': 'CSV file too large (max 10 MB)'
            }, status=413)

        # R√©cup√©rer examen
        try:
            exam = Exam.objects.get(id=exam_id)
        except Exam.DoesNotExist:
            return Response({'error': 'Exam not found'}, status=404)

        # Sauvegarder fichiers
        exam.pdf_source = pdf_file
        exam.students_csv = students_csv
        exam.save()

        # Lancer traitement asynchrone (Celery)
        job = process_batch_pdf.delay(
            exam_id=str(exam.id),
            pdf_path=exam.pdf_source.path,
            csv_path=exam.students_csv.path,
            batch_mode=batch_mode
        )

        # Cr√©er BatchProcessingJob
        from processing.models import BatchProcessingJob
        BatchProcessingJob.objects.create(
            exam=exam,
            celery_task_id=job.id,
            status='PENDING'
        )

        return Response({
            'job_id': job.id,
            'status': 'processing',
            'message': 'Processing started',
            'estimated_time': '120s',
            'exam_id': str(exam.id)
        }, status=status.HTTP_202_ACCEPTED)
```

**Exemple cURL** :

```bash
curl -X POST http://localhost:8088/api/exams/upload/ \
  -H "X-CSRFToken: $(grep csrftoken cookies.txt | cut -f7)" \
  -b cookies.txt \
  -F "exam_id=123e4567-e89b-12d3-a456-426614174000" \
  -F "pdf_file=@eval_loi_binom_log.pdf" \
  -F "students_csv=@G3_EDS_MATHS.csv" \
  -F "batch_mode=true"
```

**Exemple Axios** :

```typescript
const formData = new FormData()
formData.append('exam_id', examId)
formData.append('pdf_file', pdfFile)  // File object from input
formData.append('students_csv', csvFile)
formData.append('batch_mode', 'true')

const response = await api.post('/api/exams/upload/', formData, {
  headers: {
    'Content-Type': 'multipart/form-data'
  }
})

const jobId = response.data.job_id
// Poll job status...
```

---

### 7. POST /api/exams/{id}/assign-correctors/

**Description** : Assigner correcteurs aux copies de l'examen

**Permissions** : Admin uniquement

**Body** :

```json
{
  "assignments": [
    {
      "corrector_id": 2,
      "copy_ids": [
        "copy-uuid-1",
        "copy-uuid-2",
        "copy-uuid-3"
      ]
    },
    {
      "corrector_id": 3,
      "copy_ids": [
        "copy-uuid-4",
        "copy-uuid-5"
      ]
    }
  ]
}
```

**R√©ponse Success (200 OK)** :

```json
{
  "success": true,
  "assignments_count": 5,
  "message": "Correctors assigned successfully"
}
```

**Code Backend** :

```python
class ExamViewSet(viewsets.ModelViewSet):

    @action(detail=True, methods=['post'])
    def assign_correctors(self, request, pk=None):
        """Assigner correcteurs aux copies."""

        exam = self.get_object()

        if not request.user.is_superuser:
            return Response({'error': 'Admin only'}, status=403)

        assignments = request.data.get('assignments', [])

        assignments_count = 0

        for assignment in assignments:
            corrector_id = assignment['corrector_id']
            copy_ids = assignment['copy_ids']

            # V√©rifier que corrector est enseignant
            corrector = User.objects.get(id=corrector_id)
            if not corrector.is_staff:
                return Response({
                    'error': f'User {corrector.username} is not a teacher'
                }, status=400)

            # Assigner copies
            Copy.objects.filter(id__in=copy_ids).update(corrector=corrector)
            assignments_count += len(copy_ids)

            # Ajouter correcteur √† l'examen
            exam.correctors.add(corrector)

        return Response({
            'success': True,
            'assignments_count': assignments_count,
            'message': 'Correctors assigned successfully'
        })
```

---

### 8. POST /api/exams/{id}/publish/

**Description** : Publier les r√©sultats de l'examen (rendre visible aux √©tudiants)

**Permissions** : Admin uniquement

**R√©ponse Success (200 OK)** :

```json
{
  "success": true,
  "exam_id": "123e4567-e89b-12d3-a456-426614174000",
  "published_copies_count": 28,
  "message": "Exam published successfully"
}
```

**R√©ponse Error (400 Bad Request)** :

```json
{
  "error": "Cannot publish: 5 copies are not yet corrected"
}
```

**Code Backend** :

```python
class ExamViewSet(viewsets.ModelViewSet):

    @action(detail=True, methods=['post'])
    def publish(self, request, pk=None):
        """Publier r√©sultats examen."""

        exam = self.get_object()

        if not request.user.is_superuser:
            return Response({'error': 'Admin only'}, status=403)

        # V√©rifier que toutes copies sont corrig√©es et verrouill√©es
        uncorrected_copies = exam.copies.filter(is_locked=False).count()

        if uncorrected_copies > 0:
            return Response({
                'error': f'Cannot publish: {uncorrected_copies} copies are not yet corrected'
            }, status=400)

        # Publier
        exam.is_published = True
        exam.save()

        # Mettre √† jour status copies
        published_count = exam.copies.update(status=Copy.Status.PUBLISHED)

        return Response({
            'success': True,
            'exam_id': str(exam.id),
            'published_copies_count': published_count,
            'message': 'Exam published successfully'
        })
```

---

## üìù Serializers Django

### ExamSerializer

```python
from rest_framework import serializers
from exams.models import Exam

class ExamSerializer(serializers.ModelSerializer):
    """Serializer basique pour liste examens."""

    creator = UserSerializer(read_only=True)
    correctors = UserSerializer(many=True, read_only=True)
    copies_count = serializers.IntegerField(source='copies.count', read_only=True)

    class Meta:
        model = Exam
        fields = [
            'id', 'name', 'date', 'creator', 'grading_structure',
            'is_processed', 'is_published', 'copies_count', 'correctors',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'creator', 'created_at', 'updated_at']


class ExamDetailSerializer(serializers.ModelSerializer):
    """Serializer d√©taill√© avec statistiques."""

    creator = UserSerializer(read_only=True)
    correctors = serializers.SerializerMethodField()
    copies = CopySerializer(many=True, read_only=True)
    copies_by_status = serializers.SerializerMethodField()
    statistics = serializers.SerializerMethodField()

    class Meta:
        model = Exam
        fields = [
            'id', 'name', 'date', 'creator', 'grading_structure',
            'is_processed', 'is_published', 'pdf_source', 'students_csv',
            'copies', 'copies_count', 'copies_by_status',
            'correctors', 'statistics',
            'created_at', 'updated_at'
        ]

    def get_correctors(self, obj):
        """Correctors avec nombre de copies assign√©es."""
        correctors_data = []
        for corrector in obj.correctors.all():
            correctors_data.append({
                'id': corrector.id,
                'username': corrector.username,
                'assigned_copies_count': obj.copies.filter(corrector=corrector).count()
            })
        return correctors_data

    def get_copies_by_status(self, obj):
        """Distribution copies par statut."""
        from django.db.models import Count
        from exams.models import Copy

        status_counts = obj.copies.values('status').annotate(count=Count('id'))
        return {item['status']: item['count'] for item in status_counts}

    def get_statistics(self, obj):
        """Statistiques examen."""
        from django.db.models import Avg

        copies = obj.copies.all()
        identified = copies.filter(is_identified=True)

        return {
            'total_copies': copies.count(),
            'identified_copies': identified.count(),
            'unidentified': copies.filter(is_identified=False).count(),
            'corrected_copies': copies.filter(is_locked=True).count(),
            'average_score': copies.filter(is_locked=True).aggregate(
                avg=Avg('total_score')
            )['avg'] or 0.0,
            'max_score': sum(q['max_score'] for q in obj.grading_structure)
        }
```

---

## üìù Conclusion

L'API Examens fournit toutes les op√©rations CRUD n√©cessaires pour g√©rer les examens, avec upload de fichiers, traitement batch asynchrone, et gestion des correcteurs.

**Points cl√©s** :
- CRUD complet (Create, Read, Update, Delete)
- Upload PDF/CSV avec traitement batch
- Assignation correcteurs
- Publication r√©sultats
- Statistiques d√©taill√©es
- Permissions granulaires

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
