# 03.3 - API Gestion des Copies

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Vue d'Ensemble

L'API Copies permet aux **enseignants** de g√©rer la correction des copies : lister, ouvrir, annoter, noter, sauvegarder et verrouiller.

### Base URL

```
http://localhost:8088/api/grading/copies/
```

### Permissions

| Action | Admin | Teacher | Student |
|--------|:-----:|:-------:|:-------:|
| Liste copies | ‚úÖ Toutes | ‚úÖ Assign√©es | ‚úÖ Propres (publi√©es) |
| Voir copie | ‚úÖ | ‚úÖ (assign√©e) | ‚úÖ (propre + publi√©e) |
| Modifier copie | ‚úÖ | ‚úÖ (assign√©e + non verrouill√©e) | ‚ùå |
| Verrouiller | ‚úÖ | ‚úÖ (assign√©e) | ‚ùå |
| D√©verrouiller | ‚úÖ | ‚ùå | ‚ùå |

---

## üìã Endpoints

### 1. GET /api/grading/copies/

**Description** : Lister les copies √† corriger

**Permissions** : Tous les utilisateurs authentifi√©s (filtre selon profil)

**Query Parameters** :
- `exam_id` (optionnel) : Filtrer par examen (UUID)
- `status` (optionnel) : Filtrer par statut (`PENDING`, `READY`, `IN_PROGRESS`, `COMPLETED`, `PUBLISHED`)
- `is_identified` (optionnel) : Filtrer par identification (`true`/`false`)
- `corrector_id` (optionnel, admin uniquement) : Filtrer par correcteur

**R√©ponse Success (200 OK)** :

```json
[
  {
    "id": "copy-uuid-1",
    "exam": {
      "id": "exam-uuid-1",
      "name": "Bac Blanc Math√©matiques 2026",
      "date": "2026-02-03"
    },
    "anonymous_id": "A3-001",
    "student": {
      "id": "student-uuid-1",
      "first_name": "Jean",
      "last_name": "Dupont",
      "email": "jean.dupont@korrigo.local"
    },
    "corrector": {
      "id": 2,
      "username": "test_prof",
      "email": "prof@korrigo.tn"
    },
    "status": "READY",
    "is_identified": true,
    "is_locked": false,
    "total_score": null,
    "pages_count": 6,
    "created_at": "2026-02-03T10:30:00Z",
    "corrected_at": null
  }
]
```

**Code Backend** :

```python
from rest_framework import viewsets
from exams.models import Copy
from grading.serializers import CopySerializer

class CopyViewSet(viewsets.ModelViewSet):
    """ViewSet pour gestion des copies."""

    serializer_class = CopySerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        """Filtrer copies selon profil."""
        user = self.request.user

        if user.is_superuser:
            queryset = Copy.objects.all()
        elif user.is_staff:
            queryset = Copy.objects.filter(corrector=user)
        else:
            # √âtudiant: copies publi√©es uniquement
            queryset = Copy.objects.filter(
                student__user=user,
                status=Copy.Status.PUBLISHED
            )

        # Filtres
        exam_id = self.request.query_params.get('exam_id')
        if exam_id:
            queryset = queryset.filter(exam_id=exam_id)

        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)

        is_identified = self.request.query_params.get('is_identified')
        if is_identified is not None:
            queryset = queryset.filter(is_identified=is_identified.lower() == 'true')

        return queryset.select_related('exam', 'student', 'corrector')
```

**Exemple cURL** :

```bash
# Liste mes copies assign√©es
curl -X GET http://localhost:8088/api/grading/copies/ \
  -b cookies.txt

# Filtrer par examen
curl -X GET "http://localhost:8088/api/grading/copies/?exam_id=exam-uuid-1" \
  -b cookies.txt

# Copies pr√™tes √† corriger
curl -X GET "http://localhost:8088/api/grading/copies/?status=READY" \
  -b cookies.txt
```

---

### 2. GET /api/grading/copies/{id}/

**Description** : R√©cup√©rer d√©tails d'une copie (pour correction)

**Permissions** :
- Admin: Toutes les copies
- Teacher: Copies assign√©es uniquement
- Student: Propres copies publi√©es uniquement

**R√©ponse Success (200 OK)** :

```json
{
  "id": "copy-uuid-1",
  "exam": {
    "id": "exam-uuid-1",
    "name": "Bac Blanc Math√©matiques 2026",
    "grading_structure": [
      {
        "question": "1",
        "title": "√âtude de fonction",
        "max_score": 5.0,
        "sub_questions": [
          {"id": "1.a", "title": "Limites", "max_score": 1.5},
          {"id": "1.b", "title": "D√©riv√©e", "max_score": 2.0}
        ]
      }
    ]
  },
  "anonymous_id": "A3-001",
  "student": {
    "id": "student-uuid-1",
    "first_name": "Jean",
    "last_name": "Dupont"
  },
  "corrector": {
    "id": 2,
    "username": "test_prof"
  },
  "status": "READY",
  "is_identified": true,
  "is_locked": false,
  "pdf_url": "http://localhost:8088/media/copies/pdfs/copy_uuid.pdf",
  "pages": [
    {
      "id": "page-uuid-1",
      "page_number": 1,
      "image_url": "http://localhost:8088/media/copies/pages/page_1.jpg",
      "width": 2480,
      "height": 3508
    }
  ],
  "grades": [
    {
      "id": "grade-uuid-1",
      "question_id": "1.a",
      "score": 1.5,
      "max_score": 1.5,
      "comment": "Parfait",
      "graded_at": "2026-02-05T14:30:00Z"
    }
  ],
  "annotations": [
    {
      "id": "annotation-uuid-1",
      "page_id": "page-uuid-1",
      "type": "HIGHLIGHT",
      "content": "",
      "coordinates": {"x": 100, "y": 200, "width": 150, "height": 20},
      "color": "#FFFF00",
      "created_at": "2026-02-05T14:25:00Z"
    }
  ],
  "total_score": 1.5,
  "created_at": "2026-02-03T10:30:00Z",
  "corrected_at": null
}
```

**Code Backend** :

```python
def retrieve(self, request, pk=None):
    """R√©cup√©rer copie avec toutes donn√©es."""
    copy = self.get_object()

    # V√©rifier permissions
    if not self._can_access_copy(request.user, copy):
        return Response({'error': 'Access denied'}, status=403)

    serializer = CopyDetailSerializer(copy)
    return Response(serializer.data)

def _can_access_copy(self, user, copy):
    """V√©rifier acc√®s copie."""
    if user.is_superuser:
        return True
    if user.is_staff and copy.corrector == user:
        return True
    if not user.is_staff and copy.student and copy.student.user == user and copy.status == Copy.Status.PUBLISHED:
        return True
    return False
```

---

### 3. PATCH /api/grading/copies/{id}/

**Description** : Mettre √† jour copie (notes, annotations, status)

**Permissions** : Admin ou enseignant assign√© (copie non verrouill√©e)

**Body** :

```json
{
  "grades": [
    {
      "question_id": "1.a",
      "score": 1.5,
      "max_score": 1.5,
      "comment": "Parfait"
    },
    {
      "question_id": "1.b",
      "score": 1.8,
      "max_score": 2.0,
      "comment": "Tr√®s bien"
    }
  ],
  "annotations": [
    {
      "page_id": "page-uuid-1",
      "type": "HIGHLIGHT",
      "coordinates": {"x": 100, "y": 200, "width": 150, "height": 20},
      "color": "#FFFF00"
    }
  ],
  "status": "IN_PROGRESS"
}
```

**R√©ponse Success (200 OK)** :

```json
{
  "id": "copy-uuid-1",
  "total_score": 3.3,
  "status": "IN_PROGRESS",
  "grades": [...],
  "annotations": [...]
}
```

**R√©ponse Error (403 Forbidden)** :

```json
{
  "error": "Copy is locked"
}
```

**Code Backend** :

```python
def partial_update(self, request, pk=None):
    """Mettre √† jour copie (sauvegarde draft)."""
    copy = self.get_object()

    # V√©rifier permissions
    if not request.user.is_superuser and copy.corrector != request.user:
        return Response({'error': 'Not your copy'}, status=403)

    # V√©rifier verrouillage
    if copy.is_locked:
        return Response({'error': 'Copy is locked'}, status=403)

    # Mettre √† jour notes
    grades_data = request.data.get('grades', [])
    for grade_data in grades_data:
        Grade.objects.update_or_create(
            copy=copy,
            question_id=grade_data['question_id'],
            defaults={
                'grader': request.user,
                'score': Decimal(str(grade_data['score'])),
                'max_score': Decimal(str(grade_data['max_score'])),
                'comment': grade_data.get('comment', '')
            }
        )

    # Mettre √† jour annotations
    annotations_data = request.data.get('annotations', [])
    copy.annotations.all().delete()

    for annot_data in annotations_data:
        page = Page.objects.get(id=annot_data['page_id'])
        Annotation.objects.create(
            copy=copy,
            author=request.user,
            page=page,
            annotation_type=annot_data['type'],
            content=annot_data.get('content', ''),
            coordinates=annot_data['coordinates'],
            color=annot_data.get('color', '#FFFF00')
        )

    # Calculer total
    total = sum(g.score for g in copy.grades.all())
    copy.total_score = total
    copy.status = request.data.get('status', copy.status)
    copy.save()

    return Response(CopyDetailSerializer(copy).data)
```

---

### 4. POST /api/grading/copies/{id}/lock/

**Description** : Verrouiller copie apr√®s correction compl√®te

**Permissions** : Admin ou enseignant assign√©

**R√©ponse Success (200 OK)** :

```json
{
  "success": true,
  "copy": {
    "id": "copy-uuid-1",
    "is_locked": true,
    "status": "COMPLETED",
    "total_score": 18.5,
    "corrected_at": "2026-02-05T16:30:00Z"
  },
  "message": "Copy locked successfully"
}
```

**R√©ponse Error (400 Bad Request)** :

```json
{
  "error": "All questions must be graded before locking",
  "missing_questions": ["2.b", "3.a"]
}
```

**Code Backend** :

```python
from django.utils import timezone

@action(detail=True, methods=['post'])
def lock(self, request, pk=None):
    """Verrouiller copie."""
    copy = self.get_object()

    # Permissions
    if not request.user.is_superuser and copy.corrector != request.user:
        return Response({'error': 'Not your copy'}, status=403)

    # V√©rifier d√©j√† verrouill√©e
    if copy.is_locked:
        return Response({'error': 'Copy already locked'}, status=400)

    # V√©rifier exhaustivit√© notation
    exam_questions = self._extract_all_question_ids(copy.exam.grading_structure)
    graded_questions = set(copy.grades.values_list('question_id', flat=True))
    missing = set(exam_questions) - graded_questions

    if missing:
        return Response({
            'error': 'All questions must be graded before locking',
            'missing_questions': list(missing)
        }, status=400)

    # Verrouiller
    copy.is_locked = True
    copy.status = Copy.Status.COMPLETED
    copy.corrected_at = timezone.now()
    copy.save()

    return Response({
        'success': True,
        'copy': CopySerializer(copy).data,
        'message': 'Copy locked successfully'
    })

def _extract_all_question_ids(self, grading_structure):
    """Extraire IDs sous-questions."""
    ids = []
    for q in grading_structure:
        for sub in q.get('sub_questions', []):
            ids.append(sub['id'])
    return ids
```

---

### 5. POST /api/grading/copies/{id}/unlock/

**Description** : D√©verrouiller copie (admin uniquement)

**Permissions** : Admin uniquement

**R√©ponse Success (200 OK)** :

```json
{
  "success": true,
  "copy": {
    "id": "copy-uuid-1",
    "is_locked": false,
    "status": "IN_PROGRESS"
  },
  "message": "Copy unlocked successfully"
}
```

**Code Backend** :

```python
@action(detail=True, methods=['post'])
def unlock(self, request, pk=None):
    """D√©verrouiller copie (admin uniquement)."""
    if not request.user.is_superuser:
        return Response({'error': 'Admin only'}, status=403)

    copy = self.get_object()

    copy.is_locked = False
    copy.status = Copy.Status.IN_PROGRESS
    copy.save()

    return Response({
        'success': True,
        'copy': CopySerializer(copy).data,
        'message': 'Copy unlocked successfully'
    })
```

---

### 6. GET /api/grading/copies/{id}/pdf/

**Description** : T√©l√©charger PDF de la copie

**Permissions** : Admin, enseignant assign√©, ou √©tudiant propri√©taire (si publi√©e)

**R√©ponse** : Fichier PDF (Content-Type: application/pdf)

**Code Backend** :

```python
from django.http import FileResponse
import os

@action(detail=True, methods=['get'])
def pdf(self, request, pk=None):
    """T√©l√©charger PDF copie."""
    copy = self.get_object()

    # V√©rifier permissions
    if not self._can_access_copy(request.user, copy):
        return Response({'error': 'Access denied'}, status=403)

    # V√©rifier fichier existe
    if not copy.pdf_file or not os.path.exists(copy.pdf_file.path):
        return Response({'error': 'PDF not found'}, status=404)

    # Retourner fichier
    response = FileResponse(
        open(copy.pdf_file.path, 'rb'),
        content_type='application/pdf'
    )
    response['Content-Disposition'] = f'attachment; filename="copie_{copy.anonymous_id}.pdf"'
    return response
```

**Exemple cURL** :

```bash
# T√©l√©charger PDF
curl -X GET http://localhost:8088/api/grading/copies/copy-uuid-1/pdf/ \
  -b cookies.txt \
  -o copie.pdf
```

---

### 7. GET /api/grading/copies/{id}/statistics/

**Description** : Statistiques d'une copie (d√©tail notes par question)

**Permissions** : Admin, enseignant assign√©

**R√©ponse Success (200 OK)** :

```json
{
  "copy_id": "copy-uuid-1",
  "anonymous_id": "A3-001",
  "total_score": 18.5,
  "max_score": 20.0,
  "percentage": 92.5,
  "by_question": [
    {
      "question": "1",
      "title": "√âtude de fonction",
      "score": 4.8,
      "max_score": 5.0,
      "percentage": 96.0,
      "sub_questions": [
        {"id": "1.a", "score": 1.5, "max_score": 1.5},
        {"id": "1.b", "score": 1.8, "max_score": 2.0}
      ]
    }
  ],
  "grading_time": "00:15:30",
  "annotations_count": 8
}
```

---

## üìä Serializers

```python
from rest_framework import serializers

class CopySerializer(serializers.ModelSerializer):
    """Serializer basique."""
    exam = ExamSerializer(read_only=True)
    student = StudentSerializer(read_only=True)
    corrector = UserSerializer(read_only=True)
    pages_count = serializers.IntegerField(source='pages.count', read_only=True)

    class Meta:
        model = Copy
        fields = [
            'id', 'exam', 'anonymous_id', 'student', 'corrector',
            'status', 'is_identified', 'is_locked', 'total_score',
            'pages_count', 'created_at', 'corrected_at'
        ]


class CopyDetailSerializer(serializers.ModelSerializer):
    """Serializer d√©taill√© avec pages, grades, annotations."""
    exam = ExamDetailSerializer(read_only=True)
    student = StudentSerializer(read_only=True)
    corrector = UserSerializer(read_only=True)
    pages = PageSerializer(many=True, read_only=True)
    grades = GradeSerializer(many=True, read_only=True)
    annotations = AnnotationSerializer(many=True, read_only=True)

    class Meta:
        model = Copy
        fields = [
            'id', 'exam', 'anonymous_id', 'student', 'corrector',
            'status', 'is_identified', 'is_locked', 'pdf_url',
            'pages', 'grades', 'annotations', 'total_score',
            'created_at', 'corrected_at'
        ]
```

---

## üìù Conclusion

L'API Copies fournit toutes les op√©rations n√©cessaires pour la correction des copies avec sauvegarde automatique, annotations et verrouillage s√©curis√©.

**Points cl√©s** :
- Liste filtr√©e selon profil
- Mise √† jour incr√©mentale (draft)
- Validation avant verrouillage
- T√©l√©chargement PDF
- Permissions granulaires

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
