# 01.2 - Backend Django - Architecture D√©taill√©e

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Vue d'Ensemble du Backend

Le backend Korrigo est construit sur **Django 4.2.27** et **Django REST Framework 3.16.1**, fournissant une API REST compl√®te pour la gestion des examens, la correction num√©rique et l'identification OCR.

### Architecture en Applications Django

Le backend est organis√© en **6 applications Django** principales :

```
backend/
‚îú‚îÄ‚îÄ core/           # Authentification, utilisateurs, permissions
‚îú‚îÄ‚îÄ exams/          # Gestion des examens et copies
‚îú‚îÄ‚îÄ grading/        # Correction et notation
‚îú‚îÄ‚îÄ students/       # Gestion des √©tudiants et r√©sultats
‚îú‚îÄ‚îÄ identification/ # OCR et identification des copies
‚îî‚îÄ‚îÄ processing/     # Traitement batch PDF et OCR
```

---

## üì¶ Application `core/` - Authentification et Base

### Responsabilit√©s

- Authentification des utilisateurs (admin, enseignants, √©tudiants)
- Gestion des permissions et groupes Django
- Health checks et monitoring
- Configuration globale

### Mod√®les

#### User (Django Auth)

```python
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    """Utilisateur Django √©tendu."""

    # H√©rite de AbstractUser (username, email, password, etc.)

    # Champs additionnels
    phone = models.CharField(max_length=20, blank=True)
    date_joined = models.DateTimeField(auto_now_add=True)
    last_login = models.DateTimeField(null=True, blank=True)

    # Permissions
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)  # Enseignant/Admin
    is_superuser = models.BooleanField(default=False)  # Admin complet

    # Relations
    groups = models.ManyToManyField(Group)  # teacher, admin

    class Meta:
        db_table = 'auth_user'
        verbose_name = 'Utilisateur'
```

### Vues (Views)

#### POST /api/login/

```python
from django.contrib.auth import authenticate, login
from rest_framework.decorators import api_view
from rest_framework.response import Response

@api_view(['POST'])
def login_view(request):
    """
    Authentification utilisateur.

    Body:
        {
            "username": "test_admin",
            "password": "admin123"
        }

    Returns:
        {
            "success": true,
            "user": {
                "id": 1,
                "username": "test_admin",
                "email": "admin@korrigo.tn",
                "is_staff": true,
                "is_superuser": true,
                "groups": ["admin", "teacher"]
            }
        }
    """
    username = request.data.get('username')
    password = request.data.get('password')

    user = authenticate(request, username=username, password=password)

    if user is not None and user.is_active:
        login(request, user)

        return Response({
            'success': True,
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'is_staff': user.is_staff,
                'is_superuser': user.is_superuser,
                'groups': [g.name for g in user.groups.all()]
            }
        })

    return Response({'error': 'Invalid credentials'}, status=403)
```

#### GET /api/me/

```python
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def me_view(request):
    """
    R√©cup√©rer les informations de l'utilisateur connect√©.

    Returns:
        {
            "id": 1,
            "username": "test_admin",
            "email": "admin@korrigo.tn",
            "role": "Admin",
            "permissions": ["create_exam", "assign_corrector", ...]
        }
    """
    user = request.user

    # D√©terminer le r√¥le
    if user.is_superuser:
        role = "Admin"
    elif user.groups.filter(name='teacher').exists():
        role = "Teacher"
    else:
        role = "Student"

    return Response({
        'id': user.id,
        'username': user.username,
        'email': user.email,
        'role': role,
        'is_staff': user.is_staff,
        'permissions': get_user_permissions(user)
    })
```

#### GET /api/health/

```python
from django.db import connection

@api_view(['GET'])
def health_check(request):
    """
    Health check pour monitoring.

    Returns:
        {
            "status": "healthy",
            "database": "connected",
            "redis": "connected",
            "timestamp": "2026-02-03T10:30:00Z"
        }
    """
    try:
        # Test DB
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")

        # Test Redis
        from django.core.cache import cache
        cache.set('health_check', 'ok', 10)

        return Response({
            'status': 'healthy',
            'database': 'connected',
            'redis': 'connected',
            'timestamp': timezone.now().isoformat()
        })
    except Exception as e:
        return Response({
            'status': 'unhealthy',
            'error': str(e)
        }, status=503)
```

### Permissions Django

```python
from rest_framework.permissions import BasePermission

class IsTeacher(BasePermission):
    """Permission pour enseignants et admins."""

    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.is_staff

class IsAdmin(BasePermission):
    """Permission pour admins uniquement."""

    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.is_superuser

class IsStudent(BasePermission):
    """Permission pour √©tudiants."""

    def has_permission(self, request, view):
        return request.user.is_authenticated and not request.user.is_staff
```

---

## üìù Application `exams/` - Gestion des Examens

### Responsabilit√©s

- CRUD des examens
- Upload des PDF scann√©s
- Structure de notation (bar√®me)
- Upload et traitement batch

### Mod√®les

#### Exam

```python
import uuid
from django.db import models

class Exam(models.Model):
    """Examen."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255)
    date = models.DateField()

    # Fichiers
    pdf_source = models.FileField(upload_to='exams/pdfs/', null=True, blank=True)
    students_csv = models.FileField(upload_to='exams/csv/', null=True, blank=True)

    # Structure de notation
    grading_structure = models.JSONField(default=list)
    # Format: [{"question": "1", "title": "...", "max_score": 5.0, "sub_questions": [...]}]

    # Status
    is_processed = models.BooleanField(default=False)
    is_published = models.BooleanField(default=False)

    # Relations
    creator = models.ForeignKey('core.User', on_delete=models.CASCADE, related_name='created_exams')
    correctors = models.ManyToManyField('core.User', related_name='assigned_exams', blank=True)

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'exams_exam'
        ordering = ['-created_at']
```

#### Copy

```python
class Copy(models.Model):
    """Copie d'√©tudiant."""

    class Status(models.TextChoices):
        PENDING = 'PENDING', 'En attente'
        READY = 'READY', 'Pr√™te √† corriger'
        IN_PROGRESS = 'IN_PROGRESS', 'En cours de correction'
        COMPLETED = 'COMPLETED', 'Corrig√©e'
        PUBLISHED = 'PUBLISHED', 'Publi√©e'

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # Relations
    exam = models.ForeignKey(Exam, on_delete=models.CASCADE, related_name='copies')
    student = models.ForeignKey('students.Student', on_delete=models.CASCADE, null=True, blank=True)
    corrector = models.ForeignKey('core.User', on_delete=models.SET_NULL, null=True, blank=True)

    # Identification
    anonymous_id = models.CharField(max_length=20, unique=True)
    is_identified = models.BooleanField(default=False)

    # Status
    status = models.CharField(max_length=20, choices=Status.choices, default=Status.PENDING)

    # PDF
    pdf_file = models.FileField(upload_to='copies/pdfs/', null=True, blank=True)

    # Correction
    is_locked = models.BooleanField(default=False)  # Verrouill√©e apr√®s correction
    total_score = models.DecimalField(max_digits=5, decimal_places=2, null=True, blank=True)

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    corrected_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = 'exams_copy'
        ordering = ['anonymous_id']
```

#### Page

```python
class Page(models.Model):
    """Page scann√©e d'une copie."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    copy = models.ForeignKey(Copy, on_delete=models.CASCADE, related_name='pages')

    page_number = models.IntegerField()  # Num√©ro de page dans la copie
    image_file = models.FileField(upload_to='copies/pages/')

    # M√©tadonn√©es
    width = models.IntegerField()
    height = models.IntegerField()
    dpi = models.IntegerField(default=300)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'exams_page'
        ordering = ['copy', 'page_number']
        unique_together = [['copy', 'page_number']]
```

### Vues (Views)

#### POST /api/exams/

```python
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated

class ExamViewSet(viewsets.ModelViewSet):
    """ViewSet pour la gestion des examens."""

    queryset = Exam.objects.all()
    serializer_class = ExamSerializer
    permission_classes = [IsAuthenticated, IsTeacher]

    def create(self, request):
        """
        Cr√©er un examen.

        Body:
            {
                "name": "Bac Blanc Math√©matiques 2026",
                "date": "2026-02-03",
                "grading_structure": [
                    {
                        "question": "1",
                        "title": "√âtude de fonction",
                        "max_score": 5.0,
                        "sub_questions": [
                            {"id": "1.a", "title": "Limites", "max_score": 1.5},
                            {"id": "1.b", "title": "D√©riv√©e", "max_score": 2.0}
                        ]
                    }
                ]
            }

        Returns:
            {
                "id": "123e4567-e89b-12d3-a456-426614174000",
                "name": "Bac Blanc Math√©matiques 2026",
                "date": "2026-02-03",
                "creator": {"id": 1, "username": "test_admin"},
                "grading_structure": [...],
                "is_processed": false,
                "created_at": "2026-02-03T10:30:00Z"
            }
        """
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        exam = serializer.save(creator=request.user)

        return Response(ExamSerializer(exam).data, status=status.HTTP_201_CREATED)
```

#### POST /api/exams/upload/

```python
from rest_framework.decorators import action
from processing.tasks import process_batch_pdf

class ExamViewSet(viewsets.ModelViewSet):

    @action(detail=False, methods=['post'])
    def upload(self, request):
        """
        Upload PDF et CSV, lancer traitement batch.

        Form Data:
            pdf_file: File (PDF A3/A4)
            students_csv: File (CSV)
            exam_id: UUID
            batch_mode: boolean (true = A3 split + OCR)

        Returns:
            {
                "job_id": "abc123",
                "status": "processing",
                "message": "Processing started"
            }
        """
        exam_id = request.data.get('exam_id')
        pdf_file = request.FILES.get('pdf_file')
        students_csv = request.FILES.get('students_csv')
        batch_mode = request.data.get('batch_mode', 'false') == 'true'

        exam = Exam.objects.get(id=exam_id)

        # Sauvegarder fichiers
        exam.pdf_source = pdf_file
        exam.students_csv = students_csv
        exam.save()

        # Lancer traitement asynchrone avec Celery
        job = process_batch_pdf.delay(
            exam_id=str(exam.id),
            pdf_path=exam.pdf_source.path,
            csv_path=exam.students_csv.path,
            batch_mode=batch_mode
        )

        return Response({
            'job_id': job.id,
            'status': 'processing',
            'message': 'Processing started'
        }, status=status.HTTP_202_ACCEPTED)
```

---

## ‚úÖ Application `grading/` - Correction et Notation

### Responsabilit√©s

- Correction des copies
- Attribution des notes par question
- Annotations PDF
- Commentaires enseignant
- Sauvegarde automatique (draft)

### Mod√®les

#### Grade

```python
class Grade(models.Model):
    """Note attribu√©e pour une question."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # Relations
    copy = models.ForeignKey('exams.Copy', on_delete=models.CASCADE, related_name='grades')
    grader = models.ForeignKey('core.User', on_delete=models.CASCADE)

    # Question
    question_id = models.CharField(max_length=10)  # "1", "1.a", "2.b"

    # Note
    score = models.DecimalField(max_digits=5, decimal_places=2)
    max_score = models.DecimalField(max_digits=5, decimal_places=2)

    # Commentaire
    comment = models.TextField(blank=True)

    # Timestamps
    graded_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'grading_grade'
        unique_together = [['copy', 'question_id']]
```

#### Annotation

```python
class Annotation(models.Model):
    """Annotation PDF (surlignage, commentaire, etc.)."""

    class Type(models.TextChoices):
        HIGHLIGHT = 'HIGHLIGHT', 'Surlignage'
        UNDERLINE = 'UNDERLINE', 'Soulign√©'
        COMMENT = 'COMMENT', 'Commentaire'
        STAMP = 'STAMP', 'Tampon'

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # Relations
    copy = models.ForeignKey('exams.Copy', on_delete=models.CASCADE, related_name='annotations')
    author = models.ForeignKey('core.User', on_delete=models.CASCADE)
    page = models.ForeignKey('exams.Page', on_delete=models.CASCADE, related_name='annotations')

    # Type et contenu
    annotation_type = models.CharField(max_length=20, choices=Type.choices)
    content = models.TextField(blank=True)  # Texte du commentaire

    # Coordonn√©es PDF (format PDF.js)
    coordinates = models.JSONField()
    # Format: {"x": 100, "y": 200, "width": 50, "height": 20, "page": 1}

    # Style
    color = models.CharField(max_length=7, default='#FF0000')  # Hex color

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'grading_annotation'
```

### Vues (Views)

#### GET /api/grading/copies/

```python
class CopyViewSet(viewsets.ModelViewSet):
    """ViewSet pour la correction des copies."""

    queryset = Copy.objects.all()
    serializer_class = CopySerializer
    permission_classes = [IsAuthenticated, IsTeacher]

    def get_queryset(self):
        """
        Filtrer les copies selon le r√¥le.

        - Admin: toutes les copies
        - Teacher: copies assign√©es
        """
        user = self.request.user

        if user.is_superuser:
            return Copy.objects.all()
        else:
            return Copy.objects.filter(corrector=user)

    def list(self, request):
        """
        Liste des copies √† corriger.

        Query params:
            exam_id: UUID (optionnel)
            status: PENDING | READY | IN_PROGRESS | COMPLETED

        Returns:
            [
                {
                    "id": "...",
                    "exam": {"id": "...", "name": "..."},
                    "anonymous_id": "A3-001",
                    "student": null,  // null si pas encore identifi√©
                    "status": "READY",
                    "corrector": {"id": 2, "username": "test_prof"},
                    "total_score": null,
                    "is_locked": false
                }
            ]
        """
        queryset = self.get_queryset()

        # Filtres
        exam_id = request.query_params.get('exam_id')
        if exam_id:
            queryset = queryset.filter(exam_id=exam_id)

        status_filter = request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)
```

#### PATCH /api/grading/copies/{id}/

```python
class CopyViewSet(viewsets.ModelViewSet):

    def partial_update(self, request, pk=None):
        """
        Mettre √† jour une copie (notes, commentaires, annotations).

        Body:
            {
                "grades": [
                    {"question_id": "1", "score": 4.5, "max_score": 5.0, "comment": "Tr√®s bien"},
                    {"question_id": "1.a", "score": 1.5, "max_score": 1.5}
                ],
                "annotations": [
                    {
                        "page_id": "...",
                        "type": "HIGHLIGHT",
                        "coordinates": {"x": 100, "y": 200, "width": 50, "height": 20},
                        "color": "#FFFF00"
                    }
                ],
                "status": "IN_PROGRESS"
            }

        Returns:
            {
                "id": "...",
                "total_score": 18.5,
                "grades": [...],
                "annotations": [...]
            }
        """
        copy = self.get_object()

        # V√©rifier que la copie n'est pas verrouill√©e
        if copy.is_locked:
            return Response({'error': 'Copy is locked'}, status=403)

        # Mettre √† jour les notes
        grades_data = request.data.get('grades', [])
        for grade_data in grades_data:
            Grade.objects.update_or_create(
                copy=copy,
                question_id=grade_data['question_id'],
                defaults={
                    'grader': request.user,
                    'score': grade_data['score'],
                    'max_score': grade_data['max_score'],
                    'comment': grade_data.get('comment', '')
                }
            )

        # Calculer le total
        total = sum(g.score for g in copy.grades.all())
        copy.total_score = total
        copy.status = request.data.get('status', copy.status)
        copy.save()

        return Response(CopySerializer(copy).data)
```

#### POST /api/grading/copies/{id}/lock/

```python
class CopyViewSet(viewsets.ModelViewSet):

    @action(detail=True, methods=['post'])
    def lock(self, request, pk=None):
        """
        Verrouiller une copie apr√®s correction.

        Returns:
            {
                "success": true,
                "copy": {...},
                "message": "Copy locked successfully"
            }
        """
        copy = self.get_object()

        # V√©rifier que toutes les questions sont not√©es
        exam_questions = extract_question_ids(copy.exam.grading_structure)
        graded_questions = set(copy.grades.values_list('question_id', flat=True))

        if not set(exam_questions).issubset(graded_questions):
            return Response({
                'error': 'All questions must be graded before locking'
            }, status=400)

        # Verrouiller
        copy.is_locked = True
        copy.status = Copy.Status.COMPLETED
        copy.corrected_at = timezone.now()
        copy.save()

        return Response({
            'success': True,
            'copy': CopySerializer(copy).data,
            'message': 'Copy locked successfully'
        })
```

---

## üë®‚Äçüéì Application `students/` - Gestion des √âtudiants

### Responsabilit√©s

- CRUD des √©tudiants
- Authentification √©tudiants (email + date de naissance)
- Consultation des r√©sultats
- T√©l√©chargement des copies corrig√©es

### Mod√®les

#### Student

```python
class Student(models.Model):
    """√âtudiant."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # Identit√©
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    date_of_birth = models.DateField()

    # Lien avec User (pour authentification)
    user = models.OneToOneField('core.User', on_delete=models.SET_NULL, null=True, blank=True)

    # M√©tadonn√©es
    student_number = models.CharField(max_length=20, blank=True)
    class_name = models.CharField(max_length=50, blank=True)  # "G3", "Terminale S"

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'students_student'
        ordering = ['last_name', 'first_name']
```

### Vues (Views)

#### POST /api/students/login/

```python
@api_view(['POST'])
def student_login(request):
    """
    Authentification √©tudiant (email + date de naissance).

    Body:
        {
            "email": "eleve1@korrigo.local",
            "date_of_birth": "2008-05-15"
        }

    Returns:
        {
            "success": true,
            "student": {
                "id": "...",
                "first_name": "Jean",
                "last_name": "Dupont",
                "email": "eleve1@korrigo.local"
            },
            "token": "..."  // Session token
        }
    """
    email = request.data.get('email')
    dob = request.data.get('date_of_birth')

    try:
        student = Student.objects.get(email=email, date_of_birth=dob)

        # Si User li√©, login Django
        if student.user:
            login(request, student.user)

        return Response({
            'success': True,
            'student': StudentSerializer(student).data
        })
    except Student.DoesNotExist:
        return Response({'error': 'Invalid credentials'}, status=403)
```

#### GET /api/students/copies/

```python
@api_view(['GET'])
@permission_classes([IsAuthenticated, IsStudent])
def student_copies(request):
    """
    Liste des copies de l'√©tudiant connect√©.

    Returns:
        [
            {
                "id": "...",
                "exam": {
                    "id": "...",
                    "name": "Bac Blanc Math√©matiques 2026",
                    "date": "2026-02-03"
                },
                "status": "PUBLISHED",
                "total_score": 18.5,
                "is_published": true,
                "corrected_at": "2026-02-10T15:30:00Z"
            }
        ]
    """
    student = Student.objects.get(user=request.user)
    copies = Copy.objects.filter(
        student=student,
        status=Copy.Status.PUBLISHED
    )

    return Response(CopySerializer(copies, many=True).data)
```

---

## üîç Application `identification/` - OCR et Identification

### Responsabilit√©s

- OCR des en-t√™tes de copies
- Matching √©tudiant avec CSV (fuzzy matching)
- Desk d'identification (interface enseignant)
- Modes : AUTO / SEMI-AUTO / MANUAL

### Mod√®les

#### OCRResult

```python
class OCRResult(models.Model):
    """R√©sultat OCR pour une copie."""

    class Mode(models.TextChoices):
        AUTO = 'AUTO', 'Automatic'
        SEMI_AUTO = 'SEMI_AUTO', 'Semi-Automatic'
        MANUAL = 'MANUAL', 'Manual'

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    copy = models.OneToOneField('exams.Copy', on_delete=models.CASCADE)

    # R√©sultat OCR
    detected_text = models.TextField()
    confidence = models.FloatField()  # 0.0 - 1.0

    # Top-K candidats (nouveau PRD-19)
    top_candidates = models.JSONField(default=list)
    # Format: [{"student_id": "...", "confidence": 0.85, "vote_count": 3, "sources": [...]}]

    # Mode
    ocr_mode = models.CharField(max_length=20, choices=Mode.choices, default=Mode.AUTO)

    # Audit trail
    selected_candidate_rank = models.IntegerField(null=True, blank=True)
    manual_override = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'identification_ocrresult'
```

### Vues (Views)

#### GET /api/identification/copies/{id}/ocr-candidates/

```python
@api_view(['GET'])
@permission_classes([IsAuthenticated, IsTeacher])
def get_ocr_candidates(request, copy_id):
    """
    R√©cup√©rer les top-K candidats OCR pour s√©lection semi-automatique.

    Returns:
        {
            "copy_id": "...",
            "anonymous_id": "A3-001",
            "candidates": [
                {
                    "rank": 1,
                    "student": {
                        "id": "...",
                        "first_name": "Jean",
                        "last_name": "Dupont",
                        "email": "jean.dupont@korrigo.local",
                        "date_of_birth": "2008-05-15"
                    },
                    "confidence": 0.85,
                    "vote_count": 3,
                    "vote_agreement": 0.75,
                    "ocr_sources": [
                        {
                            "engine": "tesseract",
                            "variant": 0,
                            "text": "Jean Dupont 15/05/2008",
                            "score": 0.82
                        },
                        {
                            "engine": "easyocr",
                            "variant": 1,
                            "text": "JEAN DUPONT 15-05-2008",
                            "score": 0.88
                        }
                    ]
                }
            ],
            "ocr_mode": "SEMI_AUTO"
        }
    """
    copy = get_object_or_404(Copy, id=copy_id)
    ocr_result = OCRResult.objects.get(copy=copy)

    candidates = []
    for idx, candidate_data in enumerate(ocr_result.top_candidates[:5], 1):
        student = Student.objects.get(id=candidate_data['student_id'])
        candidates.append({
            'rank': idx,
            'student': StudentSerializer(student).data,
            'confidence': candidate_data['confidence'],
            'vote_count': candidate_data['vote_count'],
            'vote_agreement': candidate_data.get('vote_agreement', 0),
            'ocr_sources': candidate_data['sources']
        })

    return Response({
        'copy_id': str(copy.id),
        'anonymous_id': copy.anonymous_id,
        'candidates': candidates,
        'ocr_mode': ocr_result.ocr_mode
    })
```

#### POST /api/identification/copies/{id}/select-candidate/

```python
@api_view(['POST'])
@permission_classes([IsAuthenticated, IsTeacher])
def select_ocr_candidate(request, copy_id):
    """
    S√©lectionner un candidat parmi les top-K (mode SEMI_AUTO).

    Body:
        {
            "rank": 1  // 1-5
        }

    Returns:
        {
            "success": true,
            "student_id": "...",
            "message": "Student assigned successfully"
        }
    """
    copy = get_object_or_404(Copy, id=copy_id)
    selected_rank = request.data.get('rank')

    ocr_result = OCRResult.objects.get(copy=copy)
    candidate = ocr_result.top_candidates[selected_rank - 1]

    # Assigner l'√©tudiant
    student = Student.objects.get(id=candidate['student_id'])
    copy.student = student
    copy.is_identified = True
    copy.status = Copy.Status.READY
    copy.save()

    # Audit trail
    ocr_result.selected_candidate_rank = selected_rank
    ocr_result.save()

    return Response({
        'success': True,
        'student_id': str(student.id),
        'message': 'Student assigned successfully'
    })
```

---

## ‚öôÔ∏è Application `processing/` - Traitement Batch et OCR

### Responsabilit√©s

- Traitement batch des PDF A3/A4
- Split des pages A3 en A4
- Segmentation par √©tudiant (multi-sheet fusion)
- OCR multi-layer (Tesseract + EasyOCR + PaddleOCR)
- Consensus voting

### Services

#### BatchProcessor

**Fichier** : `backend/processing/services/batch_processor.py`

```python
class BatchA3Processor:
    """Processeur batch pour PDF A3 (CMEN v2)."""

    def process(self, pdf_path: str, csv_path: str) -> ProcessingResult:
        """
        Traitement complet du batch A3.

        √âtapes:
        1. D√©tection format (A3 vs A4)
        2. Split A3 ‚Üí A4 (avec rotation si n√©cessaire)
        3. OCR multi-layer sur en-t√™tes
        4. Segmentation par √©tudiant (multi-sheet fusion)
        5. Cr√©ation des copies Django

        Args:
            pdf_path: Chemin vers le PDF source
            csv_path: Chemin vers le CSV des √©tudiants

        Returns:
            ProcessingResult(
                copies_created=28,
                auto_identified=20,
                semi_auto=5,
                manual=3,
                processing_time=120.5
            )
        """
        # 1. Charger PDF
        pages = self._load_pdf(pdf_path)

        # 2. D√©tecter format et split si A3
        if self._is_a3_format(pages[0]):
            pages = self._split_a3_pages(pages)

        # 3. Charger CSV whitelist
        students = self._load_csv(csv_path)

        # 4. Segmenter par √©tudiant
        student_copies = self._segment_by_student(pages, students)

        # 5. Cr√©er copies Django
        return self._create_copies_from_batch(student_copies)

    def _split_a3_pages(self, pages: List[PageInfo]) -> List[PageInfo]:
        """
        Split A3 ‚Üí 2√óA4 avec rotation.

        Logique:
        - A3 portrait ‚Üí 2 A4 landscape (rotation 90¬∞)
        - Split vertical au milieu
        """
        a4_pages = []

        for page_num, page_img in pages:
            h, w = page_img.shape[:2]

            # Split vertical
            mid = w // 2
            left_half = page_img[:, :mid]
            right_half = page_img[:, mid:]

            # Rotation 90¬∞ CW
            left_rotated = cv2.rotate(left_half, cv2.ROTATE_90_CLOCKWISE)
            right_rotated = cv2.rotate(right_half, cv2.ROTATE_90_CLOCKWISE)

            a4_pages.append(PageInfo(page_num * 2, left_rotated))
            a4_pages.append(PageInfo(page_num * 2 + 1, right_rotated))

        return a4_pages

    def _segment_by_student(self, pages: List[PageInfo],
                           students: List[Student]) -> List[StudentCopy]:
        """
        Segmentation par √©tudiant avec multi-sheet fusion.

        Logique:
        - D√©tecter header (vision.py)
        - OCR multi-layer
        - Grouper les pages par √©tudiant (fusion 2+ sheets)
        """
        student_copies = []
        current_copy = None

        for page in pages:
            # D√©tecter header
            header_region = self._detect_header(page.image)

            if header_region is not None:
                # Nouveau header d√©tect√© ‚Üí nouvelle copie
                if current_copy is not None:
                    student_copies.append(current_copy)

                # OCR multi-layer
                ocr_result = self._ocr_header_multi_layer(header_region)

                # Matcher avec CSV
                student_match = self._match_student(ocr_result, students)

                current_copy = StudentCopy(
                    student_match=student_match,
                    pages=[page],
                    header_crops=[header_region],
                    ocr_result=ocr_result
                )
            else:
                # Pas de header ‚Üí continuation de la copie pr√©c√©dente
                if current_copy is not None:
                    current_copy.pages.append(page)

        # Ajouter derni√®re copie
        if current_copy is not None:
            student_copies.append(current_copy)

        return student_copies

    def _ocr_header_multi_layer(self, header_img: np.ndarray) -> OCRResult:
        """
        OCR multi-layer avec consensus voting.

        Moteurs:
        - Tesseract (PSM 6, French)
        - EasyOCR (French + English)
        - PaddleOCR (French)

        Returns:
            OCRResult(
                top_candidates=[...],
                confidence=0.85,
                mode='SEMI_AUTO'
            )
        """
        from processing.services.ocr_engine import MultiLayerOCR

        ocr_engine = MultiLayerOCR()
        result = ocr_engine.extract_text_with_candidates(header_img)

        # D√©terminer mode selon confidence
        if result.top_candidates and result.top_candidates[0].confidence > 0.7:
            mode = 'AUTO'
        elif result.top_candidates and result.top_candidates[0].confidence > 0.4:
            mode = 'SEMI_AUTO'
        else:
            mode = 'MANUAL'

        return OCRResult(
            top_candidates=result.top_candidates,
            confidence=result.top_candidates[0].confidence if result.top_candidates else 0.0,
            mode=mode
        )
```

#### MultiLayerOCR (PRD-19)

**Fichier** : `backend/processing/services/ocr_engine.py`

```python
class MultiLayerOCR:
    """OCR multi-layer avec consensus voting."""

    def __init__(self):
        self.tesseract = TesseractOCR()
        self.easyocr = easyocr.Reader(['fr', 'en'])
        self.paddleocr = PaddleOCR(lang='fr')

    def extract_text_with_candidates(self, image: np.ndarray) -> OCRCandidates:
        """
        Extraction multi-layer avec top-K candidats.

        Pipeline:
        1. Preprocessing (4 variants)
        2. Run all OCR engines on all variants
        3. Consensus voting
        4. Return top-5 candidates
        """
        # 1. Preprocessing variants
        preprocessor = ImagePreprocessor()
        variants = preprocessor.preprocess_variants(image)
        # variants = [binary, clahe, morph, contrast]

        # 2. Run OCR engines
        ocr_results = []
        for variant_idx, variant_img in enumerate(variants):
            # Tesseract
            tess_text = self.tesseract.extract(variant_img)
            ocr_results.append(OCRCandidate(
                engine='tesseract',
                variant=variant_idx,
                text=tess_text,
                confidence=self._calculate_confidence(tess_text)
            ))

            # EasyOCR
            easy_result = self.easyocr.readtext(variant_img)
            easy_text = ' '.join([r[1] for r in easy_result])
            ocr_results.append(OCRCandidate(
                engine='easyocr',
                variant=variant_idx,
                text=easy_text,
                confidence=np.mean([r[2] for r in easy_result]) if easy_result else 0.0
            ))

            # PaddleOCR
            paddle_result = self.paddleocr.ocr(variant_img, cls=True)
            paddle_text = ' '.join([r[1][0] for r in paddle_result[0]]) if paddle_result else ''
            ocr_results.append(OCRCandidate(
                engine='paddleocr',
                variant=variant_idx,
                text=paddle_text,
                confidence=np.mean([r[1][1] for r in paddle_result[0]]) if paddle_result else 0.0
            ))

        # 3. Consensus voting
        top_candidates = self._consensus_vote(ocr_results, students_whitelist)

        return OCRCandidates(top_candidates=top_candidates)

    def _consensus_vote(self, ocr_results: List[OCRCandidate],
                       students: List[Student]) -> List[StudentMatch]:
        """
        Voting par agr√©gation des scores OCR + fuzzy matching.

        Algorithme:
        - Chaque OCR candidate ‚Üí fuzzy match contre CSV
        - Agr√©ger les scores par √©tudiant
        - Retourner top-5
        """
        from fuzzywuzzy import fuzz

        student_scores = defaultdict(lambda: {
            'total_score': 0.0,
            'vote_count': 0,
            'ocr_sources': []
        })

        for ocr_candidate in ocr_results:
            # Parser nom + date de naissance
            name, dob = self._parse_ocr_text(ocr_candidate.text)

            # Fuzzy match contre CSV
            for student in students:
                # Jaccard similarity (nom)
                name_score = fuzz.token_sort_ratio(
                    name.lower(),
                    f"{student.first_name} {student.last_name}".lower()
                ) / 100.0

                # Date matching
                date_score = 1.0 if dob == student.date_of_birth.strftime('%d/%m/%Y') else 0.0

                # Score combin√© (0.6 * name + 0.4 * date)
                match_score = 0.6 * name_score + 0.4 * date_score

                if match_score > 0.3:  # Seuil bas pour voting
                    # Pond√©rer par confidence OCR
                    weighted_score = match_score * ocr_candidate.confidence

                    student_scores[student.id]['total_score'] += weighted_score
                    student_scores[student.id]['vote_count'] += 1
                    student_scores[student.id]['ocr_sources'].append({
                        'engine': ocr_candidate.engine,
                        'variant': ocr_candidate.variant,
                        'text': ocr_candidate.text,
                        'score': weighted_score
                    })

        # Top-5 candidats
        top_candidates = []
        for student_id, data in sorted(
            student_scores.items(),
            key=lambda x: x[1]['total_score'],
            reverse=True
        )[:5]:
            consensus_confidence = data['total_score'] / len(ocr_results)
            vote_agreement = data['vote_count'] / len(ocr_results)

            top_candidates.append(StudentMatch(
                student_id=str(student_id),
                confidence=consensus_confidence,
                vote_count=data['vote_count'],
                vote_agreement=vote_agreement,
                sources=data['ocr_sources']
            ))

        return top_candidates
```

### Celery Tasks

```python
from celery import shared_task

@shared_task(bind=True)
def process_batch_pdf(self, exam_id: str, pdf_path: str,
                     csv_path: str, batch_mode: bool):
    """
    Task Celery pour traitement batch asynchrone.

    Args:
        exam_id: UUID de l'examen
        pdf_path: Chemin vers le PDF
        csv_path: Chemin vers le CSV
        batch_mode: True = A3 split + OCR

    Progress:
        Met √† jour self.update_state() pour tracking frontend
    """
    processor = BatchA3Processor()

    # Progress: 0% - Chargement
    self.update_state(state='PROGRESS', meta={'progress': 0, 'status': 'Loading PDF'})

    # Traitement
    result = processor.process(pdf_path, csv_path)

    # Progress: 100% - Termin√©
    self.update_state(state='SUCCESS', meta={
        'progress': 100,
        'copies_created': result.copies_created,
        'auto_identified': result.auto_identified,
        'semi_auto': result.semi_auto,
        'manual': result.manual
    })

    return result
```

---

## üîß Middleware et Configuration

### CORS Middleware

```python
# backend/config/settings.py

CORS_ALLOWED_ORIGINS = [
    'http://localhost:8088',
    'https://korrigo.labomths.tn'
]

CORS_ALLOW_CREDENTIALS = True

CORS_ALLOW_HEADERS = [
    'accept',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
]
```

### CSRF Protection

```python
CSRF_TRUSTED_ORIGINS = [
    'http://localhost:8088',
    'https://korrigo.labomths.tn'
]

CSRF_COOKIE_HTTPONLY = False  # Pour acc√®s JavaScript
CSRF_COOKIE_SAMESITE = 'Lax'
```

### Session Configuration

```python
SESSION_ENGINE = 'django.contrib.sessions.backends.db'
SESSION_COOKIE_AGE = 86400  # 24 heures
SESSION_SAVE_EVERY_REQUEST = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SECURE = True  # Production only (HTTPS)
```

---

## üöÄ D√©marrage et Configuration

### Variables d'Environnement

```bash
# .env.prod

# Django
SECRET_KEY=your-secret-key-here
DEBUG=False
ALLOWED_HOSTS=localhost,korrigo.labomths.tn

# Database
DB_ENGINE=django.db.backends.postgresql
DB_NAME=korrigo_db
DB_USER=korrigo_user
DB_PASSWORD=secure_password
DB_HOST=db
DB_PORT=5432

# Redis
REDIS_URL=redis://redis:6379/0

# Celery
CELERY_BROKER_URL=redis://redis:6379/0
CELERY_RESULT_BACKEND=redis://redis:6379/0

# OCR
TESSERACT_PATH=/usr/bin/tesseract
OCR_CACHE_DIR=/app/.cache/

# Media
MEDIA_ROOT=/app/media/
MEDIA_URL=/media/
```

### Commandes Django

```bash
# Migrations
python manage.py makemigrations
python manage.py migrate

# Cr√©er superuser
python manage.py createsuperuser

# Seed production data
python manage.py shell < seed_prod.py

# Collect static
python manage.py collectstatic --noinput

# Run development server
python manage.py runserver 0.0.0.0:8000

# Run tests
pytest backend/ -v
```

---

## üìä Performance et Optimisation

### Database Indexes

```python
class Copy(models.Model):
    # ...

    class Meta:
        indexes = [
            models.Index(fields=['exam', 'status']),
            models.Index(fields=['corrector', 'status']),
            models.Index(fields=['anonymous_id']),
            models.Index(fields=['is_identified']),
        ]
```

### Query Optimization

```python
# Utiliser select_related pour foreign keys
copies = Copy.objects.select_related('exam', 'student', 'corrector').all()

# Utiliser prefetch_related pour many-to-many
exams = Exam.objects.prefetch_related('correctors', 'copies').all()

# Annotate pour agr√©gations
from django.db.models import Count, Avg

exams_with_stats = Exam.objects.annotate(
    copies_count=Count('copies'),
    avg_score=Avg('copies__total_score')
)
```

### Celery Worker Configuration

```bash
# docker-compose.local-prod.yml

celery:
  command: celery -A config worker -l info --concurrency=4
  environment:
    - CELERY_WORKER_PREFETCH_MULTIPLIER=1
```

---

## üîí S√©curit√©

### SQL Injection Protection

Django ORM prot√®ge automatiquement contre les injections SQL :

```python
# ‚úÖ SAFE - Utiliser ORM
User.objects.filter(username=user_input)

# ‚ùå UNSAFE - Raw SQL non param√©tr√©
cursor.execute(f"SELECT * FROM users WHERE username='{user_input}'")

# ‚úÖ SAFE - Raw SQL param√©tr√©
cursor.execute("SELECT * FROM users WHERE username=%s", [user_input])
```

### XSS Protection

Django √©chappe automatiquement les variables dans les templates :

```html
<!-- ‚úÖ SAFE - Auto-escaped -->
<p>{{ user_input }}</p>

<!-- ‚ùå UNSAFE - Marquer comme safe -->
<p>{{ user_input|safe }}</p>
```

### Rate Limiting

```python
# backend/core/middleware.py

from django.core.cache import cache

class RateLimitMiddleware:
    def __call__(self, request):
        ip = get_client_ip(request)
        key = f'rate_limit:{ip}'

        count = cache.get(key, 0)
        if count > 100:  # 100 requ√™tes par minute
            return HttpResponseForbidden('Rate limit exceeded')

        cache.set(key, count + 1, 60)  # Expire apr√®s 60s

        return self.get_response(request)
```

---

## üìù Conclusion

Le backend Django de Korrigo fournit une architecture robuste et modulaire pour la gestion compl√®te des examens num√©riques, de la cr√©ation √† la consultation des r√©sultats.

**Points cl√©s** :
- Architecture en 6 applications Django bien s√©par√©es
- API REST compl√®te avec DRF
- OCR multi-layer pour identification robuste
- Traitement asynchrone avec Celery
- Permissions granulaires par r√¥le
- S√©curit√© renforc√©e (CSRF, XSS, SQL injection)

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
