# 01.4 - Base de DonnÃ©es PostgreSQL - SchÃ©ma Complet

**Projet** : Korrigo - SystÃ¨me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 FÃ©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## ğŸ¯ Vue d'Ensemble

Korrigo utilise **PostgreSQL 15** comme systÃ¨me de gestion de base de donnÃ©es relationnelle.

### Configuration

| ParamÃ¨tre | Valeur |
|-----------|--------|
| **SGBD** | PostgreSQL 15.0 |
| **Nom DB** | korrigo_db |
| **Utilisateur** | korrigo_user |
| **Port** | 5432 |
| **Encoding** | UTF-8 |
| **Timezone** | UTC |
| **Max Connections** | 100 |

---

## ğŸ“Š Diagramme ER (Entity-Relationship)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   auth_user     â”‚
â”‚  (Utilisateur)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚
â”‚ username        â”‚
â”‚ email           â”‚
â”‚ password        â”‚
â”‚ is_staff        â”‚
â”‚ is_superuser    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ creator_id
         â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  exams_exam      â”‚
    â”‚   (Examen)       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ id (PK, UUID)    â”‚
    â”‚ name             â”‚
    â”‚ date             â”‚
    â”‚ pdf_source       â”‚
    â”‚ students_csv     â”‚
    â”‚ grading_structureâ”‚
    â”‚ is_processed     â”‚
    â”‚ is_published     â”‚
    â”‚ creator_id (FK)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â”‚ exam_id
             â”‚
        â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  exams_copy       â”‚
        â”‚   (Copie)         â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ id (PK, UUID)     â”‚
        â”‚ exam_id (FK)      â”‚
        â”‚ student_id (FK)   â”‚
        â”‚ corrector_id (FK) â”‚
        â”‚ anonymous_id      â”‚
        â”‚ is_identified     â”‚
        â”‚ status            â”‚
        â”‚ pdf_file          â”‚
        â”‚ is_locked         â”‚
        â”‚ total_score       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                        â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  exams_page      â”‚    â”‚  grading_grade    â”‚
â”‚   (Page)         â”‚    â”‚   (Note)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK, UUID)    â”‚    â”‚ id (PK, UUID)     â”‚
â”‚ copy_id (FK)     â”‚    â”‚ copy_id (FK)      â”‚
â”‚ page_number      â”‚    â”‚ grader_id (FK)    â”‚
â”‚ image_file       â”‚    â”‚ question_id       â”‚
â”‚ width            â”‚    â”‚ score             â”‚
â”‚ height           â”‚    â”‚ max_score         â”‚
â”‚ dpi              â”‚    â”‚ comment           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  students_student     â”‚
â”‚   (Ã‰tudiant)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK, UUID)         â”‚
â”‚ first_name            â”‚
â”‚ last_name             â”‚
â”‚ email (UNIQUE)        â”‚
â”‚ date_of_birth         â”‚
â”‚ user_id (FK)          â”‚
â”‚ student_number        â”‚
â”‚ class_name            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ copy.student_id
         â”‚
     (Relation vers exams_copy)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ identification_ocrresult â”‚
â”‚   (RÃ©sultat OCR)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK, UUID)            â”‚
â”‚ copy_id (FK, UNIQUE)     â”‚
â”‚ detected_text            â”‚
â”‚ confidence               â”‚
â”‚ top_candidates (JSON)    â”‚
â”‚ ocr_mode                 â”‚
â”‚ selected_candidate_rank  â”‚
â”‚ manual_override          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ grading_annotation       â”‚
â”‚   (Annotation PDF)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK, UUID)            â”‚
â”‚ copy_id (FK)             â”‚
â”‚ author_id (FK)           â”‚
â”‚ page_id (FK)             â”‚
â”‚ annotation_type          â”‚
â”‚ content                  â”‚
â”‚ coordinates (JSON)       â”‚
â”‚ color                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“‹ Tables et Colonnes DÃ©taillÃ©es

### 1. auth_user (Django Auth)

**RÃ´le** : Utilisateurs du systÃ¨me (admin, enseignants, Ã©tudiants)

```sql
CREATE TABLE auth_user (
    id SERIAL PRIMARY KEY,
    username VARCHAR(150) UNIQUE NOT NULL,
    email VARCHAR(254) UNIQUE NOT NULL,
    password VARCHAR(128) NOT NULL,  -- Hash bcrypt
    first_name VARCHAR(150),
    last_name VARCHAR(150),
    phone VARCHAR(20),

    -- Permissions
    is_active BOOLEAN DEFAULT TRUE,
    is_staff BOOLEAN DEFAULT FALSE,      -- Enseignant/Admin
    is_superuser BOOLEAN DEFAULT FALSE,  -- Admin complet

    -- Timestamps
    date_joined TIMESTAMP NOT NULL DEFAULT NOW(),
    last_login TIMESTAMP NULL
);

CREATE INDEX idx_user_username ON auth_user(username);
CREATE INDEX idx_user_email ON auth_user(email);
CREATE INDEX idx_user_is_staff ON auth_user(is_staff);
```

**DonnÃ©es** :
- Admin: is_superuser=True, is_staff=True
- Enseignant: is_staff=True, is_superuser=False
- Ã‰tudiant: is_staff=False, is_superuser=False

**Relations** :
- 1:N avec exams_exam (creator)
- 1:N avec exams_copy (corrector)
- M:N avec auth_group (groups)

---

### 2. auth_group (Django Groups)

**RÃ´le** : Groupes de permissions

```sql
CREATE TABLE auth_group (
    id SERIAL PRIMARY KEY,
    name VARCHAR(150) UNIQUE NOT NULL
);

CREATE TABLE auth_user_groups (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES auth_user(id) ON DELETE CASCADE,
    group_id INTEGER REFERENCES auth_group(id) ON DELETE CASCADE,
    UNIQUE (user_id, group_id)
);
```

**Groupes prÃ©dÃ©finis** :
- `teacher` : Enseignants
- `admin` : Administrateurs

---

### 3. exams_exam (Examen)

**RÃ´le** : Examens

```sql
CREATE TABLE exams_exam (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    date DATE NOT NULL,

    -- Fichiers
    pdf_source VARCHAR(255),         -- PDF scans
    students_csv VARCHAR(255),       -- CSV Ã©tudiants

    -- Structure de notation (JSON)
    grading_structure JSONB DEFAULT '[]'::jsonb,
    /*
    Format:
    [
      {
        "question": "1",
        "title": "Ã‰tude de fonction",
        "max_score": 5.0,
        "sub_questions": [
          {"id": "1.a", "title": "Limites", "max_score": 1.5},
          {"id": "1.b", "title": "DÃ©rivÃ©e", "max_score": 2.0}
        ]
      }
    ]
    */

    -- Status
    is_processed BOOLEAN DEFAULT FALSE,
    is_published BOOLEAN DEFAULT FALSE,

    -- Relations
    creator_id INTEGER REFERENCES auth_user(id) ON DELETE CASCADE,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_exam_creator ON exams_exam(creator_id);
CREATE INDEX idx_exam_date ON exams_exam(date);
CREATE INDEX idx_exam_is_processed ON exams_exam(is_processed);
CREATE INDEX idx_exam_is_published ON exams_exam(is_published);
```

**Contraintes** :
- `name` non vide
- `date` dans le passÃ© ou prÃ©sent
- `grading_structure` JSON valide

---

### 4. exams_exam_correctors (M:N)

**RÃ´le** : Relation Many-to-Many entre Exam et User (correcteurs)

```sql
CREATE TABLE exams_exam_correctors (
    id SERIAL PRIMARY KEY,
    exam_id UUID REFERENCES exams_exam(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES auth_user(id) ON DELETE CASCADE,
    UNIQUE (exam_id, user_id)
);

CREATE INDEX idx_exam_correctors_exam ON exams_exam_correctors(exam_id);
CREATE INDEX idx_exam_correctors_user ON exams_exam_correctors(user_id);
```

---

### 5. exams_copy (Copie)

**RÃ´le** : Copies d'examens (identifiÃ©es ou anonymes)

```sql
CREATE TABLE exams_copy (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Relations
    exam_id UUID REFERENCES exams_exam(id) ON DELETE CASCADE,
    student_id UUID REFERENCES students_student(id) ON DELETE SET NULL NULL,
    corrector_id INTEGER REFERENCES auth_user(id) ON DELETE SET NULL NULL,

    -- Identification
    anonymous_id VARCHAR(20) UNIQUE NOT NULL,  -- "A3-001"
    is_identified BOOLEAN DEFAULT FALSE,

    -- Status
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    /*
    Valeurs possibles:
    - PENDING: En attente de traitement
    - READY: PrÃªte Ã  corriger
    - IN_PROGRESS: En cours de correction
    - COMPLETED: CorrigÃ©e
    - PUBLISHED: PubliÃ©e (visible Ã©tudiant)
    */

    -- Fichiers
    pdf_file VARCHAR(255),

    -- Correction
    is_locked BOOLEAN DEFAULT FALSE,
    total_score NUMERIC(5, 2) NULL,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    corrected_at TIMESTAMP NULL
);

CREATE INDEX idx_copy_exam ON exams_copy(exam_id);
CREATE INDEX idx_copy_student ON exams_copy(student_id);
CREATE INDEX idx_copy_corrector ON exams_copy(corrector_id);
CREATE INDEX idx_copy_anonymous_id ON exams_copy(anonymous_id);
CREATE INDEX idx_copy_is_identified ON exams_copy(is_identified);
CREATE INDEX idx_copy_status ON exams_copy(status);
CREATE INDEX idx_copy_exam_status ON exams_copy(exam_id, status);  -- Composite
```

**Contraintes** :
- `anonymous_id` unique globalement
- `status` in ('PENDING', 'READY', 'IN_PROGRESS', 'COMPLETED', 'PUBLISHED')
- Si `is_locked=TRUE`, alors `status='COMPLETED'`
- Si `is_identified=TRUE`, alors `student_id` NOT NULL

---

### 6. exams_page (Page)

**RÃ´le** : Pages scannÃ©es des copies

```sql
CREATE TABLE exams_page (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Relations
    copy_id UUID REFERENCES exams_copy(id) ON DELETE CASCADE,

    -- Page
    page_number INTEGER NOT NULL,
    image_file VARCHAR(255) NOT NULL,  -- Chemin vers l'image

    -- MÃ©tadonnÃ©es
    width INTEGER NOT NULL,
    height INTEGER NOT NULL,
    dpi INTEGER DEFAULT 300,

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),

    UNIQUE (copy_id, page_number)
);

CREATE INDEX idx_page_copy ON exams_page(copy_id);
CREATE INDEX idx_page_copy_number ON exams_page(copy_id, page_number);  -- Composite
```

---

### 7. students_student (Ã‰tudiant)

**RÃ´le** : Ã‰tudiants

```sql
CREATE TABLE students_student (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- IdentitÃ©
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    email VARCHAR(254) UNIQUE NOT NULL,
    date_of_birth DATE NOT NULL,

    -- Lien avec User (pour authentification)
    user_id INTEGER REFERENCES auth_user(id) ON DELETE SET NULL NULL,

    -- MÃ©tadonnÃ©es
    student_number VARCHAR(20),
    class_name VARCHAR(50),  -- "G3", "Terminale S"

    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_student_email ON students_student(email);
CREATE INDEX idx_student_user ON students_student(user_id);
CREATE INDEX idx_student_last_name ON students_student(last_name);
CREATE INDEX idx_student_class_name ON students_student(class_name);
```

**Contraintes** :
- `email` unique
- `date_of_birth` dans le passÃ©

---

### 8. grading_grade (Note)

**RÃ´le** : Notes attribuÃ©es par question

```sql
CREATE TABLE grading_grade (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Relations
    copy_id UUID REFERENCES exams_copy(id) ON DELETE CASCADE,
    grader_id INTEGER REFERENCES auth_user(id) ON DELETE CASCADE,

    -- Question
    question_id VARCHAR(10) NOT NULL,  -- "1", "1.a", "2.b"

    -- Note
    score NUMERIC(5, 2) NOT NULL,
    max_score NUMERIC(5, 2) NOT NULL,

    -- Commentaire
    comment TEXT,

    -- Timestamps
    graded_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),

    UNIQUE (copy_id, question_id)
);

CREATE INDEX idx_grade_copy ON grading_grade(copy_id);
CREATE INDEX idx_grade_grader ON grading_grade(grader_id);
CREATE INDEX idx_grade_copy_question ON grading_grade(copy_id, question_id);  -- Composite
```

**Contraintes** :
- `score` <= `max_score`
- `score` >= 0
- `max_score` > 0

**Triggers** :
```sql
CREATE TRIGGER update_copy_total_score
AFTER INSERT OR UPDATE OR DELETE ON grading_grade
FOR EACH ROW
EXECUTE FUNCTION update_copy_total_score_func();
```

---

### 9. grading_annotation (Annotation PDF)

**RÃ´le** : Annotations sur les copies (surlignage, commentaires)

```sql
CREATE TABLE grading_annotation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Relations
    copy_id UUID REFERENCES exams_copy(id) ON DELETE CASCADE,
    author_id INTEGER REFERENCES auth_user(id) ON DELETE CASCADE,
    page_id UUID REFERENCES exams_page(id) ON DELETE CASCADE,

    -- Type
    annotation_type VARCHAR(20) NOT NULL,
    /*
    Valeurs:
    - HIGHLIGHT: Surlignage
    - UNDERLINE: SoulignÃ©
    - COMMENT: Commentaire textuel
    - STAMP: Tampon (bon, erreur, etc.)
    */

    -- Contenu
    content TEXT,  -- Texte du commentaire

    -- CoordonnÃ©es PDF (JSON)
    coordinates JSONB NOT NULL,
    /*
    Format:
    {
      "x": 100,
      "y": 200,
      "width": 50,
      "height": 20,
      "page": 1
    }
    */

    -- Style
    color VARCHAR(7) DEFAULT '#FF0000',  -- Hex color

    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_annotation_copy ON grading_annotation(copy_id);
CREATE INDEX idx_annotation_author ON grading_annotation(author_id);
CREATE INDEX idx_annotation_page ON grading_annotation(page_id);
CREATE INDEX idx_annotation_type ON grading_annotation(annotation_type);
```

---

### 10. identification_ocrresult (RÃ©sultat OCR)

**RÃ´le** : RÃ©sultats OCR pour identification des copies

```sql
CREATE TABLE identification_ocrresult (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Relation (1:1 avec Copy)
    copy_id UUID UNIQUE REFERENCES exams_copy(id) ON DELETE CASCADE,

    -- OCR classique (PRD-18)
    detected_text TEXT NOT NULL,
    confidence NUMERIC(3, 2) NOT NULL,  -- 0.00 - 1.00

    -- Top-K candidats (PRD-19, nouveau)
    top_candidates JSONB DEFAULT '[]'::jsonb,
    /*
    Format:
    [
      {
        "student_id": "uuid",
        "confidence": 0.85,
        "vote_count": 3,
        "vote_agreement": 0.75,
        "sources": [
          {
            "engine": "tesseract",
            "variant": 0,
            "text": "Jean Dupont 15/05/2008",
            "score": 0.82
          },
          {
            "engine": "easyocr",
            "variant": 1,
            "text": "JEAN DUPONT 15-05-2008",
            "score": 0.88
          }
        ]
      }
    ]
    */

    -- Mode OCR
    ocr_mode VARCHAR(20) DEFAULT 'AUTO',
    /*
    Valeurs:
    - AUTO: Identification automatique (confidence > 0.7)
    - SEMI_AUTO: Proposer top-k candidats (0.4 < confidence <= 0.7)
    - MANUAL: Recherche manuelle (confidence <= 0.4)
    */

    -- Audit trail
    selected_candidate_rank INTEGER NULL,  -- 1-5 si SEMI_AUTO
    manual_override BOOLEAN DEFAULT FALSE,  -- TRUE si MANUAL

    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_ocrresult_copy ON identification_ocrresult(copy_id);
CREATE INDEX idx_ocrresult_ocr_mode ON identification_ocrresult(ocr_mode);
CREATE INDEX idx_ocrresult_confidence ON identification_ocrresult(confidence);
```

---

### 11. processing_batchprocessingjob (Job Batch)

**RÃ´le** : Suivi des traitements batch asynchrones

```sql
CREATE TABLE processing_batchprocessingjob (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- Relations
    exam_id UUID REFERENCES exams_exam(id) ON DELETE CASCADE,

    -- Status Celery
    celery_task_id VARCHAR(255) UNIQUE NOT NULL,
    status VARCHAR(20) DEFAULT 'PENDING',
    /*
    Valeurs:
    - PENDING: En attente
    - PROCESSING: En cours
    - SUCCESS: TerminÃ© avec succÃ¨s
    - FAILURE: Ã‰chec
    */

    -- Progression
    progress INTEGER DEFAULT 0,  -- 0-100
    progress_message TEXT,

    -- RÃ©sultats
    copies_created INTEGER DEFAULT 0,
    auto_identified INTEGER DEFAULT 0,
    semi_auto INTEGER DEFAULT 0,
    manual INTEGER DEFAULT 0,

    -- Erreurs
    error_message TEXT,
    error_traceback TEXT,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMP NULL
);

CREATE INDEX idx_batch_job_exam ON processing_batchprocessingjob(exam_id);
CREATE INDEX idx_batch_job_celery_task ON processing_batchprocessingjob(celery_task_id);
CREATE INDEX idx_batch_job_status ON processing_batchprocessingjob(status);
```

---

### 12. processing_processinglog (Logs)

**RÃ´le** : Logs de traitement dÃ©taillÃ©s

```sql
CREATE TABLE processing_processinglog (
    id SERIAL PRIMARY KEY,

    -- Relations
    job_id UUID REFERENCES processing_batchprocessingjob(id) ON DELETE CASCADE NULL,
    exam_id UUID REFERENCES exams_exam(id) ON DELETE CASCADE NULL,
    copy_id UUID REFERENCES exams_copy(id) ON DELETE CASCADE NULL,

    -- Log
    level VARCHAR(10) NOT NULL,  -- DEBUG, INFO, WARNING, ERROR
    message TEXT NOT NULL,
    context JSONB,  -- DonnÃ©es additionnelles

    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_log_job ON processing_processinglog(job_id);
CREATE INDEX idx_log_exam ON processing_processinglog(exam_id);
CREATE INDEX idx_log_copy ON processing_processinglog(copy_id);
CREATE INDEX idx_log_level ON processing_processinglog(level);
CREATE INDEX idx_log_created_at ON processing_processinglog(created_at);
```

---

## ğŸ”— Relations et Contraintes

### CardinalitÃ©s

```
User (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Exam (creator)
User (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Copy (corrector)
User (M) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Exam (correctors)

Exam (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Copy
Student (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Copy

Copy (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Page
Copy (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Grade
Copy (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (1) OCRResult
Copy (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Annotation

Page (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Annotation

User (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Grade (grader)
User (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) Annotation (author)

Exam (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ (N) BatchProcessingJob
```

### Contraintes d'IntÃ©gritÃ© RÃ©fÃ©rentielle

```sql
-- ON DELETE CASCADE
ALTER TABLE exams_copy
    ADD CONSTRAINT fk_copy_exam
    FOREIGN KEY (exam_id) REFERENCES exams_exam(id) ON DELETE CASCADE;

-- ON DELETE SET NULL
ALTER TABLE exams_copy
    ADD CONSTRAINT fk_copy_student
    FOREIGN KEY (student_id) REFERENCES students_student(id) ON DELETE SET NULL;

ALTER TABLE exams_copy
    ADD CONSTRAINT fk_copy_corrector
    FOREIGN KEY (corrector_id) REFERENCES auth_user(id) ON DELETE SET NULL;

-- Contraintes CHECK
ALTER TABLE grading_grade
    ADD CONSTRAINT check_grade_score_positive
    CHECK (score >= 0);

ALTER TABLE grading_grade
    ADD CONSTRAINT check_grade_score_max
    CHECK (score <= max_score);

ALTER TABLE identification_ocrresult
    ADD CONSTRAINT check_ocrresult_confidence_range
    CHECK (confidence >= 0 AND confidence <= 1);
```

---

## ğŸ” Indexes et Performance

### Indexes Composites Critiques

```sql
-- Recherche de copies par exam + status
CREATE INDEX idx_copy_exam_status
ON exams_copy(exam_id, status);

-- Recherche de copies par correcteur + status
CREATE INDEX idx_copy_corrector_status
ON exams_copy(corrector_id, status);

-- Recherche de notes par copie + question
CREATE INDEX idx_grade_copy_question
ON grading_grade(copy_id, question_id);

-- Recherche de pages par copie + numÃ©ro
CREATE INDEX idx_page_copy_number
ON exams_page(copy_id, page_number);
```

### Statistiques et Analyse

```sql
-- Analyser les tables pour optimiser le query planner
ANALYZE exams_exam;
ANALYZE exams_copy;
ANALYZE grading_grade;
ANALYZE students_student;
```

---

## ğŸš€ RequÃªtes SQL Courantes

### 1. RÃ©cupÃ©rer toutes les copies d'un examen avec Ã©tudiants

```sql
SELECT
    c.id,
    c.anonymous_id,
    c.status,
    c.is_identified,
    c.total_score,
    s.first_name,
    s.last_name,
    s.email,
    u.username AS corrector_name
FROM exams_copy c
LEFT JOIN students_student s ON c.student_id = s.id
LEFT JOIN auth_user u ON c.corrector_id = u.id
WHERE c.exam_id = 'exam-uuid-here'
ORDER BY c.anonymous_id;
```

### 2. Calculer le total des notes d'une copie

```sql
SELECT
    copy_id,
    SUM(score) AS total_score,
    SUM(max_score) AS max_possible_score,
    COUNT(*) AS questions_graded
FROM grading_grade
WHERE copy_id = 'copy-uuid-here'
GROUP BY copy_id;
```

### 3. Statistiques d'un examen

```sql
SELECT
    e.name,
    e.date,
    COUNT(DISTINCT c.id) AS total_copies,
    COUNT(DISTINCT CASE WHEN c.is_identified THEN c.id END) AS identified_copies,
    COUNT(DISTINCT CASE WHEN c.status = 'COMPLETED' THEN c.id END) AS corrected_copies,
    AVG(c.total_score) AS average_score,
    MAX(c.total_score) AS max_score,
    MIN(c.total_score) AS min_score
FROM exams_exam e
LEFT JOIN exams_copy c ON e.id = c.exam_id
WHERE e.id = 'exam-uuid-here'
GROUP BY e.id, e.name, e.date;
```

### 4. Trouver les copies non identifiÃ©es d'un examen

```sql
SELECT
    c.id,
    c.anonymous_id,
    ocr.detected_text,
    ocr.confidence,
    ocr.ocr_mode
FROM exams_copy c
LEFT JOIN identification_ocrresult ocr ON c.id = ocr.copy_id
WHERE c.exam_id = 'exam-uuid-here'
  AND c.is_identified = FALSE
ORDER BY ocr.confidence DESC;
```

### 5. Dashboard enseignant (copies Ã  corriger)

```sql
SELECT
    e.name AS exam_name,
    c.id,
    c.anonymous_id,
    c.status,
    COALESCE(s.last_name, 'Non identifiÃ©') AS student_name
FROM exams_copy c
INNER JOIN exams_exam e ON c.exam_id = e.id
LEFT JOIN students_student s ON c.student_id = s.id
WHERE c.corrector_id = 123  -- User ID du prof
  AND c.status IN ('READY', 'IN_PROGRESS')
ORDER BY e.date DESC, c.anonymous_id;
```

---

## ğŸ’¾ Backup et Restauration

### Backup Complet

```bash
# Backup complet de la base
pg_dump -U korrigo_user -h localhost -F c -b -v -f backup_korrigo_$(date +%Y%m%d).dump korrigo_db

# Backup schema uniquement
pg_dump -U korrigo_user -h localhost -s -f schema_korrigo.sql korrigo_db

# Backup donnÃ©es uniquement
pg_dump -U korrigo_user -h localhost -a -f data_korrigo.sql korrigo_db
```

### Restauration

```bash
# Restaurer depuis dump complet
pg_restore -U korrigo_user -h localhost -d korrigo_db -v backup_korrigo_20260203.dump

# Restaurer depuis SQL
psql -U korrigo_user -h localhost -d korrigo_db -f backup_korrigo.sql
```

### StratÃ©gie de Backup Production

```bash
#!/bin/bash
# Script de backup quotidien (cron: 2h du matin)

DATE=$(date +%Y%m%d)
BACKUP_DIR="/var/backups/korrigo"
RETENTION_DAYS=30

# Backup complet
pg_dump -U korrigo_user -h localhost -F c -b -v \
    -f ${BACKUP_DIR}/korrigo_${DATE}.dump \
    korrigo_db

# Compression
gzip ${BACKUP_DIR}/korrigo_${DATE}.dump

# Nettoyage (garder 30 jours)
find ${BACKUP_DIR} -name "korrigo_*.dump.gz" -mtime +${RETENTION_DAYS} -delete

# Upload vers S3 (optionnel)
aws s3 cp ${BACKUP_DIR}/korrigo_${DATE}.dump.gz s3://korrigo-backups/
```

---

## ğŸ”§ Migrations Django

### Historique des Migrations

```
backend/
â”œâ”€â”€ core/migrations/
â”‚   â”œâ”€â”€ 0001_initial.py              # User, Group
â”‚   â””â”€â”€ 0002_add_phone_field.py
â”œâ”€â”€ exams/migrations/
â”‚   â”œâ”€â”€ 0001_initial.py              # Exam, Copy, Page
â”‚   â”œâ”€â”€ 0002_add_grading_structure.py
â”‚   â”œâ”€â”€ 0003_add_anonymous_id.py
â”‚   â””â”€â”€ 0004_add_is_locked.py
â”œâ”€â”€ grading/migrations/
â”‚   â”œâ”€â”€ 0001_initial.py              # Grade, Annotation
â”‚   â””â”€â”€ 0002_add_annotation_color.py
â”œâ”€â”€ students/migrations/
â”‚   â”œâ”€â”€ 0001_initial.py              # Student
â”‚   â””â”€â”€ 0002_add_user_link.py
â”œâ”€â”€ identification/migrations/
â”‚   â”œâ”€â”€ 0001_initial.py              # OCRResult
â”‚   â””â”€â”€ 0002_add_top_candidates.py   # PRD-19
â””â”€â”€ processing/migrations/
    â”œâ”€â”€ 0001_initial.py              # BatchProcessingJob, ProcessingLog
    â””â”€â”€ 0002_add_progress_fields.py
```

### Commandes de Migration

```bash
# CrÃ©er migrations
python manage.py makemigrations

# Appliquer migrations
python manage.py migrate

# Voir l'Ã©tat des migrations
python manage.py showmigrations

# Rollback (revenir Ã  la migration 0003)
python manage.py migrate exams 0003

# GÃ©nÃ©rer SQL (sans appliquer)
python manage.py sqlmigrate exams 0001
```

---

## ğŸ“Š VolumÃ©trie et Performances

### Estimations de VolumÃ©trie

**Pour un examen type (100 Ã©tudiants, 50 pages par copie)** :

| Table | Nombre de lignes | Taille estimÃ©e |
|-------|------------------|----------------|
| exams_exam | 1 | ~10 KB |
| exams_copy | 100 | ~50 KB |
| exams_page | 5,000 (100Ã—50) | ~2 MB |
| grading_grade | 500 (100Ã—5 questions) | ~100 KB |
| grading_annotation | 2,000 | ~500 KB |
| identification_ocrresult | 100 | ~200 KB |
| students_student | 100 | ~20 KB |
| **Total DB** | | **~3 MB** |
| **Fichiers (images)** | 5,000 pages Ã— 200 KB | **~1 GB** |

**Pour 100 examens sur un an** :
- Base de donnÃ©es : ~300 MB
- Fichiers images : ~100 GB

### Optimisations

```sql
-- Vacuum rÃ©gulier (rÃ©cupÃ©rer espace)
VACUUM FULL ANALYZE exams_copy;

-- Reindex
REINDEX TABLE exams_copy;

-- Partitioning par annÃ©e (pour gros volumes)
CREATE TABLE exams_exam_2026 PARTITION OF exams_exam
FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');
```

---

## ğŸ” SÃ©curitÃ© Base de DonnÃ©es

### Permissions PostgreSQL

```sql
-- CrÃ©er utilisateur korrigo_user (limitÃ©)
CREATE USER korrigo_user WITH PASSWORD 'secure_password';

-- Grants sur tables
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO korrigo_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO korrigo_user;

-- RÃ©voquer DROP
REVOKE DROP ON ALL TABLES IN SCHEMA public FROM korrigo_user;

-- Utilisateur lecture seule (pour backups, analytics)
CREATE USER korrigo_readonly WITH PASSWORD 'readonly_password';
GRANT CONNECT ON DATABASE korrigo_db TO korrigo_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO korrigo_readonly;
```

### Chiffrement

```sql
-- Chiffrement des donnÃ©es sensibles (PostgreSQL pgcrypto)
CREATE EXTENSION pgcrypto;

-- Exemple: chiffrer un champ
UPDATE students_student
SET email_encrypted = pgp_sym_encrypt(email, 'encryption_key');
```

### Audit Trail

```sql
-- Trigger d'audit (qui a modifiÃ© quoi et quand)
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    table_name VARCHAR(50),
    operation VARCHAR(10),
    user_id INTEGER,
    old_data JSONB,
    new_data JSONB,
    timestamp TIMESTAMP DEFAULT NOW()
);

CREATE OR REPLACE FUNCTION audit_trigger_func()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (table_name, operation, user_id, old_data, new_data)
    VALUES (
        TG_TABLE_NAME,
        TG_OP,
        current_setting('app.current_user_id', TRUE)::INTEGER,
        row_to_json(OLD),
        row_to_json(NEW)
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Appliquer audit sur tables sensibles
CREATE TRIGGER audit_exams_exam
AFTER INSERT OR UPDATE OR DELETE ON exams_exam
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();
```

---

## ğŸ“ Conclusion

La base de donnÃ©es PostgreSQL de Korrigo offre un schÃ©ma relationnel robuste et optimisÃ© pour la gestion complÃ¨te des examens, de la crÃ©ation Ã  la consultation des rÃ©sultats.

**Points clÃ©s** :
- SchÃ©ma normalisÃ© (3NF) avec relations claires
- Indexes optimisÃ©s pour les requÃªtes frÃ©quentes
- Support JSON pour structures flexibles (barÃ¨me, OCR candidats)
- StratÃ©gie de backup solide
- SÃ©curitÃ© renforcÃ©e avec permissions et audit trail

---

**Document rÃ©digÃ© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 FÃ©vrier 2026
