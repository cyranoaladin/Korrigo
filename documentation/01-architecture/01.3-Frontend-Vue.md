# 01.3 - Frontend Vue.js - Architecture D√©taill√©e

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Vue d'Ensemble du Frontend

Le frontend Korrigo est une **Single Page Application (SPA)** construite avec **Vue.js 3** utilisant la **Composition API**, **TypeScript**, et **Vite** comme bundler.

### Stack Technique

| Technologie | Version | Usage |
|-------------|---------|-------|
| **Vue.js** | 3.4.x | Framework principal |
| **Vue Router** | 4.x | Routing et navigation |
| **Pinia** | 2.x | State management |
| **Axios** | 1.x | HTTP client |
| **PDF.js** | 3.x | Visualisation et annotation PDF |
| **Vite** | 4.x | Build tool et dev server |
| **TypeScript** | 5.x | Type safety |
| **Playwright** | 1.x | Tests E2E |

---

## üìÅ Structure des Dossiers

```
frontend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ assets/              # Images, fonts, CSS globaux
‚îÇ   ‚îú‚îÄ‚îÄ components/          # Composants Vue r√©utilisables
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin/          # Composants admin
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ teacher/        # Composants enseignant
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ student/        # Composants √©tudiant
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ shared/         # Composants partag√©s
‚îÇ   ‚îú‚îÄ‚îÄ views/              # Pages/vues principales
‚îÇ   ‚îú‚îÄ‚îÄ router/             # Configuration Vue Router
‚îÇ   ‚îú‚îÄ‚îÄ stores/             # Stores Pinia
‚îÇ   ‚îú‚îÄ‚îÄ services/           # Services API et utils
‚îÇ   ‚îú‚îÄ‚îÄ types/              # Types TypeScript
‚îÇ   ‚îú‚îÄ‚îÄ composables/        # Composables Vue
‚îÇ   ‚îú‚îÄ‚îÄ App.vue            # Composant racine
‚îÇ   ‚îî‚îÄ‚îÄ main.ts            # Point d'entr√©e
‚îú‚îÄ‚îÄ public/                 # Fichiers statiques
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/              # Tests unitaires (Vitest)
‚îÇ   ‚îî‚îÄ‚îÄ e2e/               # Tests E2E (Playwright)
‚îú‚îÄ‚îÄ vite.config.ts         # Configuration Vite
‚îú‚îÄ‚îÄ tsconfig.json          # Configuration TypeScript
‚îî‚îÄ‚îÄ package.json           # D√©pendances npm
```

---

## üß© Composants Principaux

### Admin

#### DashboardAdmin.vue

**R√¥le** : Tableau de bord administrateur

**Fonctionnalit√©s** :
- Vue d'ensemble des examens (en cours, termin√©s)
- Statistiques globales (copies corrig√©es, en attente)
- Acc√®s rapide aux actions admin

```vue
<template>
  <div class="dashboard-admin">
    <h1>Tableau de Bord Administrateur</h1>

    <!-- Statistiques -->
    <div class="stats-grid">
      <StatCard title="Examens Actifs" :value="stats.active_exams" icon="exam" />
      <StatCard title="Copies √† Identifier" :value="stats.pending_copies" icon="clipboard" />
      <StatCard title="Copies Corrig√©es" :value="stats.corrected_copies" icon="check" />
      <StatCard title="Enseignants" :value="stats.teachers_count" icon="users" />
    </div>

    <!-- Liste des examens -->
    <div class="exams-list">
      <h2>Examens R√©cents</h2>
      <ExamCard
        v-for="exam in recentExams"
        :key="exam.id"
        :exam="exam"
        @click="goToExam(exam.id)"
      />
    </div>

    <!-- Actions rapides -->
    <div class="quick-actions">
      <button @click="createExam" class="btn-primary">
        Cr√©er un Examen
      </button>
      <button @click="manageUsers" class="btn-secondary">
        G√©rer les Utilisateurs
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { useExamStore } from '@/stores/exam'
import type { Exam, DashboardStats } from '@/types'

const router = useRouter()
const examStore = useExamStore()

const stats = ref<DashboardStats>({
  active_exams: 0,
  pending_copies: 0,
  corrected_copies: 0,
  teachers_count: 0
})

const recentExams = ref<Exam[]>([])

onMounted(async () => {
  await loadDashboard()
})

async function loadDashboard() {
  stats.value = await examStore.fetchStats()
  recentExams.value = await examStore.fetchExams({ limit: 5 })
}

function createExam() {
  router.push('/admin/exams/create')
}

function goToExam(examId: string) {
  router.push(`/admin/exams/${examId}`)
}
</script>
```

#### ExamCreate.vue

**R√¥le** : Formulaire de cr√©ation d'examen

**Workflow** :
1. Saisir informations (nom, date)
2. D√©finir structure de notation (bar√®me)
3. Uploader CSV √©tudiants
4. Uploader PDF scans
5. Lancer traitement

```vue
<template>
  <div class="exam-create">
    <h1>Cr√©er un Examen</h1>

    <!-- √âtape 1: Informations g√©n√©rales -->
    <section v-if="currentStep === 1">
      <h2>Informations G√©n√©rales</h2>
      <form @submit.prevent="nextStep">
        <div class="form-group">
          <label>Nom de l'examen</label>
          <input v-model="exam.name" required />
        </div>

        <div class="form-group">
          <label>Date</label>
          <input type="date" v-model="exam.date" required />
        </div>

        <button type="submit" class="btn-primary">Suivant</button>
      </form>
    </section>

    <!-- √âtape 2: Structure de notation -->
    <section v-if="currentStep === 2">
      <h2>Structure de Notation (Bar√®me)</h2>

      <div v-for="(question, idx) in exam.grading_structure" :key="idx" class="question-block">
        <div class="question-header">
          <input v-model="question.question" placeholder="Num√©ro (ex: 1)" />
          <input v-model="question.title" placeholder="Titre (ex: √âtude de fonction)" />
          <input type="number" v-model.number="question.max_score" placeholder="Points" />
          <button @click="removeQuestion(idx)" class="btn-danger">Supprimer</button>
        </div>

        <!-- Sous-questions -->
        <div class="sub-questions">
          <div v-for="(sub, subIdx) in question.sub_questions" :key="subIdx" class="sub-question">
            <input v-model="sub.id" placeholder="ID (ex: 1.a)" />
            <input v-model="sub.title" placeholder="Titre" />
            <input type="number" v-model.number="sub.max_score" placeholder="Points" />
            <button @click="removeSubQuestion(idx, subIdx)" class="btn-sm">√ó</button>
          </div>
          <button @click="addSubQuestion(idx)" class="btn-secondary">
            Ajouter Sous-Question
          </button>
        </div>
      </div>

      <button @click="addQuestion" class="btn-secondary">Ajouter Question</button>

      <div class="actions">
        <button @click="previousStep" class="btn-secondary">Pr√©c√©dent</button>
        <button @click="nextStep" class="btn-primary">Suivant</button>
      </div>
    </section>

    <!-- √âtape 3: Upload fichiers -->
    <section v-if="currentStep === 3">
      <h2>Upload des Fichiers</h2>

      <!-- CSV √©tudiants -->
      <div class="form-group">
        <label>Liste des √âtudiants (CSV)</label>
        <input
          type="file"
          accept=".csv"
          @change="handleCSVUpload"
          required
        />
        <small>Format: nom,prenom,email,date_naissance</small>
      </div>

      <!-- PDF scans -->
      <div class="form-group">
        <label>Scans des Copies (PDF)</label>
        <input
          type="file"
          accept=".pdf"
          @change="handlePDFUpload"
          required
        />
        <small>Formats support√©s: A3, A4</small>
      </div>

      <!-- Mode batch -->
      <div class="form-group">
        <label>
          <input type="checkbox" v-model="exam.batch_mode" />
          Activer mode batch A3 (split + OCR automatique)
        </label>
      </div>

      <div class="actions">
        <button @click="previousStep" class="btn-secondary">Pr√©c√©dent</button>
        <button @click="createExam" class="btn-primary" :disabled="isSubmitting">
          Cr√©er et Traiter
        </button>
      </div>
    </section>

    <!-- Progress -->
    <ProcessingProgress
      v-if="processingJobId"
      :jobId="processingJobId"
      @complete="onProcessingComplete"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue'
import { useRouter } from 'vue-router'
import { useExamStore } from '@/stores/exam'
import api from '@/services/api'
import type { ExamCreateRequest, Question } from '@/types'

const router = useRouter()
const examStore = useExamStore()

const currentStep = ref(1)
const isSubmitting = ref(false)
const processingJobId = ref<string | null>(null)

const exam = reactive<ExamCreateRequest>({
  name: '',
  date: '',
  grading_structure: [],
  batch_mode: true
})

const csvFile = ref<File | null>(null)
const pdfFile = ref<File | null>(null)

function addQuestion() {
  exam.grading_structure.push({
    question: '',
    title: '',
    max_score: 0,
    sub_questions: []
  })
}

function addSubQuestion(questionIdx: number) {
  exam.grading_structure[questionIdx].sub_questions.push({
    id: '',
    title: '',
    max_score: 0
  })
}

function removeQuestion(idx: number) {
  exam.grading_structure.splice(idx, 1)
}

function removeSubQuestion(questionIdx: number, subIdx: number) {
  exam.grading_structure[questionIdx].sub_questions.splice(subIdx, 1)
}

function handleCSVUpload(event: Event) {
  const target = event.target as HTMLInputElement
  csvFile.value = target.files?.[0] || null
}

function handlePDFUpload(event: Event) {
  const target = event.target as HTMLInputElement
  pdfFile.value = target.files?.[0] || null
}

function nextStep() {
  currentStep.value++
}

function previousStep() {
  currentStep.value--
}

async function createExam() {
  isSubmitting.value = true

  try {
    // 1. Cr√©er l'examen
    const examResponse = await examStore.createExam(exam)

    // 2. Upload fichiers
    const formData = new FormData()
    formData.append('exam_id', examResponse.id)
    formData.append('pdf_file', pdfFile.value!)
    formData.append('students_csv', csvFile.value!)
    formData.append('batch_mode', exam.batch_mode.toString())

    const uploadResponse = await api.post('/api/exams/upload/', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    })

    // 3. Suivre le traitement
    processingJobId.value = uploadResponse.data.job_id

  } catch (error) {
    console.error('Failed to create exam:', error)
    alert('Erreur lors de la cr√©ation de l\'examen')
  } finally {
    isSubmitting.value = false
  }
}

function onProcessingComplete() {
  router.push('/admin/dashboard')
}
</script>
```

#### IdentificationDesk.vue

**R√¥le** : Bureau d'identification pour copies non identifi√©es automatiquement

**Modes** :
- **AUTO** : Identification automatique (confidence > 0.7)
- **SEMI-AUTO** : Proposer top-5 candidats OCR (0.4 < confidence <= 0.7)
- **MANUAL** : Recherche manuelle (confidence <= 0.4)

```vue
<template>
  <div class="identification-desk">
    <h1>Bureau d'Identification</h1>

    <!-- Filtres -->
    <div class="filters">
      <select v-model="filterMode">
        <option value="">Tous</option>
        <option value="SEMI_AUTO">Semi-Automatique</option>
        <option value="MANUAL">Manuelle</option>
      </select>
    </div>

    <!-- Liste des copies -->
    <div class="copies-list">
      <CopyCard
        v-for="copy in unidentifiedCopies"
        :key="copy.id"
        :copy="copy"
        @click="selectCopy(copy)"
      />
    </div>

    <!-- Panel d'identification -->
    <div v-if="selectedCopy" class="identification-panel">
      <div class="copy-preview">
        <h2>Copie {{ selectedCopy.anonymous_id }}</h2>
        <img :src="selectedCopy.header_image_url" alt="Header" />
      </div>

      <!-- Mode SEMI-AUTO: Proposer candidats OCR -->
      <div v-if="selectedCopy.ocr_mode === 'SEMI_AUTO'" class="ocr-candidates">
        <h3>ü§ñ Suggestions OCR</h3>
        <p class="help-text">
          Les moteurs OCR ont d√©tect√© ces candidats. S√©lectionnez le bon √©tudiant :
        </p>

        <div
          v-for="candidate in ocrCandidates"
          :key="candidate.rank"
          class="candidate-card"
          :class="{ 'high-confidence': candidate.confidence > 0.6 }"
        >
          <div class="rank-badge">{{ candidate.rank }}</div>

          <div class="candidate-info">
            <h4>{{ candidate.student.last_name }} {{ candidate.student.first_name }}</h4>
            <p class="email">üìß {{ candidate.student.email }}</p>
            <p class="dob">üéÇ {{ formatDate(candidate.student.date_of_birth) }}</p>
          </div>

          <div class="confidence-metrics">
            <div class="confidence-bar">
              <label>Confiance: {{ (candidate.confidence * 100).toFixed(0) }}%</label>
              <div class="bar">
                <div class="fill" :style="{ width: `${candidate.confidence * 100}%` }"></div>
              </div>
            </div>
            <div class="vote-info">
              ‚úì {{ candidate.vote_count }} moteurs d'accord
            </div>
          </div>

          <button @click="selectCandidate(candidate.rank)" class="btn-select">
            S√©lectionner
          </button>

          <!-- D√©tails OCR -->
          <details class="ocr-sources">
            <summary>D√©tails OCR</summary>
            <ul>
              <li v-for="source in candidate.ocr_sources" :key="source.engine">
                <strong>{{ source.engine }}</strong> (variant {{ source.variant }}):
                "{{ source.text }}" (score: {{ source.score.toFixed(2) }})
              </li>
            </ul>
          </details>
        </div>

        <button @click="showManualSearch = true" class="btn-manual">
          Aucun de ces √©tudiants ? Recherche Manuelle
        </button>
      </div>

      <!-- Mode MANUAL: Recherche manuelle -->
      <div v-if="selectedCopy.ocr_mode === 'MANUAL' || showManualSearch" class="manual-search">
        <h3>Recherche Manuelle</h3>

        <input
          v-model="searchQuery"
          @input="searchStudents"
          placeholder="Nom, pr√©nom, ou email..."
          class="search-input"
        />

        <div class="search-results">
          <div
            v-for="student in searchResults"
            :key="student.id"
            class="student-result"
            @click="manualAssign(student.id)"
          >
            <h4>{{ student.last_name }} {{ student.first_name }}</h4>
            <p>{{ student.email }}</p>
            <p>{{ formatDate(student.date_of_birth) }}</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import api from '@/services/api'
import type { Copy, OCRCandidate, Student } from '@/types'

const unidentifiedCopies = ref<Copy[]>([])
const selectedCopy = ref<Copy | null>(null)
const ocrCandidates = ref<OCRCandidate[]>([])
const filterMode = ref('')
const showManualSearch = ref(false)
const searchQuery = ref('')
const searchResults = ref<Student[]>([])

onMounted(async () => {
  await loadUnidentifiedCopies()
})

async function loadUnidentifiedCopies() {
  const response = await api.get('/api/identification/copies/', {
    params: { is_identified: false }
  })
  unidentifiedCopies.value = response.data
}

async function selectCopy(copy: Copy) {
  selectedCopy.value = copy
  showManualSearch.value = false

  if (copy.ocr_mode === 'SEMI_AUTO') {
    // Charger candidats OCR
    const response = await api.get(`/api/identification/copies/${copy.id}/ocr-candidates/`)
    ocrCandidates.value = response.data.candidates
  }
}

async function selectCandidate(rank: number) {
  if (!selectedCopy.value) return

  await api.post(`/api/identification/copies/${selectedCopy.value.id}/select-candidate/`, {
    rank
  })

  // Retirer de la liste
  unidentifiedCopies.value = unidentifiedCopies.value.filter(
    c => c.id !== selectedCopy.value!.id
  )

  selectedCopy.value = null
}

async function searchStudents() {
  if (searchQuery.value.length < 2) return

  const response = await api.get('/api/students/', {
    params: { search: searchQuery.value }
  })
  searchResults.value = response.data
}

async function manualAssign(studentId: string) {
  if (!selectedCopy.value) return

  await api.post(`/api/identification/copies/${selectedCopy.value.id}/manual-assign/`, {
    student_id: studentId
  })

  unidentifiedCopies.value = unidentifiedCopies.value.filter(
    c => c.id !== selectedCopy.value!.id
  )

  selectedCopy.value = null
}

function formatDate(date: string) {
  return new Date(date).toLocaleDateString('fr-FR')
}
</script>
```

### Teacher

#### CopyGrading.vue

**R√¥le** : Interface de correction pour enseignants

**Fonctionnalit√©s** :
- Visualisation PDF avec PDF.js
- Annotations (surlignage, commentaires)
- Attribution des notes par question
- Sauvegarde automatique (draft)
- Verrouillage apr√®s correction

```vue
<template>
  <div class="copy-grading">
    <!-- Sidebar: Questions et notes -->
    <aside class="grading-sidebar">
      <h2>Notation</h2>

      <div v-for="question in exam.grading_structure" :key="question.question" class="question-block">
        <div class="question-header">
          <h3>{{ question.question }}. {{ question.title }}</h3>
          <span class="max-score">/ {{ question.max_score }}</span>
        </div>

        <!-- Sous-questions -->
        <div v-for="sub in question.sub_questions" :key="sub.id" class="sub-question">
          <label>{{ sub.id }}. {{ sub.title }}</label>
          <input
            type="number"
            v-model.number="grades[sub.id]"
            :max="sub.max_score"
            @input="autoSave"
          />
          <span class="max">/ {{ sub.max_score }}</span>
        </div>

        <!-- Commentaire -->
        <textarea
          v-model="comments[question.question]"
          placeholder="Commentaire..."
          @input="autoSave"
        ></textarea>
      </div>

      <!-- Total -->
      <div class="total-score">
        <strong>Total:</strong>
        <span class="score">{{ totalScore }} / {{ maxScore }}</span>
      </div>

      <!-- Actions -->
      <div class="actions">
        <button @click="saveDraft" class="btn-secondary">
          Sauvegarder Brouillon
        </button>
        <button @click="finalize" class="btn-primary">
          Finaliser et Verrouiller
        </button>
      </div>
    </aside>

    <!-- PDF Viewer -->
    <main class="pdf-viewer">
      <PDFViewer
        :src="copy.pdf_url"
        :annotations="annotations"
        @annotate="handleAnnotation"
      />
    </main>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useRoute } from 'vue-router'
import api from '@/services/api'
import PDFViewer from '@/components/shared/PDFViewer.vue'
import type { Copy, Exam, Annotation } from '@/types'

const route = useRoute()
const copyId = route.params.id as string

const copy = ref<Copy | null>(null)
const exam = ref<Exam | null>(null)
const grades = ref<Record<string, number>>({})
const comments = ref<Record<string, string>>({})
const annotations = ref<Annotation[]>([])

let autoSaveTimeout: ReturnType<typeof setTimeout> | null = null

onMounted(async () => {
  await loadCopy()
})

async function loadCopy() {
  const response = await api.get(`/api/grading/copies/${copyId}/`)
  copy.value = response.data
  exam.value = response.data.exam

  // Charger notes existantes
  if (copy.value.grades) {
    copy.value.grades.forEach(g => {
      grades.value[g.question_id] = g.score
      comments.value[g.question_id.split('.')[0]] = g.comment
    })
  }

  // Charger annotations
  annotations.value = copy.value.annotations || []
}

const totalScore = computed(() => {
  return Object.values(grades.value).reduce((sum, score) => sum + score, 0)
})

const maxScore = computed(() => {
  if (!exam.value) return 0
  return exam.value.grading_structure.reduce((sum, q) => {
    return sum + q.sub_questions.reduce((subSum, sub) => subSum + sub.max_score, 0)
  }, 0)
})

function autoSave() {
  // Debounce: sauvegarder 2s apr√®s derni√®re modification
  if (autoSaveTimeout) clearTimeout(autoSaveTimeout)

  autoSaveTimeout = setTimeout(async () => {
    await saveDraft()
  }, 2000)
}

async function saveDraft() {
  const gradesArray = Object.entries(grades.value).map(([questionId, score]) => ({
    question_id: questionId,
    score,
    max_score: getMaxScore(questionId),
    comment: comments.value[questionId.split('.')[0]] || ''
  }))

  await api.patch(`/api/grading/copies/${copyId}/`, {
    grades: gradesArray,
    annotations: annotations.value,
    status: 'IN_PROGRESS'
  })
}

async function finalize() {
  // V√©rifier que toutes les questions sont not√©es
  const allQuestions = exam.value!.grading_structure.flatMap(q =>
    q.sub_questions.map(sub => sub.id)
  )

  const missingGrades = allQuestions.filter(qId => !(qId in grades.value))

  if (missingGrades.length > 0) {
    alert(`Veuillez noter toutes les questions: ${missingGrades.join(', ')}`)
    return
  }

  // Sauvegarder et verrouiller
  await saveDraft()
  await api.post(`/api/grading/copies/${copyId}/lock/`)

  alert('Copie finalis√©e et verrouill√©e')
  router.push('/teacher/dashboard')
}

function handleAnnotation(annotation: Annotation) {
  annotations.value.push(annotation)
  autoSave()
}

function getMaxScore(questionId: string): number {
  for (const q of exam.value!.grading_structure) {
    for (const sub of q.sub_questions) {
      if (sub.id === questionId) return sub.max_score
    }
  }
  return 0
}
</script>
```

### Student

#### StudentPortal.vue

**R√¥le** : Portail √©tudiant pour consultation des copies

```vue
<template>
  <div class="student-portal">
    <h1>Mes Examens</h1>

    <div class="exams-grid">
      <div
        v-for="copy in myCopies"
        :key="copy.id"
        class="exam-card"
        @click="viewCopy(copy.id)"
      >
        <h2>{{ copy.exam.name }}</h2>
        <p class="date">{{ formatDate(copy.exam.date) }}</p>

        <div class="score" v-if="copy.is_published">
          <strong>{{ copy.total_score }}</strong>
          <span>/ {{ calculateMaxScore(copy.exam) }}</span>
        </div>

        <div class="status" v-else>
          <span class="badge">En cours de correction</span>
        </div>
      </div>
    </div>

    <!-- Pas de copies -->
    <div v-if="myCopies.length === 0" class="empty-state">
      <p>Aucun examen disponible</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import api from '@/services/api'
import type { Copy } from '@/types'

const router = useRouter()
const myCopies = ref<Copy[]>([])

onMounted(async () => {
  const response = await api.get('/api/students/copies/')
  myCopies.value = response.data
})

function viewCopy(copyId: string) {
  router.push(`/student/copies/${copyId}`)
}

function formatDate(date: string) {
  return new Date(date).toLocaleDateString('fr-FR')
}

function calculateMaxScore(exam: any) {
  return exam.grading_structure.reduce((sum, q) => sum + q.max_score, 0)
}
</script>
```

---

## üó∫Ô∏è Routing (Vue Router)

**Fichier** : `frontend/src/router/index.ts`

```typescript
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const routes = [
  // Public
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/Login.vue')
  },

  // Admin
  {
    path: '/admin',
    meta: { requiresAuth: true, requiresRole: 'admin' },
    children: [
      {
        path: 'dashboard',
        name: 'AdminDashboard',
        component: () => import('@/views/admin/DashboardAdmin.vue')
      },
      {
        path: 'exams/create',
        name: 'ExamCreate',
        component: () => import('@/views/admin/ExamCreate.vue')
      },
      {
        path: 'exams/:id',
        name: 'ExamDetails',
        component: () => import('@/views/admin/ExamDetails.vue')
      },
      {
        path: 'identification',
        name: 'IdentificationDesk',
        component: () => import('@/views/admin/IdentificationDesk.vue')
      }
    ]
  },

  // Teacher
  {
    path: '/teacher',
    meta: { requiresAuth: true, requiresRole: 'teacher' },
    children: [
      {
        path: 'dashboard',
        name: 'TeacherDashboard',
        component: () => import('@/views/teacher/DashboardTeacher.vue')
      },
      {
        path: 'copies/:id',
        name: 'CopyGrading',
        component: () => import('@/views/teacher/CopyGrading.vue')
      }
    ]
  },

  // Student
  {
    path: '/student',
    meta: { requiresAuth: true, requiresRole: 'student' },
    children: [
      {
        path: 'portal',
        name: 'StudentPortal',
        component: () => import('@/views/student/StudentPortal.vue')
      },
      {
        path: 'copies/:id',
        name: 'CopyView',
        component: () => import('@/views/student/CopyView.vue')
      }
    ]
  },

  // Redirect root
  {
    path: '/',
    redirect: () => {
      const authStore = useAuthStore()
      if (!authStore.isAuthenticated) return '/login'
      if (authStore.isAdmin) return '/admin/dashboard'
      if (authStore.isTeacher) return '/teacher/dashboard'
      return '/student/portal'
    }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// Navigation guards
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore()

  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next('/login')
  } else if (to.meta.requiresRole) {
    const requiredRole = to.meta.requiresRole as string

    if (requiredRole === 'admin' && !authStore.isAdmin) {
      next('/login')
    } else if (requiredRole === 'teacher' && !authStore.isTeacher) {
      next('/login')
    } else if (requiredRole === 'student' && !authStore.isStudent) {
      next('/login')
    } else {
      next()
    }
  } else {
    next()
  }
})

export default router
```

---

## üè™ State Management (Pinia)

### Auth Store

**Fichier** : `frontend/src/stores/auth.ts`

```typescript
import { defineStore } from 'pinia'
import api from '@/services/api'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null as User | null,
    isAuthenticated: false
  }),

  getters: {
    isAdmin: (state) => state.user?.is_superuser || false,
    isTeacher: (state) => state.user?.is_staff || false,
    isStudent: (state) => !state.user?.is_staff || false
  },

  actions: {
    async login(username: string, password: string) {
      const response = await api.post('/api/login/', { username, password })

      if (response.data.success) {
        this.user = response.data.user
        this.isAuthenticated = true
        return true
      }

      return false
    },

    async logout() {
      await api.post('/api/logout/')
      this.user = null
      this.isAuthenticated = false
    },

    async fetchMe() {
      const response = await api.get('/api/me/')
      this.user = response.data
      this.isAuthenticated = true
    }
  }
})
```

### Exam Store

**Fichier** : `frontend/src/stores/exam.ts`

```typescript
import { defineStore } from 'pinia'
import api from '@/services/api'
import type { Exam, ExamCreateRequest } from '@/types'

export const useExamStore = defineStore('exam', {
  state: () => ({
    exams: [] as Exam[],
    currentExam: null as Exam | null
  }),

  actions: {
    async fetchExams(params?: any) {
      const response = await api.get('/api/exams/', { params })
      this.exams = response.data
      return this.exams
    },

    async fetchExam(id: string) {
      const response = await api.get(`/api/exams/${id}/`)
      this.currentExam = response.data
      return this.currentExam
    },

    async createExam(data: ExamCreateRequest) {
      const response = await api.post('/api/exams/', data)
      this.exams.push(response.data)
      return response.data
    },

    async fetchStats() {
      const response = await api.get('/api/stats/')
      return response.data
    }
  }
})
```

---

## üåê Services API

**Fichier** : `frontend/src/services/api.ts`

```typescript
import axios from 'axios'

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:8088',
  withCredentials: true,  // Pour cookies CSRF
  headers: {
    'Content-Type': 'application/json'
  }
})

// Intercepteur pour CSRF token
api.interceptors.request.use((config) => {
  const csrfToken = getCookie('csrftoken')
  if (csrfToken) {
    config.headers['X-CSRFToken'] = csrfToken
  }
  return config
})

// Intercepteur pour erreurs
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Rediriger vers login
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

function getCookie(name: string): string | null {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop()?.split(';').shift() || null
  return null
}

export default api
```

---

## üß™ Tests

### Tests E2E (Playwright)

**Fichier** : `frontend/tests/e2e/auth_flow.spec.ts`

```typescript
import { test, expect } from '@playwright/test'

test.describe('Authentication Flow', () => {
  test('Admin login and dashboard', async ({ page }) => {
    // 1. Navigate to login
    await page.goto('http://localhost:8088/login')

    // 2. Fill credentials
    await page.fill('input[name="username"]', 'test_admin')
    await page.fill('input[name="password"]', 'admin123')

    // 3. Submit
    await page.click('button[type="submit"]')

    // 4. Verify redirect to dashboard
    await expect(page).toHaveURL(/\/admin\/dashboard/)

    // 5. Check page content
    await expect(page.locator('h1')).toContainText('Tableau de Bord')
  })

  test('Student login and portal', async ({ page }) => {
    await page.goto('http://localhost:8088/login')

    await page.fill('input[name="username"]', 'test_student')
    await page.fill('input[name="password"]', 'student123')

    await page.click('button[type="submit"]')

    await expect(page).toHaveURL(/\/student\/portal/)
    await expect(page.locator('h1')).toContainText('Mes Examens')
  })
})
```

---

## üîß Configuration Vite

**Fichier** : `frontend/vite.config.ts`

```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],

  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },

  server: {
    port: 8080,
    proxy: {
      '/api': {
        target: 'http://localhost:8088',
        changeOrigin: true
      }
    }
  },

  build: {
    outDir: '../backend/static/frontend',
    emptyOutDir: true
  }
})
```

---

## üìù Conclusion

Le frontend Vue.js de Korrigo fournit une interface utilisateur moderne et r√©active pour tous les profils (admin, enseignant, √©tudiant).

**Points cl√©s** :
- Architecture SPA avec Vue.js 3 + Composition API
- Routing avec navigation guards
- State management centralis√© avec Pinia
- Visualisation PDF avec PDF.js
- Tests E2E complets avec Playwright

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
