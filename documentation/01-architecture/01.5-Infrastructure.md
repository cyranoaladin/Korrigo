# 01.5 - Infrastructure Docker et D√©ploiement

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Vue d'Ensemble

Korrigo est d√©ploy√© en utilisant une **architecture containeris√©e Docker** orchestr√©e par **Docker Compose**. Cette approche garantit la portabilit√©, la reproductibilit√© et la facilit√© de d√©ploiement.

### Services Docker

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    NGINX (Port 80/443)                ‚îÇ
‚îÇ              Reverse Proxy + Static Files              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ                       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Backend Django   ‚îÇ   ‚îÇ   Frontend Vue    ‚îÇ
‚îÇ  (Gunicorn:8000)  ‚îÇ   ‚îÇ  (Static Build)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ           ‚îÇ          ‚îÇ           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   DB    ‚îÇ ‚îÇ Redis  ‚îÇ ‚îÇ Celery ‚îÇ ‚îÇ Media  ‚îÇ
‚îÇ  (PG)   ‚îÇ ‚îÇ Cache  ‚îÇ ‚îÇ Worker ‚îÇ ‚îÇ Volume ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üì¶ Services Docker

### 1. nginx

**R√¥le** : Reverse proxy, serveur de fichiers statiques, terminaison SSL

**Image** : nginx:1.25-alpine
**Ports** :
- 80 (HTTP)
- 443 (HTTPS)

**Configuration** : `infra/nginx/nginx.conf`

```nginx
upstream backend {
    server backend:8000;
}

server {
    listen 80;
    server_name korrigo.labomths.tn localhost;

    client_max_body_size 100M;  # Upload PDF max 100MB

    # Frontend (Vue.js build)
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }

    # Backend API
    location /api/ {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Timeouts pour uploads longs
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
    }

    # Django Admin
    location /admin/ {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Media files (PDF, images)
    location /media/ {
        alias /app/media/;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }

    # Static files (Django admin, DRF UI)
    location /static/ {
        alias /app/static/;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
}
```

**Volumes** :
- `./infra/nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro`
- `backend_static:/app/static:ro`
- `backend_media:/app/media:ro`
- `frontend_dist:/usr/share/nginx/html:ro`

---

### 2. backend

**R√¥le** : Application Django + Gunicorn

**Build** : `backend/Dockerfile`
**Image** : docker-backend:latest (9.94 GB)
**Port interne** : 8000
**Workers Gunicorn** : 3

**Dockerfile** :

```dockerfile
FROM python:3.9-slim

# System dependencies
RUN apt-get update && apt-get install -y \
    postgresql-client \
    libpq-dev \
    gcc \
    g++ \
    tesseract-ocr \
    tesseract-ocr-fra \
    libtesseract-dev \
    libgl1-mesa-glibg \
    libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# Working directory
WORKDIR /app

# Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Application code
COPY . .

# Collect static files (production)
RUN python manage.py collectstatic --noinput

# Gunicorn command
CMD ["gunicorn", "config.wsgi:application", \
     "--bind", "0.0.0.0:8000", \
     "--workers", "3", \
     "--timeout", "300", \
     "--access-logfile", "-", \
     "--error-logfile", "-"]
```

**Variables d'Environnement** :

```bash
# Django
DJANGO_SETTINGS_MODULE=config.settings
SECRET_KEY=your-secret-key-here
DEBUG=False
ALLOWED_HOSTS=localhost,korrigo.labomths.tn

# Database
DB_ENGINE=django.db.backends.postgresql
DB_NAME=korrigo_db
DB_USER=korrigo_user
DB_PASSWORD=secure_password
DB_HOST=db
DB_PORT=5432

# Redis
REDIS_URL=redis://redis:6379/0

# Celery
CELERY_BROKER_URL=redis://redis:6379/0
CELERY_RESULT_BACKEND=redis://redis:6379/0

# OCR
TESSERACT_PATH=/usr/bin/tesseract

# Media
MEDIA_ROOT=/app/media/
```

**Volumes** :
- `backend_media:/app/media/`
- `backend_static:/app/static/`

---

### 3. db (PostgreSQL)

**R√¥le** : Base de donn√©es relationnelle

**Image** : postgres:15-alpine
**Port** : 5432
**Volume** : `postgres_data:/var/lib/postgresql/data`

**Configuration** :

```yaml
db:
  image: postgres:15-alpine
  environment:
    POSTGRES_DB: korrigo_db
    POSTGRES_USER: korrigo_user
    POSTGRES_PASSWORD: ${DB_PASSWORD}
    POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=en_US.UTF-8"
  volumes:
    - postgres_data:/var/lib/postgresql/data
  healthcheck:
    test: ["CMD-SHELL", "pg_isready -U korrigo_user -d korrigo_db"]
    interval: 10s
    timeout: 5s
    retries: 5
```

**Optimisations PostgreSQL** (`postgresql.conf`) :

```ini
# Connections
max_connections = 100

# Memory
shared_buffers = 256MB
effective_cache_size = 1GB
work_mem = 16MB
maintenance_work_mem = 128MB

# WAL
wal_buffers = 8MB
checkpoint_completion_target = 0.9
```

---

### 4. redis

**R√¥le** : Cache et broker Celery

**Image** : redis:7-alpine
**Port** : 6379
**Volume** : `redis_data:/data`

**Configuration** :

```yaml
redis:
  image: redis:7-alpine
  command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
  volumes:
    - redis_data:/data
  healthcheck:
    test: ["CMD", "redis-cli", "ping"]
    interval: 10s
    timeout: 5s
    retries: 5
```

---

### 5. celery

**R√¥le** : Worker asynchrone pour traitement batch

**Build** : M√™me image que backend
**Commande** : `celery -A config worker -l info --concurrency=4`

**Configuration** :

```yaml
celery:
  build:
    context: ../../backend
    dockerfile: Dockerfile
  command: celery -A config worker -l info --concurrency=4 --max-tasks-per-child=100
  environment:
    # Same as backend
  depends_on:
    - db
    - redis
  volumes:
    - backend_media:/app/media/
```

**Optimisations** :
- `--concurrency=4` : 4 workers parall√®les
- `--max-tasks-per-child=100` : Red√©marrer worker apr√®s 100 t√¢ches (√©viter memory leaks)

---

## üê≥ Docker Compose

### Fichier docker-compose.local-prod.yml

**Emplacement** : `infra/docker/docker-compose.local-prod.yml`

```yaml
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    container_name: korrigo-db
    environment:
      POSTGRES_DB: korrigo_db
      POSTGRES_USER: korrigo_user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - korrigo-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U korrigo_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: korrigo-redis
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    networks:
      - korrigo-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s

  backend:
    build:
      context: ../../backend
      dockerfile: Dockerfile
    container_name: korrigo-backend
    command: gunicorn config.wsgi:application --bind 0.0.0.0:8000 --workers 3 --timeout 300
    env_file:
      - ../../backend/.env.prod
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - backend_media:/app/media/
      - backend_static:/app/static/
    networks:
      - korrigo-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health/live/"]
      interval: 30s
      timeout: 10s
      retries: 3

  celery:
    build:
      context: ../../backend
      dockerfile: Dockerfile
    container_name: korrigo-celery
    command: celery -A config worker -l info --concurrency=4 --max-tasks-per-child=100
    env_file:
      - ../../backend/.env.prod
    depends_on:
      - db
      - redis
    volumes:
      - backend_media:/app/media/
    networks:
      - korrigo-network

  nginx:
    image: nginx:1.25-alpine
    container_name: korrigo-nginx
    ports:
      - "8088:80"
    volumes:
      - ../nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - backend_static:/app/static:ro
      - backend_media:/app/media:ro
      - ../../frontend/dist:/usr/share/nginx/html:ro
    depends_on:
      - backend
    networks:
      - korrigo-network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/"]
      interval: 30s

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  backend_media:
    driver: local
  backend_static:
    driver: local

networks:
  korrigo-network:
    driver: bridge
```

---

## üöÄ Commandes Docker Compose

### D√©marrage

```bash
# Build + d√©marrage
docker compose -f infra/docker/docker-compose.local-prod.yml up -d --build

# D√©marrage seul (sans rebuild)
docker compose -f infra/docker/docker-compose.local-prod.yml up -d

# Voir les logs
docker compose -f infra/docker/docker-compose.local-prod.yml logs -f

# Logs d'un service sp√©cifique
docker compose -f infra/docker/docker-compose.local-prod.yml logs -f backend
```

### Arr√™t

```bash
# Arr√™ter les services
docker compose -f infra/docker/docker-compose.local-prod.yml stop

# Arr√™ter et supprimer conteneurs
docker compose -f infra/docker/docker-compose.local-prod.yml down

# Supprimer conteneurs + volumes (‚ö†Ô∏è perte de donn√©es)
docker compose -f infra/docker/docker-compose.local-prod.yml down -v
```

### Maintenance

```bash
# Red√©marrer un service
docker compose -f infra/docker/docker-compose.local-prod.yml restart backend

# Exec dans un conteneur
docker compose -f infra/docker/docker-compose.local-prod.yml exec backend bash

# Voir l'√©tat des services
docker compose -f infra/docker/docker-compose.local-prod.yml ps

# Voir l'utilisation des ressources
docker stats
```

### Migrations Django

```bash
# Cr√©er migrations
docker compose -f infra/docker/docker-compose.local-prod.yml exec backend python manage.py makemigrations

# Appliquer migrations
docker compose -f infra/docker/docker-compose.local-prod.yml exec backend python manage.py migrate

# Cr√©er superuser
docker compose -f infra/docker/docker-compose.local-prod.yml exec backend python manage.py createsuperuser
```

---

## üåç Environnements

### 1. D√©veloppement Local (docker-compose.dev.yml)

**Diff√©rences** :
- DEBUG=True
- Hot reload activ√© (volumes mont√©s)
- Pas d'optimisations
- Ports expos√©s directement

```yaml
# docker-compose.dev.yml
backend:
  command: python manage.py runserver 0.0.0.0:8000
  environment:
    DEBUG: "True"
  volumes:
    - ../../backend:/app  # Mount source code
  ports:
    - "8000:8000"  # Direct access
```

### 2. Production Locale (docker-compose.local-prod.yml)

**Caract√©ristiques** :
- Reproduction exacte de la production
- Nginx reverse proxy
- Gunicorn WSGI
- DEBUG=False
- Port unique : 8088

### 3. Production (docker-compose.prod.yml)

**Diff√©rences** :
- SSL/TLS avec Certbot
- Secrets Docker
- Logs centralis√©s
- Monitoring int√©gr√©
- Healthchecks stricts

```yaml
# docker-compose.prod.yml (serveur korrigo.labomths.tn)
version: '3.8'

services:
  nginx:
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./certbot/conf:/etc/letsencrypt:ro
      - ./certbot/www:/var/www/certbot:ro
    environment:
      - DOMAIN=korrigo.labomths.tn

  backend:
    secrets:
      - db_password
      - secret_key
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

secrets:
  db_password:
    file: ./secrets/db_password.txt
  secret_key:
    file: ./secrets/secret_key.txt
```

---

## üîê SSL/TLS avec Certbot

### Configuration Nginx avec SSL

```nginx
server {
    listen 80;
    server_name korrigo.labomths.tn;

    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name korrigo.labomths.tn;

    # SSL certificates (Let's Encrypt)
    ssl_certificate /etc/letsencrypt/live/korrigo.labomths.tn/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/korrigo.labomths.tn/privkey.pem;

    # SSL configuration (Mozilla Intermediate)
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers off;

    # HSTS
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;

    # ... rest of config
}
```

### Renouvellement Auto Certbot

```bash
# Cron job (renouvellement tous les 12h)
0 */12 * * * docker compose -f /path/to/docker-compose.prod.yml run --rm certbot renew && docker compose -f /path/to/docker-compose.prod.yml exec nginx nginx -s reload
```

---

## üìä Monitoring et Logs

### Health Checks

**Backend** :
```bash
curl http://localhost:8088/api/health/live/
curl http://localhost:8088/api/health/ready/
```

**PostgreSQL** :
```bash
docker compose exec db pg_isready -U korrigo_user -d korrigo_db
```

**Redis** :
```bash
docker compose exec redis redis-cli ping
```

### Logs Structur√©s

**Configuration Django Logging** :

```python
# config/settings.py

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'json': {
            '()': 'pythonjsonlogger.jsonlogger.JsonFormatter',
            'format': '%(asctime)s %(name)s %(levelname)s %(message)s'
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'json',
        },
        'file': {
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/app/logs/korrigo.log',
            'maxBytes': 10485760,  # 10 MB
            'backupCount': 5,
            'formatter': 'json',
        },
    },
    'root': {
        'level': 'INFO',
        'handlers': ['console', 'file'],
    },
    'loggers': {
        'django': {
            'level': 'INFO',
        },
        'processing': {
            'level': 'DEBUG',
        },
        'identification': {
            'level': 'DEBUG',
        },
    },
}
```

**Visualisation Logs** :

```bash
# Logs temps r√©el
docker compose logs -f --tail=100

# Filtrer par service
docker compose logs -f backend celery

# Filtrer par erreur
docker compose logs backend | grep ERROR

# Exporter logs JSON
docker compose logs backend --no-color > backend.log
```

### Prometheus Metrics

**Exposition des m√©triques** :

```python
# backend/core/middleware.py

from prometheus_client import Counter, Histogram
import time

request_count = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
request_duration = Histogram('http_request_duration_seconds', 'HTTP request duration')

class PrometheusMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        start_time = time.time()

        response = self.get_response(request)

        duration = time.time() - start_time
        request_count.labels(
            method=request.method,
            endpoint=request.path,
            status=response.status_code
        ).inc()
        request_duration.observe(duration)

        return response
```

**Endpoint Prometheus** :

```python
# backend/core/urls.py

from prometheus_client import generate_latest
from django.http import HttpResponse

def metrics_view(request):
    # V√©rifier token
    token = request.headers.get('X-Metrics-Token')
    if token != settings.METRICS_TOKEN:
        return HttpResponse('Forbidden', status=403)

    return HttpResponse(generate_latest(), content_type='text/plain')
```

---

## üîß Optimisations Production

### 1. Gunicorn Tuning

```python
# gunicorn.conf.py

import multiprocessing

bind = "0.0.0.0:8000"
workers = multiprocessing.cpu_count() * 2 + 1  # Formule recommand√©e
worker_class = "sync"  # ou "gevent" pour async
worker_connections = 1000
timeout = 300  # 5 minutes pour uploads longs
keepalive = 5

# Logging
accesslog = "-"
errorlog = "-"
loglevel = "info"

# Reload on code change (dev only)
reload = False
```

### 2. Nginx Caching

```nginx
# Cache pour media files
location /media/ {
    alias /app/media/;
    expires 30d;
    add_header Cache-Control "public, immutable";

    # Cache proxy
    proxy_cache media_cache;
    proxy_cache_valid 200 30d;
    proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
}
```

### 3. PostgreSQL Connection Pooling

```python
# config/settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        # ...
        'CONN_MAX_AGE': 600,  # Pooling (10 min)
        'OPTIONS': {
            'connect_timeout': 10,
        }
    }
}
```

### 4. Redis Caching

```python
# config/settings.py

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://redis:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'SOCKET_CONNECT_TIMEOUT': 5,
            'SOCKET_TIMEOUT': 5,
            'COMPRESSOR': 'django_redis.compressors.zlib.ZlibCompressor',
            'IGNORE_EXCEPTIONS': True,
        }
    }
}
```

---

## üíæ Backup Automatis√©

### Script Backup Docker

```bash
#!/bin/bash
# backup_korrigo.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups/korrigo"

# 1. Backup PostgreSQL
docker compose exec -T db pg_dump -U korrigo_user korrigo_db | gzip > ${BACKUP_DIR}/db_${DATE}.sql.gz

# 2. Backup Media files
docker run --rm -v backend_media:/data -v ${BACKUP_DIR}:/backup alpine tar czf /backup/media_${DATE}.tar.gz -C /data .

# 3. Backup Redis (optionnel)
docker compose exec -T redis redis-cli SAVE
docker cp korrigo-redis:/data/dump.rdb ${BACKUP_DIR}/redis_${DATE}.rdb

# 4. Nettoyage (garder 7 jours)
find ${BACKUP_DIR} -name "*.sql.gz" -mtime +7 -delete
find ${BACKUP_DIR} -name "*.tar.gz" -mtime +7 -delete

echo "Backup completed: ${DATE}"
```

### Cron Backup Quotidien

```bash
# /etc/cron.d/korrigo-backup

# Backup quotidien √† 2h du matin
0 2 * * * root /opt/korrigo/backup_korrigo.sh >> /var/log/korrigo_backup.log 2>&1
```

---

## üîÑ D√©ploiement Continu (CI/CD)

### Exemple GitHub Actions

```yaml
# .github/workflows/deploy.yml

name: Deploy to Production

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run tests
        run: |
          docker compose -f infra/docker/docker-compose.test.yml up --abort-on-container-exit
          docker compose -f infra/docker/docker-compose.test.yml down

      - name: Build images
        run: |
          docker compose -f infra/docker/docker-compose.prod.yml build

      - name: Push to registry
        run: |
          docker tag korrigo-backend registry.labomths.tn/korrigo-backend:latest
          docker push registry.labomths.tn/korrigo-backend:latest

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.PROD_SERVER_HOST }}
          username: ${{ secrets.PROD_SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /opt/korrigo
            docker compose pull
            docker compose up -d --force-recreate
            docker compose exec backend python manage.py migrate --noinput
```

---

## üìù Conclusion

L'infrastructure Docker de Korrigo offre un environnement de d√©ploiement robuste, scalable et facile √† maintenir.

**Points cl√©s** :
- Architecture containeris√©e compl√®te (5 services)
- Nginx reverse proxy avec SSL/TLS
- PostgreSQL + Redis pour persistance et cache
- Celery pour traitement asynchrone
- Monitoring et logs structur√©s
- Backup automatis√© quotidien
- D√©ploiement continu avec CI/CD

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
