# 07.2 - Format CSV Liste des √âtudiants

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Objectif

Le fichier CSV contient la **liste des √©tudiants** attendus pour un examen. Il est utilis√© pour :
- Identification des copies (matching OCR)
- Validation des √©tudiants
- G√©n√©ration des r√©sultats

---

## üìã Format Standard

### Structure Obligatoire

| Colonne | Type | Description | Exemple |
|---------|------|-------------|---------|
| **nom** | string | Nom de famille (MAJUSCULES) | DUPONT |
| **prenom** | string | Pr√©nom (Premi√®re lettre majuscule) | Jean |
| **email** | string | Email √©tudiant (unique) | jean.dupont@viatique.local |
| **date_naissance** | date | Date de naissance (DD/MM/YYYY) | 15/05/2008 |

### Colonnes Optionnelles

| Colonne | Type | Description | Exemple |
|---------|------|-------------|---------|
| **numero_etudiant** | string | Num√©ro d'√©tudiant | STU001 |
| **classe** | string | Classe ou groupe | G3, Terminale S |

---

## üìÑ Exemples

### Exemple 1 : Format Minimal (4 colonnes)

```csv
nom,prenom,email,date_naissance
DUPONT,Jean,jean.dupont@viatique.local,15/05/2008
MARTIN,Marie,marie.martin@viatique.local,03/12/2007
BERNARD,Luc,luc.bernard@viatique.local,22/08/2008
PETIT,Sophie,sophie.petit@viatique.local,10/03/2007
DURAND,Pierre,pierre.durand@viatique.local,28/11/2008
```

### Exemple 2 : Format Complet (6 colonnes)

```csv
nom,prenom,email,date_naissance,numero_etudiant,classe
DUPONT,Jean,jean.dupont@viatique.local,15/05/2008,STU001,G3
MARTIN,Marie,marie.martin@viatique.local,03/12/2007,STU002,G3
BERNARD,Luc,luc.bernard@viatique.local,22/08/2008,STU003,G3
PETIT,Sophie,sophie.petit@viatique.local,10/03/2007,STU004,G3
DURAND,Pierre,pierre.durand@viatique.local,28/11/2008,STU005,G3
```

### Exemple 3 : Avec Point-virgule (Excel)

```csv
nom;prenom;email;date_naissance;numero_etudiant;classe
DUPONT;Jean;jean.dupont@viatique.local;15/05/2008;STU001;G3
MARTIN;Marie;marie.martin@viatique.local;03/12/2007;STU002;G3
BERNARD;Luc;luc.bernard@viatique.local;22/08/2008;STU003;G3
```

---

## ‚úÖ R√®gles de Validation

### 1. Format Fichier

- **Extension** : `.csv`
- **Encodage** : UTF-8 (recommand√©) ou ISO-8859-1
- **S√©parateur** : Virgule `,` ou point-virgule `;`
- **En-t√™te** : Premi√®re ligne = noms de colonnes
- **Taille max** : 10 MB

### 2. Colonnes Obligatoires

```python
REQUIRED_COLUMNS = ['nom', 'prenom', 'email', 'date_naissance']
```

### 3. Validation Nom/Pr√©nom

- **Non vide**
- **Longueur** : 2-100 caract√®res
- **Caract√®res autoris√©s** : Lettres, espaces, tirets, apostrophes
- **Format recommand√©** :
  - Nom : MAJUSCULES (`DUPONT`)
  - Pr√©nom : Premi√®re majuscule (`Jean`)

```python
import re

def validate_name(name: str) -> bool:
    """Valider nom/pr√©nom."""
    if not name or len(name) < 2 or len(name) > 100:
        return False

    # Accepter lettres, espaces, tirets, apostrophes, accents
    pattern = r"^[A-Z√Ä-√øa-z\s\-']+$"
    return bool(re.match(pattern, name))
```

### 4. Validation Email

- **Format** : `user@domain.tld`
- **Unique** : Pas de doublons dans le CSV
- **Regex** :

```python
import re

def validate_email(email: str) -> bool:
    """Valider format email."""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))
```

### 5. Validation Date de Naissance

- **Format** : `DD/MM/YYYY` (recommand√©) ou `YYYY-MM-DD`
- **Plage valide** : 1990 - ann√©e courante
- **Coh√©rence** : √âtudiant doit avoir 10-25 ans

```python
from datetime import datetime

def validate_date_of_birth(dob_str: str) -> bool:
    """Valider date de naissance."""
    # Essayer formats courants
    formats = ['%d/%m/%Y', '%Y-%m-%d', '%d-%m-%Y']

    for fmt in formats:
        try:
            dob = datetime.strptime(dob_str, fmt)

            # V√©rifier plage
            current_year = datetime.now().year
            birth_year = dob.year

            if birth_year < 1990 or birth_year > current_year:
                return False

            # V√©rifier √¢ge (10-25 ans)
            age = current_year - birth_year
            if age < 10 or age > 25:
                return False

            return True

        except ValueError:
            continue

    return False
```

---

## üîç Validation Backend

### Parser CSV

```python
import csv
from typing import List, Dict
from django.core.exceptions import ValidationError

def parse_student_csv(file_path: str) -> List[Dict]:
    """
    Parser et valider CSV √©tudiants.

    Args:
        file_path: Chemin vers fichier CSV

    Returns:
        Liste de dicts {nom, prenom, email, date_naissance, ...}

    Raises:
        ValidationError: Si CSV invalide
    """
    students = []
    errors = []

    # D√©tecter encodage
    with open(file_path, 'rb') as f:
        raw = f.read()
        encoding = 'utf-8' if b'\xef\xbb\xbf' in raw or raw.decode('utf-8', errors='ignore') else 'iso-8859-1'

    # Lire CSV
    with open(file_path, 'r', encoding=encoding) as f:
        # D√©tecter s√©parateur
        sample = f.read(1024)
        f.seek(0)

        delimiter = ';' if ';' in sample else ','

        reader = csv.DictReader(f, delimiter=delimiter)

        # V√©rifier colonnes obligatoires
        required_columns = ['nom', 'prenom', 'email', 'date_naissance']
        missing_columns = set(required_columns) - set(reader.fieldnames or [])

        if missing_columns:
            raise ValidationError(f"Missing required columns: {', '.join(missing_columns)}")

        # Parser lignes
        seen_emails = set()

        for idx, row in enumerate(reader, start=2):  # Start at 2 (line 1 = header)
            # Nettoyer valeurs
            row = {k.strip(): v.strip() for k, v in row.items()}

            # Valider
            row_errors = []

            # Nom
            if not validate_name(row['nom']):
                row_errors.append(f"Invalid nom: {row['nom']}")

            # Pr√©nom
            if not validate_name(row['prenom']):
                row_errors.append(f"Invalid prenom: {row['prenom']}")

            # Email
            if not validate_email(row['email']):
                row_errors.append(f"Invalid email: {row['email']}")

            if row['email'] in seen_emails:
                row_errors.append(f"Duplicate email: {row['email']}")

            seen_emails.add(row['email'])

            # Date de naissance
            if not validate_date_of_birth(row['date_naissance']):
                row_errors.append(f"Invalid date_naissance: {row['date_naissance']}")

            if row_errors:
                errors.append(f"Line {idx}: {'; '.join(row_errors)}")
            else:
                students.append(row)

    # Si erreurs, lever exception
    if errors:
        raise ValidationError('\n'.join(errors))

    return students
```

### Importer √âtudiants Django

```python
from students.models import Student
from datetime import datetime

def import_students_from_csv(csv_path: str) -> int:
    """
    Importer √©tudiants depuis CSV vers base Django.

    Returns:
        Nombre d'√©tudiants cr√©√©s
    """
    # Parser CSV
    students_data = parse_student_csv(csv_path)

    created_count = 0

    for student_data in students_data:
        # Parser date
        dob = datetime.strptime(student_data['date_naissance'], '%d/%m/%Y').date()

        # Cr√©er ou mettre √† jour Student
        student, created = Student.objects.update_or_create(
            email=student_data['email'],
            defaults={
                'first_name': student_data['prenom'],
                'last_name': student_data['nom'].upper(),
                'date_of_birth': dob,
                'student_number': student_data.get('numero_etudiant', ''),
                'class_name': student_data.get('classe', '')
            }
        )

        if created:
            created_count += 1

    return created_count
```

---

## üìä Utilisation dans le Workflow

### 1. Upload CSV

```python
# exams/views.py

@action(detail=False, methods=['post'])
def upload(self, request):
    """Upload PDF + CSV."""

    students_csv = request.FILES.get('students_csv')

    # Valider CSV
    try:
        students = parse_student_csv(students_csv.temporary_file_path())
    except ValidationError as e:
        return Response({'error': str(e)}, status=400)

    # Sauvegarder
    exam.students_csv = students_csv
    exam.save()

    # Importer √©tudiants
    import_students_from_csv(exam.students_csv.path)

    # Lancer traitement batch...
```

### 2. Matching OCR

```python
# processing/services/batch_processor.py

def _match_student(self, ocr_name: str, ocr_date: str,
                   students: List[Student]) -> StudentMatch:
    """
    Matcher r√©sultat OCR avec liste CSV.

    Args:
        ocr_name: "DUPONT JEAN" (OCR text)
        ocr_date: "15/05/2008"
        students: Liste √©tudiants depuis CSV

    Returns:
        StudentMatch(student_id, confidence, ...)
    """
    from fuzzywuzzy import fuzz

    best_match = None
    best_score = 0.0

    for student in students:
        # Nom complet CSV
        csv_full_name = f"{student.last_name} {student.first_name}".upper()

        # Score nom (Jaccard similarity)
        name_score = fuzz.token_sort_ratio(ocr_name.upper(), csv_full_name) / 100.0

        # Score date
        csv_date = student.date_of_birth.strftime('%d/%m/%Y')
        date_score = 1.0 if ocr_date == csv_date else 0.0

        # Score combin√© (0.6 * nom + 0.4 * date)
        total_score = 0.6 * name_score + 0.4 * date_score

        if total_score > best_score:
            best_score = total_score
            best_match = student

    if best_match and best_score > 0.5:
        return StudentMatch(
            student_id=best_match.id,
            confidence=best_score,
            matched_name=f"{best_match.last_name} {best_match.first_name}"
        )

    return None
```

---

## üõ†Ô∏è Outils de G√©n√©ration CSV

### Script Python

```python
#!/usr/bin/env python3
"""
G√©n√©rer CSV exemple pour tests.

Usage:
    python generate_test_csv.py --count 30 --output students.csv
"""

import csv
import random
from datetime import date, timedelta

FIRST_NAMES = ['Jean', 'Marie', 'Luc', 'Sophie', 'Pierre', 'Emma', 'Thomas', 'L√©a', 'Nicolas', 'Chlo√©']
LAST_NAMES = ['DUPONT', 'MARTIN', 'BERNARD', 'PETIT', 'DURAND', 'LEROY', 'MOREAU', 'SIMON', 'LAURENT', 'LEFEBVRE']

def generate_csv(count: int, output_file: str):
    """G√©n√©rer CSV avec N √©tudiants."""

    with open(output_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)

        # Header
        writer.writerow(['nom', 'prenom', 'email', 'date_naissance', 'numero_etudiant', 'classe'])

        # Rows
        for i in range(1, count + 1):
            first_name = random.choice(FIRST_NAMES)
            last_name = random.choice(LAST_NAMES)

            # Email unique
            email = f"{first_name.lower()}.{last_name.lower()}{i}@viatique.local"

            # Date de naissance (15-18 ans)
            birth_year = random.randint(2006, 2009)
            birth_month = random.randint(1, 12)
            birth_day = random.randint(1, 28)
            dob = date(birth_year, birth_month, birth_day).strftime('%d/%m/%Y')

            # Num√©ro
            numero = f"STU{i:03d}"

            # Classe
            classe = random.choice(['G3', 'Terminale S', '1√®re ES'])

            writer.writerow([last_name, first_name, email, dob, numero, classe])

    print(f"‚úÖ Generated {count} students in {output_file}")

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('--count', type=int, default=30)
    parser.add_argument('--output', default='students.csv')

    args = parser.parse_args()
    generate_csv(args.count, args.output)
```

### Usage

```bash
# G√©n√©rer 30 √©tudiants
python generate_test_csv.py --count 30 --output students_test.csv

# V√©rifier
head students_test.csv
```

---

## ‚ùå Erreurs Courantes

### Erreur 1 : Encodage Incorrect

**Sympt√¥me** : Caract√®res accentu√©s mal affich√©s (`√É¬©` au lieu de `√©`)

**Solution** :
```bash
# Convertir en UTF-8
iconv -f ISO-8859-1 -t UTF-8 students.csv > students_utf8.csv
```

### Erreur 2 : Mauvais S√©parateur

**Sympt√¥me** : Toutes colonnes dans une seule colonne

**Solution** :
- V√©rifier si s√©parateur = `;` (Excel) au lieu de `,`
- Ouvrir dans √©diteur texte pour confirmer

### Erreur 3 : Format Date Incorrect

**Sympt√¥me** : `Invalid date_naissance: 2008-05-15`

**Solution** :
- Utiliser format `DD/MM/YYYY` : `15/05/2008`
- OU adapter parser backend pour accepter `YYYY-MM-DD`

### Erreur 4 : Emails Dupliqu√©s

**Sympt√¥me** : `Duplicate email: jean.dupont@viatique.local`

**Solution** :
- V√©rifier CSV pour doublons
- Assurer unicit√© emails

### Erreur 5 : BOM UTF-8

**Sympt√¥me** : Premi√®re colonne = `\ufeffnom` au lieu de `nom`

**Solution** :
```python
# Supprimer BOM
with open('students.csv', 'r', encoding='utf-8-sig') as f:
    reader = csv.DictReader(f)
```

---

## üìù Conclusion

Le format CSV pour la liste des √©tudiants est simple mais strict. Respecter le format et les r√®gles de validation garantit un traitement OCR optimal.

**Points cl√©s** :
- 4 colonnes obligatoires (nom, prenom, email, date_naissance)
- Format date : DD/MM/YYYY
- Encodage : UTF-8
- Validation stricte avant import
- Emails uniques

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
