# 07.5 - S√©curit√© et Bonnes Pratiques

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Objectif

Ce document d√©crit les **mesures de s√©curit√©** impl√©ment√©es dans Korrigo et les bonnes pratiques pour maintenir un syst√®me s√©curis√© conforme aux standards OWASP Top 10.

---

## üîê Authentification

### 1. Authentification Enseignants/Admins

**M√©thode** : Django Session-based Authentication

**Configuration** :

```python
# backend/settings.py

# Session Configuration
SESSION_ENGINE = 'django.contrib.sessions.backends.db'
SESSION_COOKIE_NAME = 'korrigo_sessionid'
SESSION_COOKIE_AGE = 3600 * 2  # 2 heures
SESSION_COOKIE_SECURE = True  # HTTPS uniquement
SESSION_COOKIE_HTTPONLY = True  # Pas d'acc√®s JavaScript
SESSION_COOKIE_SAMESITE = 'Strict'  # Protection CSRF
SESSION_SAVE_EVERY_REQUEST = True  # Refresh session √† chaque requ√™te

# Password Hashing
PASSWORD_HASHERS = [
    'django.contrib.auth.hashers.Argon2PasswordHasher',  # Recommand√©
    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
]

# Password Validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 12,  # Minimum 12 caract√®res
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]
```

**S√©curit√© mot de passe** :

```python
# Exemple validation
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError

try:
    validate_password('MyP@ssw0rd2026!')
    # OK
except ValidationError as e:
    print(e.messages)
    # ['Ce mot de passe est trop courant.']
```

---

### 2. Authentification √âtudiants

**M√©thode** : Email + Date de naissance (session-based, pas de compte Django)

**S√©curit√©** :

```python
# students/views.py

from django_ratelimit.decorators import ratelimit

@ratelimit(key='ip', rate='5/m', method='POST')
@api_view(['POST'])
def student_login(request):
    """
    Login √©tudiant avec rate limiting.

    Rate limit: 5 tentatives par minute par IP
    """
    email = request.data.get('email')
    dob = request.data.get('date_of_birth')

    # Validation
    if not email or not dob:
        return Response({'error': 'Missing credentials'}, status=400)

    # Recherche √©tudiant (case-insensitive email)
    try:
        student = Student.objects.get(
            email__iexact=email,
            date_of_birth=parse_date(dob)
        )
    except Student.DoesNotExist:
        # Log failed attempt
        logger.warning(f"Failed student login: {email} from {request.META.get('REMOTE_ADDR')}")

        # Generic error message (√©viter √©num√©ration)
        return Response({'error': 'Invalid credentials'}, status=401)

    # Cr√©er session
    request.session['student_id'] = student.id
    request.session['is_student'] = True
    request.session.set_expiry(3600 * 2)  # 2 heures

    return Response({'success': True})
```

**Risques att√©nu√©s** :

| Risque | Mitigation |
|--------|------------|
| **Brute-force** | Rate limiting (5 tentatives/minute) |
| **√ânum√©ration emails** | Message erreur g√©n√©rique |
| **Session hijacking** | HTTPS + HttpOnly + SameSite cookies |
| **Date naissance publique** | Session courte (2h), lecture seule |

---

## üõ°Ô∏è Autorisations (Permissions)

### Mod√®le RBAC (Role-Based Access Control)

**R√¥les** :

| R√¥le | Permissions | Cas d'usage |
|------|-------------|-------------|
| **ADMIN** | Tous droits | Administrateur syst√®me |
| **TEACHER** | CRUD examens, correction, publication | Enseignant |
| **STUDENT** | Lecture copies publi√©es (soi-m√™me uniquement) | √âl√®ve |

### Permissions Django REST Framework

```python
# core/permissions.py

from rest_framework.permissions import BasePermission

class IsAdmin(BasePermission):
    """Uniquement admins."""

    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.role == 'ADMIN'


class IsTeacher(BasePermission):
    """Admins + Teachers."""

    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.role in ['ADMIN', 'TEACHER']


class IsExamOwner(BasePermission):
    """Uniquement cr√©ateur examen."""

    def has_object_permission(self, request, view, obj):
        if not request.user or not request.user.is_authenticated:
            return False

        # Admin ‚Üí acc√®s total
        if request.user.role == 'ADMIN':
            return True

        # Teacher ‚Üí uniquement ses examens
        return obj.created_by == request.user


class IsCopyOwner(BasePermission):
    """Uniquement √©tudiant propri√©taire copie."""

    def has_object_permission(self, request, view, obj):
        student_id = request.session.get('student_id')

        if not student_id:
            return False

        # Copie appartient √† l'√©tudiant
        return obj.student_id == student_id
```

### Usage

```python
# exams/views.py

class ExamViewSet(viewsets.ModelViewSet):
    """ViewSet examens."""

    permission_classes = [IsAuthenticated, IsTeacher]

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated, IsExamOwner])
    def publish_results(self, request, pk=None):
        """Publier r√©sultats (uniquement cr√©ateur examen)."""
        # ...
```

---

## üîí Protection CSRF

### Configuration

```python
# backend/settings.py

# CSRF Settings
CSRF_COOKIE_NAME = 'korrigo_csrftoken'
CSRF_COOKIE_AGE = 31449600  # 1 an
CSRF_COOKIE_SECURE = True  # HTTPS uniquement
CSRF_COOKIE_HTTPONLY = False  # JavaScript doit lire le cookie
CSRF_COOKIE_SAMESITE = 'Strict'

# Trusted Origins
CSRF_TRUSTED_ORIGINS = [
    'https://korrigo.yourdomain.com',
    'https://www.korrigo.yourdomain.com'
]
```

### Frontend (Axios)

```typescript
// frontend/src/services/api.ts

import axios from 'axios'
import Cookies from 'js-cookie'

const api = axios.create({
  baseURL: '/api',
  withCredentials: true,  // Envoyer cookies
  headers: {
    'Content-Type': 'application/json'
  }
})

// Interceptor: Ajouter CSRF token √† chaque requ√™te
api.interceptors.request.use(config => {
  const csrfToken = Cookies.get('korrigo_csrftoken')

  if (csrfToken && ['post', 'put', 'patch', 'delete'].includes(config.method?.toLowerCase() || '')) {
    config.headers['X-CSRFToken'] = csrfToken
  }

  return config
})

export default api
```

---

## üö´ Protection Injection

### 1. SQL Injection

**Django ORM** : Protection automatique via param√©trage requ√™tes

**BON** (param√©tr√©) :

```python
# ‚úÖ S√©curis√©
Student.objects.filter(email=user_input)

# ‚úÖ S√©curis√©
Student.objects.raw('SELECT * FROM students WHERE email = %s', [user_input])
```

**MAUVAIS** (concat√©nation) :

```python
# ‚ùå Vuln√©rable SQL injection
Student.objects.raw(f'SELECT * FROM students WHERE email = "{user_input}"')

# ‚ùå Vuln√©rable
cursor.execute(f"SELECT * FROM students WHERE email = '{user_input}'")
```

### 2. XSS (Cross-Site Scripting)

**Frontend Vue.js** : √âchappement automatique

```vue
<!-- ‚úÖ √âchapp√© automatiquement -->
<p>{{ userInput }}</p>

<!-- ‚ùå Dangereux: HTML brut -->
<p v-html="userInput"></p>
```

**Sanitize HTML si n√©cessaire** :

```typescript
import DOMPurify from 'dompurify'

const cleanHTML = DOMPurify.sanitize(userInput)
```

**Backend Django** : √âchappement automatique dans templates

```django
<!-- ‚úÖ √âchapp√© -->
<p>{{ user_comment }}</p>

<!-- ‚ùå Dangereux -->
<p>{{ user_comment|safe }}</p>
```

### 3. Command Injection

**√âviter `os.system()`, `subprocess.shell=True`**

**BON** :

```python
# ‚úÖ S√©curis√© (liste arguments)
import subprocess

result = subprocess.run(
    ['pdfinfo', pdf_path],
    capture_output=True,
    text=True,
    check=True
)
```

**MAUVAIS** :

```python
# ‚ùå Vuln√©rable command injection
os.system(f'pdfinfo {pdf_path}')

# ‚ùå Vuln√©rable
subprocess.run(f'pdfinfo {pdf_path}', shell=True)
```

---

## üìä Rate Limiting

### Configuration django-ratelimit

**Installation** :

```bash
pip install django-ratelimit
```

**Zones** :

| Endpoint | Rate | Burst | Cl√© |
|----------|------|-------|-----|
| Login √©tudiant | 5/minute | - | IP |
| API g√©n√©rale | 100/minute | 20 | User |
| Upload PDF | 10/heure | 2 | User |

**Impl√©mentation** :

```python
# views.py

from django_ratelimit.decorators import ratelimit

@ratelimit(key='ip', rate='5/m', method='POST')
@api_view(['POST'])
def student_login(request):
    """Login avec rate limiting."""
    # Si rate limit d√©pass√©, django-ratelimit retourne 429
    # ...
```

**Custom decorator** :

```python
# core/decorators.py

from django_ratelimit.decorators import ratelimit
from functools import wraps

def api_rate_limit(rate='100/m'):
    """Rate limiting API avec cl√© user ou IP."""

    def decorator(func):
        @wraps(func)
        @ratelimit(key='user_or_ip', rate=rate, method=['GET', 'POST', 'PUT', 'PATCH', 'DELETE'])
        def wrapper(request, *args, **kwargs):
            return func(request, *args, **kwargs)
        return wrapper
    return decorator

# Usage
@api_rate_limit(rate='30/m')
@api_view(['GET'])
def some_api_view(request):
    # ...
```

---

## üîê S√©curit√© Headers HTTP

### Configuration Nginx

**Fichier** : `infra/nginx/nginx.conf`

```nginx
# Security Headers
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' wss:;" always;
add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
```

### Test Headers

```bash
# V√©rifier headers
curl -I https://korrigo.yourdomain.com

# Ou avec online tool
# https://securityheaders.com/?q=https://korrigo.yourdomain.com
```

**Score attendu** : A ou A+

---

## üìÅ S√©curit√© Uploads

### Validation Fichiers

```python
# exams/validators.py

from django.core.exceptions import ValidationError
import magic
import PyPDF2

def validate_pdf_file(file):
    """Valider fichier PDF upload√©."""

    # 1. V√©rifier extension
    if not file.name.lower().endswith('.pdf'):
        raise ValidationError('Invalid file type. Must be PDF.')

    # 2. V√©rifier taille (100 MB max)
    max_size = 100 * 1024 * 1024
    if file.size > max_size:
        raise ValidationError(f'File too large: {file.size} bytes (max: {max_size})')

    # 3. V√©rifier MIME type (magic bytes)
    file.seek(0)
    mime = magic.from_buffer(file.read(1024), mime=True)
    if mime != 'application/pdf':
        raise ValidationError(f'Invalid file type: {mime}. Expected application/pdf')

    # 4. V√©rifier int√©grit√© PDF
    file.seek(0)
    try:
        pdf_reader = PyPDF2.PdfReader(file)
        page_count = len(pdf_reader.pages)

        if page_count == 0:
            raise ValidationError('PDF has no pages')

    except Exception as e:
        raise ValidationError(f'Corrupted PDF: {str(e)}')

    # Reset file pointer
    file.seek(0)


def validate_csv_file(file):
    """Valider fichier CSV upload√©."""

    # Extension
    if not file.name.lower().endswith('.csv'):
        raise ValidationError('Invalid file type. Must be CSV.')

    # Taille (10 MB max)
    max_size = 10 * 1024 * 1024
    if file.size > max_size:
        raise ValidationError(f'File too large: {file.size} bytes (max: {max_size})')

    # MIME type
    file.seek(0)
    mime = magic.from_buffer(file.read(1024), mime=True)
    if mime not in ['text/plain', 'text/csv', 'application/csv']:
        raise ValidationError(f'Invalid file type: {mime}')

    file.seek(0)
```

### Stockage S√©curis√©

```python
# backend/settings.py

# Media Files
MEDIA_ROOT = '/app/media'
MEDIA_URL = '/media/'

# Prevent script execution in media folder
# ‚Üí G√©r√© par Nginx (voir infra/nginx/nginx.conf)
```

**Nginx configuration** :

```nginx
location /media/ {
    alias /app/media/;

    # Prevent script execution
    location ~* \.(html|htm|php|js)$ {
        deny all;
    }

    # Force download PDFs
    location ~* \.pdf$ {
        add_header Content-Disposition "attachment";
    }
}
```

---

## üîç Audit et Logging

### Configuration Logging

```python
# backend/settings.py

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/app/logs/django.log',
            'maxBytes': 10 * 1024 * 1024,  # 10 MB
            'backupCount': 5,
            'formatter': 'verbose',
        },
        'security': {
            'level': 'WARNING',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': '/app/logs/security.log',
            'maxBytes': 10 * 1024 * 1024,
            'backupCount': 10,
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'INFO',
            'propagate': False,
        },
        'django.security': {
            'handlers': ['security'],
            'level': 'WARNING',
            'propagate': False,
        },
    },
}
```

### Logging √âv√©nements Sensibles

```python
import logging

security_logger = logging.getLogger('django.security')

# Login √©chou√©
security_logger.warning(
    f"Failed login attempt: {email} from {request.META.get('REMOTE_ADDR')}"
)

# Tentative acc√®s non autoris√©
security_logger.warning(
    f"Unauthorized access attempt: user {request.user.id} to copy {copy_id}"
)

# Modification sensible
security_logger.info(
    f"Exam {exam.id} published by user {request.user.id}"
)
```

---

## üß™ Tests S√©curit√©

### Test Permissions

```python
# backend/core/tests/test_permissions.py

from django.test import TestCase
from rest_framework.test import APIClient
from django.contrib.auth import get_user_model

User = get_user_model()

class PermissionsTestCase(TestCase):
    def setUp(self):
        self.client = APIClient()

        # Cr√©er users
        self.admin = User.objects.create_user(username='admin', role='ADMIN', password='pass')
        self.teacher = User.objects.create_user(username='teacher', role='TEACHER', password='pass')
        self.other_teacher = User.objects.create_user(username='other', role='TEACHER', password='pass')

    def test_teacher_cannot_modify_other_exam(self):
        """Test qu'un teacher ne peut pas modifier examen d'un autre."""
        # Cr√©er examen par teacher
        self.client.force_authenticate(user=self.teacher)
        response = self.client.post('/api/exams/', {
            'title': 'Test Exam',
            'subject': 'Maths'
        })
        exam_id = response.data['id']

        # Tenter modification par other_teacher
        self.client.force_authenticate(user=self.other_teacher)
        response = self.client.patch(f'/api/exams/{exam_id}/', {
            'title': 'Hacked Title'
        })

        self.assertEqual(response.status_code, 403)

    def test_student_cannot_access_unpublished_copy(self):
        """Test qu'un √©tudiant ne peut pas voir copie non publi√©e."""
        # Cr√©er copie GRADED (non publi√©e)
        copy = Copy.objects.create(
            exam=self.exam,
            student=self.student,
            status='GRADED'
        )

        # Login √©tudiant
        session = self.client.session
        session['student_id'] = self.student.id
        session['is_student'] = True
        session.save()

        # Tenter acc√®s
        response = self.client.get(f'/api/students/copies/{copy.id}/')

        self.assertEqual(response.status_code, 403)
```

---

## üõ°Ô∏è Checklist S√©curit√© Production

### Pr√©-D√©ploiement

- [ ] **DEBUG=False** dans settings.py
- [ ] **SECRET_KEY** al√©atoire (50+ caract√®res)
- [ ] **ALLOWED_HOSTS** configur√©
- [ ] **SSL/HTTPS** activ√© (Let's Encrypt)
- [ ] **SECURE_SSL_REDIRECT=True**
- [ ] **SESSION_COOKIE_SECURE=True**
- [ ] **CSRF_COOKIE_SECURE=True**
- [ ] **Passwords hashed** avec Argon2
- [ ] **Rate limiting** activ√©
- [ ] **Security headers** Nginx
- [ ] **Firewall UFW** configur√©
- [ ] **Fail2Ban** install√©
- [ ] **Backups automatiques** configur√©s
- [ ] **Logs** configur√©s (rotation)
- [ ] **Sentry** configur√© (monitoring)

### Post-D√©ploiement

- [ ] **Scan s√©curit√©** (OWASP ZAP, Nikto)
- [ ] **Test penetration** endpoints sensibles
- [ ] **V√©rifier headers** (securityheaders.com)
- [ ] **Test SSL** (ssllabs.com)
- [ ] **Audit logs** r√©gulier
- [ ] **Mise √† jour d√©pendances** (Dependabot)

---

## üìä Monitoring S√©curit√©

### Sentry Integration

```python
# backend/settings.py

import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration

sentry_sdk.init(
    dsn="https://your-key@sentry.io/project-id",
    integrations=[DjangoIntegration()],
    traces_sample_rate=1.0,
    send_default_pii=False,  # ‚ùå Ne pas envoyer donn√©es perso
    environment="production"
)
```

### Alertes

**Configurer alertes Sentry** :
- Tentatives login √©chou√©es > 10/min
- Erreurs 500 > 5/min
- Erreurs permission 403 > 20/min
- Uploads PDF > 100 MB

---

## üìù Conclusion

La s√©curit√© Korrigo repose sur une approche multi-couches : authentification robuste, autorisations strictes, protection CSRF/XSS/SQL injection, rate limiting, headers HTTP, validation uploads, et monitoring continu.

**Points cl√©s** :
- Authentification session-based s√©curis√©e
- RBAC avec permissions granulaires
- Protection OWASP Top 10
- Rate limiting multi-zones
- Headers HTTP s√©curis√©s
- Validation stricte uploads
- Audit et logging complets
- Monitoring Sentry

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
