# 06.3 - D√©ploiement Production

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Objectif

Ce document d√©crit le processus de **d√©ploiement en production** du syst√®me Korrigo sur un serveur Linux avec Docker Compose.

---

## üìã Architecture Production

### Stack Technique

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ARCHITECTURE PRODUCTION                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                        Internet
                           ‚îÇ
                           ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Firewall   ‚îÇ
                    ‚îÇ  Port 80/443 ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ    Nginx     ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ Reverse Proxy + SSL
                    ‚îÇ   (Docker)   ‚îÇ      Rate Limiting
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ                ‚îÇ                ‚îÇ
          ‚ñº                ‚ñº                ‚ñº
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  Django  ‚îÇ     ‚îÇ  Celery  ‚îÇ    ‚îÇ  Redis   ‚îÇ
   ‚îÇ  (WSGI)  ‚îÇ     ‚îÇ  Worker  ‚îÇ    ‚îÇ  Cache   ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ PostgreSQL   ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ Persistent Data
          ‚îÇ   (Docker)   ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

         Volumes Docker:
         - postgres_data    : /var/lib/postgresql/data
         - media_files      : /app/media
         - static_files     : /app/staticfiles
```

---

## üñ•Ô∏è Pr√©requis Serveur

### Configuration Minimale

| Ressource | Production (50 users) | Production (200 users) |
|-----------|----------------------|------------------------|
| **CPU** | 4 cores | 8 cores |
| **RAM** | 8 GB | 16 GB |
| **Disque** | 100 GB SSD | 250 GB SSD |
| **Bande passante** | 100 Mbps | 500 Mbps |

### OS Recommand√©

- **Ubuntu Server 22.04 LTS** (recommand√©)
- Debian 11+
- CentOS 8+

---

## üîß Installation Initiale

### √âtape 1 : Pr√©paration Serveur

**Mise √† jour syst√®me** :

```bash
# Connexion SSH
ssh root@production-server

# Mise √† jour
apt update && apt upgrade -y

# Installer d√©pendances
apt install -y \
  curl \
  git \
  ufw \
  fail2ban \
  certbot \
  python3-certbot-nginx
```

### √âtape 2 : Installation Docker

```bash
# Installer Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh

# Installer Docker Compose
apt install -y docker-compose-plugin

# V√©rifier installation
docker --version
docker compose version

# D√©marrer Docker au boot
systemctl enable docker
systemctl start docker
```

### √âtape 3 : Configuration Firewall

```bash
# Configurer UFW
ufw default deny incoming
ufw default allow outgoing

# Autoriser SSH (modifier port si n√©cessaire)
ufw allow 22/tcp

# Autoriser HTTP/HTTPS
ufw allow 80/tcp
ufw allow 443/tcp

# Activer firewall
ufw enable

# V√©rifier
ufw status
```

**Output attendu** :
```
Status: active

To                         Action      From
--                         ------      ----
22/tcp                     ALLOW       Anywhere
80/tcp                     ALLOW       Anywhere
443/tcp                    ALLOW       Anywhere
```

---

## üì¶ D√©ploiement Application

### √âtape 1 : Cloner Repository

```bash
# Cr√©er user d√©di√© (recommand√©)
adduser korrigo
usermod -aG docker korrigo

# Changer vers user korrigo
su - korrigo

# Cloner projet
cd /home/korrigo
git clone https://github.com/your-org/korrigo.git
cd korrigo

# Checkout version stable
git checkout v2.0.0  # Tag production
```

### √âtape 2 : Configuration Environment

**Cr√©er fichier `.env.production`** :

```bash
# Backend Django
SECRET_KEY=your-super-secret-production-key-min-50-chars-random
DEBUG=False
ALLOWED_HOSTS=korrigo.yourdomain.com,www.korrigo.yourdomain.com
DJANGO_SETTINGS_MODULE=backend.settings
CORS_ALLOWED_ORIGINS=https://korrigo.yourdomain.com

# Database
DB_NAME=korrigo_prod
DB_USER=korrigo_user
DB_PASSWORD=strong-database-password-here
DB_HOST=db
DB_PORT=5432

# Redis
REDIS_URL=redis://redis:6379/0
CELERY_BROKER_URL=redis://redis:6379/0
CELERY_RESULT_BACKEND=redis://redis:6379/0

# Email (SMTP)
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=noreply@yourdomain.com
EMAIL_HOST_PASSWORD=your-smtp-password

# Security
SECURE_SSL_REDIRECT=True
SESSION_COOKIE_SECURE=True
CSRF_COOKIE_SECURE=True
SECURE_HSTS_SECONDS=31536000

# Sentry (optionnel)
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id

# AWS S3 (si stockage externe)
USE_S3=False
# AWS_ACCESS_KEY_ID=your-key
# AWS_SECRET_ACCESS_KEY=your-secret
# AWS_STORAGE_BUCKET_NAME=korrigo-media
```

**S√©curiser le fichier** :

```bash
chmod 600 .env.production
```

### √âtape 3 : Build et Lancement

**Build images Docker** :

```bash
# Build avec .env.production
docker compose -f docker-compose.prod.yml --env-file .env.production build

# V√©rifier images
docker images | grep korrigo
```

**Lancer services** :

```bash
# Lancer en d√©tach√©
docker compose -f docker-compose.prod.yml --env-file .env.production up -d

# V√©rifier statut
docker compose -f docker-compose.prod.yml ps
```

**Output attendu** :
```
NAME                COMMAND                  SERVICE    STATUS
korrigo-backend     "gunicorn ..."           backend    Up 30s
korrigo-celery      "celery -A backend..."   celery     Up 30s
korrigo-db          "docker-entrypoint..."   db         Up 30s
korrigo-nginx       "/docker-entrypoin..."   nginx      Up 30s
korrigo-redis       "docker-entrypoint..."   redis      Up 30s
```

### √âtape 4 : Migrations Base de Donn√©es

```bash
# Ex√©cuter migrations
docker compose -f docker-compose.prod.yml exec backend python manage.py migrate

# Cr√©er superuser
docker compose -f docker-compose.prod.yml exec backend python manage.py createsuperuser

# Collecter fichiers statiques
docker compose -f docker-compose.prod.yml exec backend python manage.py collectstatic --no-input
```

---

## üîê Configuration SSL (HTTPS)

### √âtape 1 : Obtenir Certificat Let's Encrypt

**M√©thode 1 : Certbot Standalone** (recommand√© avant lancement Nginx)

```bash
# Arr√™ter Nginx temporairement
docker compose -f docker-compose.prod.yml stop nginx

# Obtenir certificat
certbot certonly --standalone \
  -d korrigo.yourdomain.com \
  -d www.korrigo.yourdomain.com \
  --email admin@yourdomain.com \
  --agree-tos \
  --non-interactive

# Red√©marrer Nginx
docker compose -f docker-compose.prod.yml start nginx
```

**M√©thode 2 : Certbot Webroot** (si Nginx d√©j√† lanc√©)

```bash
# Cr√©er dossier webroot
mkdir -p /var/www/certbot

# Obtenir certificat
certbot certonly --webroot \
  -w /var/www/certbot \
  -d korrigo.yourdomain.com \
  -d www.korrigo.yourdomain.com \
  --email admin@yourdomain.com \
  --agree-tos
```

**Certificats g√©n√©r√©s dans** :
- `/etc/letsencrypt/live/korrigo.yourdomain.com/fullchain.pem`
- `/etc/letsencrypt/live/korrigo.yourdomain.com/privkey.pem`

### √âtape 2 : Configuration Nginx SSL

**Modifier `infra/nginx/nginx.conf`** :

```nginx
# Redirection HTTP ‚Üí HTTPS
server {
    listen 80;
    server_name korrigo.yourdomain.com www.korrigo.yourdomain.com;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://$server_name$request_uri;
    }
}

# HTTPS
server {
    listen 443 ssl http2;
    server_name korrigo.yourdomain.com www.korrigo.yourdomain.com;

    # SSL Certificates
    ssl_certificate /etc/letsencrypt/live/korrigo.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/korrigo.yourdomain.com/privkey.pem;

    # SSL Configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # Security Headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Client Max Body Size (pour uploads)
    client_max_body_size 100M;

    # Timeouts
    proxy_connect_timeout 60s;
    proxy_send_timeout 60s;
    proxy_read_timeout 60s;

    # Locations
    location /static/ {
        alias /app/staticfiles/;
        expires 30d;
        add_header Cache-Control "public, immutable";
    }

    location /media/ {
        alias /app/media/;
        expires 7d;
        add_header Cache-Control "public";
    }

    location / {
        proxy_pass http://backend:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

**Recharger Nginx** :

```bash
docker compose -f docker-compose.prod.yml exec nginx nginx -t
docker compose -f docker-compose.prod.yml restart nginx
```

### √âtape 3 : Auto-Renouvellement Certificat

**Ajouter cron job** :

```bash
# √âditer crontab
crontab -e

# Ajouter ligne (renouvellement tous les lundis 3h)
0 3 * * 1 certbot renew --quiet && docker compose -f /home/korrigo/korrigo/docker-compose.prod.yml restart nginx
```

---

## üîÑ Mise √† Jour Application

### Strat√©gie Zero-Downtime

**Script de d√©ploiement** : `deploy.sh`

```bash
#!/bin/bash
set -e

echo "üöÄ Starting deployment..."

# Variables
COMPOSE_FILE="docker-compose.prod.yml"
ENV_FILE=".env.production"

# 1. Pull latest code
echo "üì• Pulling latest code..."
git fetch --all --tags
git checkout $1  # Tag version (ex: v2.0.1)

# 2. Build new images
echo "üèóÔ∏è  Building Docker images..."
docker compose -f $COMPOSE_FILE --env-file $ENV_FILE build

# 3. Run migrations (avant switch)
echo "üóÑÔ∏è  Running migrations..."
docker compose -f $COMPOSE_FILE exec backend python manage.py migrate --no-input

# 4. Collect static files
echo "üì¶ Collecting static files..."
docker compose -f $COMPOSE_FILE exec backend python manage.py collectstatic --no-input

# 5. Restart services (rolling restart)
echo "üîÑ Restarting services..."

# Restart backend (Gunicorn reload graceful)
docker compose -f $COMPOSE_FILE exec backend kill -HUP 1

# Restart Celery workers
docker compose -f $COMPOSE_FILE restart celery

# Reload Nginx
docker compose -f $COMPOSE_FILE exec nginx nginx -s reload

echo "‚úÖ Deployment completed!"

# 6. Health check
echo "üè• Running health check..."
sleep 5
curl -f https://korrigo.yourdomain.com/api/health/ || {
    echo "‚ùå Health check failed!"
    exit 1
}

echo "‚úÖ Health check passed!"
```

**Usage** :

```bash
chmod +x deploy.sh
./deploy.sh v2.0.1
```

---

## üìä Monitoring et Logs

### Logs Docker

**Consulter logs en temps r√©el** :

```bash
# Tous les services
docker compose -f docker-compose.prod.yml logs -f

# Backend uniquement
docker compose -f docker-compose.prod.yml logs -f backend

# Celery uniquement
docker compose -f docker-compose.prod.yml logs -f celery

# Derni√®res 100 lignes
docker compose -f docker-compose.prod.yml logs --tail=100 backend
```

### Logs Django

**Fichiers logs** :
- `/app/logs/django.log` (dans container)
- `/app/logs/celery.log`

**Consulter depuis host** :

```bash
# Via volume mount
tail -f /home/korrigo/korrigo/logs/django.log
```

### Monitoring Ressources

**Monitoring CPU/RAM** :

```bash
# Stats temps r√©el
docker stats

# Utilisation disque
docker system df

# Logs containers
docker compose -f docker-compose.prod.yml ps
```

### Sentry (Monitoring Erreurs)

**Configuration dans `.env.production`** :

```bash
SENTRY_DSN=https://your-key@sentry.io/project-id
SENTRY_ENVIRONMENT=production
```

**Test Sentry** :

```bash
docker compose -f docker-compose.prod.yml exec backend python manage.py raven test
```

---

## üîí S√©curit√© Production

### 1. Fail2Ban (Protection Brute-Force)

**Installer Fail2Ban** :

```bash
apt install -y fail2ban

# Configuration SSH
cat > /etc/fail2ban/jail.local <<EOF
[sshd]
enabled = true
port = 22
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 3600
EOF

# Red√©marrer
systemctl restart fail2ban

# V√©rifier
fail2ban-client status sshd
```

### 2. Backup Automatique

**Script backup PostgreSQL** : `backup.sh`

```bash
#!/bin/bash
set -e

BACKUP_DIR="/home/korrigo/backups"
DATE=$(date +%Y%m%d_%H%M%S)
COMPOSE_FILE="/home/korrigo/korrigo/docker-compose.prod.yml"

# Cr√©er dossier backup
mkdir -p $BACKUP_DIR

# Backup base de donn√©es
echo "üì¶ Backing up database..."
docker compose -f $COMPOSE_FILE exec -T db pg_dump -U korrigo_user korrigo_prod | gzip > $BACKUP_DIR/db_backup_$DATE.sql.gz

# Backup media files
echo "üì¶ Backing up media files..."
tar -czf $BACKUP_DIR/media_backup_$DATE.tar.gz /home/korrigo/korrigo/media/

# Nettoyer backups > 30 jours
find $BACKUP_DIR -name "*.gz" -mtime +30 -delete

echo "‚úÖ Backup completed: $BACKUP_DIR/db_backup_$DATE.sql.gz"
```

**Ajouter cron job** :

```bash
# Backup quotidien 2h du matin
0 2 * * * /home/korrigo/backup.sh >> /home/korrigo/backup.log 2>&1
```

### 3. Restauration Backup

```bash
# Restaurer base de donn√©es
gunzip -c db_backup_20260203_020000.sql.gz | docker compose -f docker-compose.prod.yml exec -T db psql -U korrigo_user -d korrigo_prod

# Restaurer media files
tar -xzf media_backup_20260203_020000.tar.gz -C /home/korrigo/korrigo/
```

---

## üß™ Tests Post-D√©ploiement

### Checklist Production

```bash
# 1. V√©rifier services actifs
docker compose -f docker-compose.prod.yml ps

# 2. Tester API health
curl -f https://korrigo.yourdomain.com/api/health/

# 3. V√©rifier SSL
curl -I https://korrigo.yourdomain.com

# 4. Tester login admin
# Navigateur ‚Üí https://korrigo.yourdomain.com/admin/

# 5. V√©rifier Celery worker
docker compose -f docker-compose.prod.yml exec celery celery -A backend inspect active

# 6. Tester upload PDF (via interface)

# 7. V√©rifier logs
docker compose -f docker-compose.prod.yml logs --tail=50 backend | grep ERROR
```

**Tests Automatis√©s** :

```bash
# Tests backend
docker compose -f docker-compose.prod.yml exec backend pytest backend/ -v

# Tests E2E (depuis CI/CD)
cd frontend
npx playwright test --config playwright.prod.config.ts
```

---

## üìà Optimisation Performance

### 1. Caching Redis

**Activer cache Django** :

```python
# settings.py

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://redis:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}

SESSION_ENGINE = 'django.contrib.sessions.backends.cache'
SESSION_CACHE_ALIAS = 'default'
```

### 2. Gunicorn Workers

**Calcul optimal workers** :

```
workers = (2 √ó CPU_cores) + 1
```

**Exemple 4 cores** ‚Üí 9 workers

**Configuration** : `backend/gunicorn.conf.py`

```python
import multiprocessing

bind = "0.0.0.0:8000"
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = "sync"
worker_connections = 1000
timeout = 60
keepalive = 5

# Logging
accesslog = "/app/logs/gunicorn_access.log"
errorlog = "/app/logs/gunicorn_error.log"
loglevel = "info"

# Graceful restart
max_requests = 1000
max_requests_jitter = 50
```

### 3. PostgreSQL Tuning

**Configuration optimale** : `infra/postgres/postgresql.conf`

```ini
# Connexions
max_connections = 100

# Memory
shared_buffers = 2GB          # 25% RAM
effective_cache_size = 6GB    # 75% RAM
work_mem = 64MB
maintenance_work_mem = 512MB

# WAL
wal_buffers = 16MB
checkpoint_completion_target = 0.9

# Query Planner
random_page_cost = 1.1        # SSD
effective_io_concurrency = 200
```

**Recharger config** :

```bash
docker compose -f docker-compose.prod.yml restart db
```

---

## üö® Troubleshooting

### Probl√®me 1 : Service ne d√©marre pas

```bash
# V√©rifier logs
docker compose -f docker-compose.prod.yml logs backend

# V√©rifier variables env
docker compose -f docker-compose.prod.yml exec backend env | grep DB_

# Red√©marrer service
docker compose -f docker-compose.prod.yml restart backend
```

### Probl√®me 2 : 502 Bad Gateway

**Causes** :
- Backend Django pas d√©marr√©
- Timeout Gunicorn
- Erreur application

**Solution** :

```bash
# V√©rifier backend
docker compose -f docker-compose.prod.yml ps backend

# V√©rifier logs
docker compose -f docker-compose.prod.yml logs backend | tail -50

# Tester depuis container nginx
docker compose -f docker-compose.prod.yml exec nginx curl http://backend:8000/api/health/
```

### Probl√®me 3 : Database Connection Refused

```bash
# V√©rifier PostgreSQL
docker compose -f docker-compose.prod.yml ps db

# Tester connexion
docker compose -f docker-compose.prod.yml exec backend python manage.py dbshell

# V√©rifier credentials
docker compose -f docker-compose.prod.yml exec backend env | grep DB_
```

---

## üìù Conclusion

Le d√©ploiement production Korrigo utilise Docker Compose pour une orchestration simple et efficace. Le syst√®me supporte des configurations SSL, monitoring, backups automatiques, et mises √† jour zero-downtime.

**Points cl√©s** :
- Docker Compose production-ready
- SSL/HTTPS avec Let's Encrypt
- Backups automatiques quotidiens
- Monitoring Sentry + logs
- Fail2Ban protection
- Gunicorn + Nginx optimis√©s
- Mises √† jour zero-downtime

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
