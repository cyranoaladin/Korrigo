# 02.3 - Workflow de Traitement PDF Batch

**Projet** : Korrigo - SystÃ¨me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 FÃ©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## ğŸ¯ Objectif

Le traitement PDF batch permet de **convertir un PDF scannÃ© multi-pages** (contenant toutes les copies d'un examen) en **copies individuelles** associÃ©es Ã  chaque Ã©tudiant, avec gestion automatique des formats A3/A4, rotation, segmentation et OCR.

### Formats SupportÃ©s

1. **A4 standard** : 1 page = 1 face de copie (simple processing)
2. **A3 paysage** : 1 page A3 = 2 pages A4 cÃ´te Ã  cÃ´te (split + rotation requis)

---

## ğŸ“Š Vue d'Ensemble du Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Ã‰TAPE 1: UPLOAD PDF + CSV                           â”‚
â”‚  POST /api/exams/upload/                                       â”‚
â”‚  â€¢ exam_id, pdf_file, students_csv, batch_mode                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 2: LANCEMENT TÃ‚CHE CELERY ASYNCHRONE               â”‚
â”‚  processing.tasks.process_batch_pdf.delay()                    â”‚
â”‚  â€¢ Job ID retournÃ© au frontend                                 â”‚
â”‚  â€¢ Processing en arriÃ¨re-plan                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 3: DÃ‰TECTION FORMAT A3/A4                          â”‚
â”‚  _is_a3_format() â†’ Comparer dimensions                         â”‚
â”‚  â€¢ A3: 4960Ã—3508 px (300 DPI) ou ratio 1.41                   â”‚
â”‚  â€¢ A4: 3508Ã—2480 px (300 DPI) ou ratio 1.41                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                       â”‚
           â–¼                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ FORMAT A4   â”‚        â”‚  FORMAT A3      â”‚
    â”‚ â†’ Direct    â”‚        â”‚  â†’ Split        â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                        â”‚
           â”‚                        â–¼
           â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚               â”‚ Split A3 â†’ 2Ã—A4 â”‚
           â”‚               â”‚ + Rotation 90Â°  â”‚
           â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                        â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 4: SEGMENTATION PAR Ã‰TUDIANT                       â”‚
â”‚  _segment_by_student()                                         â”‚
â”‚  â€¢ DÃ©tecter headers (vision.py)                                â”‚
â”‚  â€¢ OCR multi-layer (tesseract + easyocr + paddleocr)          â”‚
â”‚  â€¢ Grouper pages par Ã©tudiant (multi-sheet fusion)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 5: CRÃ‰ATION COPIES DJANGO                          â”‚
â”‚  create_copies_from_batch()                                    â”‚
â”‚  â€¢ CrÃ©er Copy pour chaque Ã©tudiant                             â”‚
â”‚  â€¢ GÃ©nÃ©rer anonymous_id (A3-001, A3-002...)                   â”‚
â”‚  â€¢ Sauvegarder OCRResult (top-k candidates)                   â”‚
â”‚  â€¢ GÃ©nÃ©rer PDF individuel par copie                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¤ Ã‰tape 1 : Upload PDF et CSV

### API Endpoint

**POST /api/exams/upload/**

**Form Data** :
- `exam_id` : UUID de l'examen
- `pdf_file` : Fichier PDF (max 100 MB)
- `students_csv` : Fichier CSV (liste des Ã©tudiants)
- `batch_mode` : `"true"` ou `"false"` (activer traitement batch)

**Exemple RequÃªte** :

```bash
curl -X POST http://localhost:8088/api/exams/upload/ \
  -F "exam_id=uuid-exam-1" \
  -F "pdf_file=@eval_loi_binom_log.pdf" \
  -F "students_csv=@G3_EDS_MATHS.csv" \
  -F "batch_mode=true" \
  -H "Authorization: Bearer $TOKEN"
```

**RÃ©ponse** :

```json
{
  "job_id": "abc123-def456-ghi789",
  "status": "processing",
  "message": "Processing started",
  "estimated_time": "120s"
}
```

### Backend Implementation

**Fichier** : `backend/exams/views.py`

```python
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status
from processing.tasks import process_batch_pdf

class ExamViewSet(viewsets.ModelViewSet):

    @action(detail=False, methods=['post'])
    def upload(self, request):
        """
        Upload PDF et CSV, lancer traitement batch.

        Returns:
            {
                "job_id": "celery-task-id",
                "status": "processing"
            }
        """
        # 1. RÃ©cupÃ©rer donnÃ©es
        exam_id = request.data.get('exam_id')
        pdf_file = request.FILES.get('pdf_file')
        students_csv = request.FILES.get('students_csv')
        batch_mode = request.data.get('batch_mode', 'false') == 'true'

        # 2. Valider
        if not all([exam_id, pdf_file, students_csv]):
            return Response({
                'error': 'Missing required fields'
            }, status=status.HTTP_400_BAD_REQUEST)

        exam = Exam.objects.get(id=exam_id)

        # 3. Sauvegarder fichiers
        exam.pdf_source = pdf_file
        exam.students_csv = students_csv
        exam.save()

        # 4. Lancer traitement asynchrone (Celery)
        job = process_batch_pdf.delay(
            exam_id=str(exam.id),
            pdf_path=exam.pdf_source.path,
            csv_path=exam.students_csv.path,
            batch_mode=batch_mode
        )

        # 5. CrÃ©er BatchProcessingJob
        BatchProcessingJob.objects.create(
            exam=exam,
            celery_task_id=job.id,
            status='PENDING'
        )

        return Response({
            'job_id': job.id,
            'status': 'processing',
            'message': 'Processing started',
            'estimated_time': '120s'
        }, status=status.HTTP_202_ACCEPTED)
```

---

## âš™ï¸ Ã‰tape 2 : TÃ¢che Celery Asynchrone

### Celery Task

**Fichier** : `backend/processing/tasks.py`

```python
from celery import shared_task
from processing.services.batch_processor import BatchA3Processor

@shared_task(bind=True)
def process_batch_pdf(self, exam_id: str, pdf_path: str,
                     csv_path: str, batch_mode: bool):
    """
    TÃ¢che Celery pour traitement batch PDF.

    Args:
        self: Celery task instance (pour update_state)
        exam_id: UUID de l'examen
        pdf_path: Chemin absolu vers le PDF
        csv_path: Chemin absolu vers le CSV
        batch_mode: True = A3 split + OCR

    Progress updates:
        State: PROGRESS
        Meta: {'progress': 0-100, 'status': 'message'}
    """
    try:
        # 1. Progress: 0% - Initialisation
        self.update_state(
            state='PROGRESS',
            meta={'progress': 0, 'status': 'Initializing...'}
        )

        # 2. CrÃ©er processor
        processor = BatchA3Processor(
            task=self,  # Pour progress updates
            exam_id=exam_id
        )

        # 3. ExÃ©cuter traitement
        result = processor.process(pdf_path, csv_path)

        # 4. Progress: 100% - TerminÃ©
        self.update_state(
            state='SUCCESS',
            meta={
                'progress': 100,
                'status': 'Completed',
                'copies_created': result.copies_created,
                'auto_identified': result.auto_identified,
                'semi_auto': result.semi_auto,
                'manual': result.manual,
                'processing_time': result.processing_time
            }
        )

        return {
            'status': 'success',
            'result': result.to_dict()
        }

    except Exception as e:
        # Erreur
        self.update_state(
            state='FAILURE',
            meta={
                'progress': 0,
                'status': 'Failed',
                'error': str(e)
            }
        )
        raise
```

### Suivi de Progression (Frontend)

**Composant** : `frontend/src/components/ProcessingProgress.vue`

```vue
<template>
  <div class="processing-progress">
    <h3>Traitement en cours...</h3>

    <div class="progress-bar">
      <div class="fill" :style="{ width: `${progress}%` }"></div>
    </div>
    <p class="status">{{ statusMessage }}</p>

    <!-- RÃ©sultats (si terminÃ©) -->
    <div v-if="isComplete" class="results">
      <h4>Traitement TerminÃ© âœ“</h4>
      <ul>
        <li>Copies crÃ©Ã©es: {{ result.copies_created }}</li>
        <li>Auto-identifiÃ©es: {{ result.auto_identified }}</li>
        <li>Semi-auto: {{ result.semi_auto }}</li>
        <li>Manuel: {{ result.manual }}</li>
        <li>Temps: {{ result.processing_time }}s</li>
      </ul>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import api from '@/services/api'

const props = defineProps<{
  jobId: string
}>()

const emit = defineEmits<{
  (e: 'complete', result: any): void
}>()

const progress = ref(0)
const statusMessage = ref('Initialisation...')
const isComplete = ref(false)
const result = ref<any>(null)

let pollInterval: ReturnType<typeof setInterval> | null = null

onMounted(() => {
  // Poll status toutes les 2s
  pollInterval = setInterval(checkStatus, 2000)
})

onUnmounted(() => {
  if (pollInterval) clearInterval(pollInterval)
})

async function checkStatus() {
  try {
    const response = await api.get(`/api/processing/jobs/${props.jobId}/status/`)

    progress.value = response.data.progress
    statusMessage.value = response.data.status

    if (response.data.state === 'SUCCESS') {
      isComplete.value = true
      result.value = response.data.result
      if (pollInterval) clearInterval(pollInterval)
      emit('complete', result.value)
    } else if (response.data.state === 'FAILURE') {
      statusMessage.value = `Erreur: ${response.data.error}`
      if (pollInterval) clearInterval(pollInterval)
    }
  } catch (error) {
    console.error('Poll error:', error)
  }
}
</script>
```

---

## ğŸ” Ã‰tape 3 : DÃ©tection Format A3/A4

### Objectif

DÃ©tecter si le PDF contient des pages **A3** (qui nÃ©cessitent split + rotation) ou **A4** (direct).

### Dimensions Standard

| Format | Dimensions (mm) | Pixels @ 300 DPI | Ratio |
|--------|-----------------|------------------|-------|
| **A4 portrait** | 210Ã—297 | 2480Ã—3508 | 1.41 |
| **A4 paysage** | 297Ã—210 | 3508Ã—2480 | 0.71 |
| **A3 portrait** | 297Ã—420 | 3508Ã—4960 | 1.41 |
| **A3 paysage** | 420Ã—297 | 4960Ã—3508 | 0.71 |

### Implementation

**Fichier** : `backend/processing/services/batch_processor.py`

```python
import cv2
import numpy as np
from pdf2image import convert_from_path

class BatchA3Processor:
    """Processeur batch pour PDF A3/A4."""

    def __init__(self, task=None, exam_id=None):
        self.task = task  # Celery task (pour progress)
        self.exam_id = exam_id
        self.A3_MIN_WIDTH = 4000  # Seuil A3 (tolÃ©rance)

    def process(self, pdf_path: str, csv_path: str) -> ProcessingResult:
        """
        Pipeline complet de traitement batch.

        Returns:
            ProcessingResult(
                copies_created=28,
                auto_identified=20,
                semi_auto=5,
                manual=3,
                processing_time=120.5
            )
        """
        import time
        start_time = time.time()

        # 1. Charger PDF
        self._update_progress(5, 'Loading PDF...')
        pages = self._load_pdf(pdf_path)

        # 2. DÃ©tecter format
        self._update_progress(10, 'Detecting format...')
        is_a3 = self._is_a3_format(pages[0])

        # 3. Split si A3
        if is_a3:
            self._update_progress(15, 'Splitting A3 pages...')
            pages = self._split_a3_pages(pages)

        # 4. Charger CSV
        self._update_progress(30, 'Loading student list...')
        students = self._load_csv(csv_path)

        # 5. Segmentation par Ã©tudiant
        self._update_progress(40, 'Segmenting copies...')
        student_copies = self._segment_by_student(pages, students)

        # 6. CrÃ©er copies Django
        self._update_progress(80, 'Creating database entries...')
        result = self._create_copies_from_batch(student_copies)

        # 7. TerminÃ©
        processing_time = time.time() - start_time
        result.processing_time = processing_time

        self._update_progress(100, 'Completed')
        return result

    def _load_pdf(self, pdf_path: str) -> list[PageInfo]:
        """
        Charger PDF et convertir en images.

        Returns:
            Liste de PageInfo(page_num, image_array)
        """
        images = convert_from_path(
            pdf_path,
            dpi=300,  # 300 DPI pour OCR
            fmt='jpeg'
        )

        pages = []
        for idx, img in enumerate(images, 1):
            img_array = np.array(img)
            pages.append(PageInfo(page_num=idx, image=img_array))

        return pages

    def _is_a3_format(self, page: PageInfo) -> bool:
        """
        DÃ©tecter si la page est en format A3.

        Logique:
        - Comparer largeur: A3 â‰ˆ 4960 px @ 300 DPI
        - TolÃ©rance: Â±10%
        """
        h, w = page.image.shape[:2]

        # A3 paysage: largeur > 4000 px
        if w > self.A3_MIN_WIDTH:
            logger.info(f"Detected A3 format: {w}Ã—{h}")
            return True

        logger.info(f"Detected A4 format: {w}Ã—{h}")
        return False

    def _update_progress(self, progress: int, status: str):
        """Mettre Ã  jour progression Celery."""
        if self.task:
            self.task.update_state(
                state='PROGRESS',
                meta={'progress': progress, 'status': status}
            )
```

---

## âœ‚ï¸ Ã‰tape 4 : Split A3 â†’ 2Ã—A4 + Rotation

### Objectif

Convertir une page **A3 paysage** en **2 pages A4 portrait** :
1. **Split vertical** au milieu
2. **Rotation 90Â° clockwise** de chaque moitiÃ©

### Logique Visuelle

```
A3 PAYSAGE (4960Ã—3508 px)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                â”‚
â”‚         LEFT HALF              â”‚  RIGHT HALF
â”‚      (2480Ã—3508)               â”‚  (2480Ã—3508)
â”‚                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“ SPLIT                  â†“ SPLIT
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚         â”‚              â”‚         â”‚
     â”‚  LEFT   â”‚              â”‚  RIGHT  â”‚
     â”‚         â”‚              â”‚         â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“ ROTATE 90Â° CW      â†“ ROTATE 90Â° CW
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚         â”‚              â”‚         â”‚
     â”‚  A4 #1  â”‚              â”‚  A4 #2  â”‚
     â”‚         â”‚              â”‚         â”‚
     â”‚         â”‚              â”‚         â”‚
     â”‚         â”‚              â”‚         â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    (3508Ã—2480)              (3508Ã—2480)
    A4 PORTRAIT              A4 PORTRAIT
```

### Implementation

```python
def _split_a3_pages(self, pages: list[PageInfo]) -> list[PageInfo]:
    """
    Split A3 â†’ 2Ã—A4 avec rotation.

    Algorithme:
    1. Split vertical au milieu
    2. Rotation 90Â° CW de chaque moitiÃ©
    3. GÃ©nÃ©rer 2 nouvelles pages A4
    """
    a4_pages = []

    for page in pages:
        h, w = page.image.shape[:2]

        # 1. Split vertical au milieu
        mid = w // 2
        left_half = page.image[:, :mid]      # Gauche: 0 â†’ mid
        right_half = page.image[:, mid:]     # Droite: mid â†’ w

        # 2. Rotation 90Â° CW
        left_rotated = cv2.rotate(left_half, cv2.ROTATE_90_CLOCKWISE)
        right_rotated = cv2.rotate(right_half, cv2.ROTATE_90_CLOCKWISE)

        # 3. CrÃ©er nouvelles pages A4
        a4_pages.append(PageInfo(
            page_num=page.page_num * 2 - 1,  # Page 1 â†’ 1, Page 2 â†’ 3
            image=left_rotated,
            source_a3_page=page.page_num,
            is_left_half=True
        ))

        a4_pages.append(PageInfo(
            page_num=page.page_num * 2,      # Page 1 â†’ 2, Page 2 â†’ 4
            image=right_rotated,
            source_a3_page=page.page_num,
            is_left_half=False
        ))

    logger.info(f"Split {len(pages)} A3 pages â†’ {len(a4_pages)} A4 pages")
    return a4_pages
```

### VÃ©rification QualitÃ©

```python
def _verify_split_quality(self, a4_page: PageInfo) -> bool:
    """
    VÃ©rifier que le split A3â†’A4 a bien fonctionnÃ©.

    CritÃ¨res:
    - Dimensions A4 correctes (Â±5%)
    - Rotation correcte (ratio > 1)
    - Contenu visible (pas blanc)
    """
    h, w = a4_page.image.shape[:2]

    # VÃ©rifier dimensions A4 (3508Ã—2480 @ 300 DPI)
    expected_w = 2480
    expected_h = 3508

    if not (0.95 * expected_w < w < 1.05 * expected_w):
        logger.warning(f"Invalid A4 width: {w} (expected ~{expected_w})")
        return False

    if not (0.95 * expected_h < h < 1.05 * expected_h):
        logger.warning(f"Invalid A4 height: {h} (expected ~{expected_h})")
        return False

    # VÃ©rifier que pas blanc (image vide)
    gray = cv2.cvtColor(a4_page.image, cv2.COLOR_BGR2GRAY)
    mean_intensity = np.mean(gray)

    if mean_intensity > 250:  # Presque blanc
        logger.warning(f"Page appears blank (mean: {mean_intensity})")
        return False

    return True
```

---

## ğŸ“‘ Ã‰tape 5 : Segmentation par Ã‰tudiant

### Objectif

Grouper les pages par **Ã©tudiant** en dÃ©tectant les en-tÃªtes et en fusionnant les pages appartenant Ã  la mÃªme copie (multi-sheet fusion).

### Logique Multi-Sheet

Un Ã©tudiant peut avoir **plusieurs feuilles** (double-sided A4 â†’ 4 pages) :

```
Copie Ã‰tudiant 1:
  Page 1: Header dÃ©tectÃ© â†’ Nouvelle copie
  Page 2: Pas de header â†’ Continuation
  Page 3: Header Ã©tudiant 1 (2Ã¨me feuille) â†’ Fusion avec copie existante
  Page 4: Pas de header â†’ Continuation

Copie Ã‰tudiant 2:
  Page 5: Header dÃ©tectÃ© â†’ Nouvelle copie
  Page 6: Pas de header â†’ Continuation
```

### Implementation

```python
def _segment_by_student(
    self,
    pages: list[PageInfo],
    students: list[Student]
) -> list[StudentCopy]:
    """
    Segmenter pages par Ã©tudiant avec multi-sheet fusion.

    Algorithme:
    1. Pour chaque page:
       a. DÃ©tecter header
       b. Si header trouvÃ© â†’ OCR + match Ã©tudiant
       c. Si mÃªme Ã©tudiant que copie prÃ©cÃ©dente â†’ Fusionner
       d. Sinon â†’ Nouvelle copie
    2. Grouper pages par Ã©tudiant

    Returns:
        Liste de StudentCopy(student_match, pages, header_crops, ocr_result)
    """
    from processing.services.vision import HeaderDetector
    from processing.services.ocr_engine import MultiLayerOCR

    detector = HeaderDetector()
    ocr_engine = MultiLayerOCR()

    student_copies = []
    current_copy = None

    for idx, page in enumerate(pages):
        self._update_progress(
            40 + int((idx / len(pages)) * 40),
            f'Processing page {idx+1}/{len(pages)}...'
        )

        # 1. DÃ©tecter header
        header_region = detector.detect_header(page.image)

        if header_region is not None:
            # Header dÃ©tectÃ© â†’ OCR
            ocr_result = ocr_engine.extract_text_with_candidates(
                header_region,
                students
            )

            # Matcher Ã©tudiant (top-1 candidat)
            if ocr_result.top_candidates:
                student_match = ocr_result.top_candidates[0]
            else:
                student_match = None

            # VÃ©rifier si mÃªme Ã©tudiant que copie prÃ©cÃ©dente (multi-sheet fusion)
            if (current_copy is not None and
                student_match and
                current_copy.student_match and
                student_match.student_id == current_copy.student_match.student_id):

                # FUSION: Ajouter pages Ã  copie existante
                logger.info(f"Multi-sheet fusion: {student_match.student_id}")
                current_copy.pages.append(page)
                current_copy.header_crops.append(header_region)

            else:
                # NOUVELLE COPIE
                if current_copy is not None:
                    student_copies.append(current_copy)

                current_copy = StudentCopy(
                    student_match=student_match,
                    pages=[page],
                    header_crops=[header_region],
                    ocr_result=ocr_result
                )

        else:
            # Pas de header â†’ Continuation de la copie prÃ©cÃ©dente
            if current_copy is not None:
                current_copy.pages.append(page)
            else:
                # Copie orpheline (pas de header au dÃ©but)
                logger.warning(f"Orphan page {idx+1} (no header)")
                current_copy = StudentCopy(
                    student_match=None,
                    pages=[page],
                    header_crops=[],
                    ocr_result=None
                )

    # Ajouter derniÃ¨re copie
    if current_copy is not None:
        student_copies.append(current_copy)

    logger.info(f"Segmented into {len(student_copies)} copies")
    return student_copies
```

---

## ğŸ’¾ Ã‰tape 6 : CrÃ©ation Copies Django

### Objectif

CrÃ©er les objets Django **Copy**, **Page**, **OCRResult** Ã  partir des donnÃ©es segmentÃ©es.

### Implementation

```python
from exams.models import Exam, Copy, Page
from students.models import Student
from identification.models import OCRResult

def _create_copies_from_batch(
    self,
    student_copies: list[StudentCopy]
) -> ProcessingResult:
    """
    CrÃ©er copies Django depuis rÃ©sultats batch.

    Returns:
        ProcessingResult(
            copies_created=28,
            auto_identified=20,
            semi_auto=5,
            manual=3
        )
    """
    exam = Exam.objects.get(id=self.exam_id)

    copies_created = 0
    auto_identified = 0
    semi_auto = 0
    manual = 0

    for idx, student_copy in enumerate(student_copies):
        # 1. GÃ©nÃ©rer anonymous_id
        anonymous_id = f"A3-{idx+1:03d}"  # A3-001, A3-002, etc.

        # 2. DÃ©terminer student_id (si AUTO)
        student_id = None
        is_identified = False
        status = Copy.Status.PENDING

        if student_copy.ocr_result:
            ocr_mode = student_copy.ocr_result.ocr_mode

            if ocr_mode == 'AUTO':
                # Assignation automatique
                student_id = student_copy.student_match.student_id
                is_identified = True
                status = Copy.Status.READY
                auto_identified += 1

            elif ocr_mode == 'SEMI_AUTO':
                # En attente de sÃ©lection enseignant
                semi_auto += 1

            else:  # MANUAL
                manual += 1

        else:
            manual += 1

        # 3. CrÃ©er Copy
        copy = Copy.objects.create(
            exam=exam,
            student_id=student_id,
            anonymous_id=anonymous_id,
            is_identified=is_identified,
            status=status,
            corrector=None  # Sera assignÃ© plus tard
        )

        # 4. CrÃ©er Pages
        for page_idx, page_info in enumerate(student_copy.pages, 1):
            # Sauvegarder image page
            page_image_path = self._save_page_image(copy, page_idx, page_info.image)

            Page.objects.create(
                copy=copy,
                page_number=page_idx,
                image_file=page_image_path,
                width=page_info.image.shape[1],
                height=page_info.image.shape[0],
                dpi=300
            )

        # 5. CrÃ©er OCRResult
        if student_copy.ocr_result:
            OCRResult.objects.create(
                copy=copy,
                detected_text=student_copy.ocr_result.top_candidates[0].sources[0]['text']
                              if student_copy.ocr_result.top_candidates else '',
                confidence=student_copy.ocr_result.top_candidates[0].confidence
                           if student_copy.ocr_result.top_candidates else 0.0,
                top_candidates=[c.to_dict() for c in student_copy.ocr_result.top_candidates],
                ocr_mode=student_copy.ocr_result.ocr_mode
            )

        # 6. GÃ©nÃ©rer PDF individuel
        pdf_path = self._generate_copy_pdf(copy, student_copy.pages)
        copy.pdf_file = pdf_path
        copy.save()

        copies_created += 1

    return ProcessingResult(
        copies_created=copies_created,
        auto_identified=auto_identified,
        semi_auto=semi_auto,
        manual=manual
    )

def _save_page_image(self, copy: Copy, page_num: int, image: np.ndarray) -> str:
    """
    Sauvegarder image page sur disque.

    Returns:
        Chemin relatif (pour FileField)
    """
    import cv2
    from django.conf import settings

    # Chemin: media/copies/pages/{copy_id}/page_{num}.jpg
    output_dir = settings.MEDIA_ROOT / 'copies' / 'pages' / str(copy.id)
    output_dir.mkdir(parents=True, exist_ok=True)

    output_path = output_dir / f'page_{page_num}.jpg'
    cv2.imwrite(str(output_path), image)

    # Retourner chemin relatif
    return f'copies/pages/{copy.id}/page_{page_num}.jpg'

def _generate_copy_pdf(self, copy: Copy, pages: list[PageInfo]) -> str:
    """
    GÃ©nÃ©rer PDF individuel depuis pages.

    Returns:
        Chemin relatif (pour FileField)
    """
    from PIL import Image
    from django.conf import settings

    # Chemin: media/copies/pdfs/{copy_id}.pdf
    output_dir = settings.MEDIA_ROOT / 'copies' / 'pdfs'
    output_dir.mkdir(parents=True, exist_ok=True)

    output_path = output_dir / f'{copy.id}.pdf'

    # Convertir numpy arrays â†’ PIL Images
    pil_images = [Image.fromarray(page.image) for page in pages]

    # Sauvegarder PDF
    pil_images[0].save(
        str(output_path),
        save_all=True,
        append_images=pil_images[1:],
        format='PDF'
    )

    return f'copies/pdfs/{copy.id}.pdf'
```

---

## ğŸ“Š RÃ©sultats et MÃ©triques

### Exemple de RÃ©sultat

Pour le fichier `eval_loi_binom_log.pdf` (88 pages A3, 28 Ã©tudiants) :

```json
{
  "copies_created": 28,
  "auto_identified": 20,      // 71% AUTO
  "semi_auto": 5,             // 18% SEMI-AUTO
  "manual": 3,                // 11% MANUAL
  "processing_time": 125.3,   // ~2 minutes
  "pages_processed": 176,     // 88 A3 â†’ 176 A4
  "avg_pages_per_copy": 6.3
}
```

### Performance

| OpÃ©ration | Temps Moyen |
|-----------|-------------|
| PDF loading | 5s |
| Format detection | 0.1s |
| A3 split (88 pages) | 8s |
| OCR multi-layer (28 headers) | 120s (~4.3s/header) |
| Segmentation | 5s |
| DB crÃ©ation | 2s |
| **Total** | **~140s** |

---

## ğŸ“ Conclusion

Le workflow de traitement PDF batch offre un pipeline robuste pour convertir des scans A3 multi-Ã©tudiants en copies individuelles avec identification OCR.

**Points clÃ©s** :
- Support A3 et A4
- Split + rotation automatiques
- Multi-sheet fusion (un Ã©tudiant = plusieurs feuilles)
- OCR multi-layer avec consensus voting
- Traitement asynchrone (Celery)
- Progress tracking en temps rÃ©el

---

**Document rÃ©digÃ© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 FÃ©vrier 2026
