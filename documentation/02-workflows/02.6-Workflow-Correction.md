# 02.6 - Workflow de Correction des Copies

**Projet** : Korrigo - SystÃ¨me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 FÃ©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## ğŸ¯ Objectif

Le workflow de correction permet aux **enseignants** de corriger numÃ©riquement les copies d'examens en attribuant des notes par question, en ajoutant des annotations PDF (surlignages, commentaires) et en sauvegardant automatiquement leur progression.

### Acteurs

- **Enseignant correcteur** : Corrige les copies qui lui sont assignÃ©es
- **Administrateur** : Supervise, peut corriger toutes les copies

---

## ğŸ“Š Vue d'Ensemble du Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 1: LISTE DES COPIES Ã€ CORRIGER                    â”‚
â”‚  GET /api/grading/copies/ â†’ Filtrer par correcteur            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 2: OUVRIR UNE COPIE                                â”‚
â”‚  GET /api/grading/copies/{id}/ â†’ Charger copie + exam         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 3: VISUALISATION PDF + ANNOTATION                  â”‚
â”‚  â€¢ PDF.js viewer avec zoom, navigation pages                   â”‚
â”‚  â€¢ Outils annotation: surlignage, commentaires, tampons       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 4: ATTRIBUTION DES NOTES                           â”‚
â”‚  â€¢ Sidebar avec structure de notation (barÃ¨me)                 â”‚
â”‚  â€¢ Input note par sous-question                                â”‚
â”‚  â€¢ Commentaires par question                                   â”‚
â”‚  â€¢ Calcul automatique du total                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 5: SAUVEGARDE AUTOMATIQUE (DRAFT)                  â”‚
â”‚  PATCH /api/grading/copies/{id}/                               â”‚
â”‚  â€¢ Toutes les 2s aprÃ¨s modification                            â”‚
â”‚  â€¢ Status: IN_PROGRESS                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Ã‰TAPE 6: FINALISATION ET VERROUILLAGE                    â”‚
â”‚  POST /api/grading/copies/{id}/lock/                           â”‚
â”‚  â€¢ VÃ©rifier que toutes questions sont notÃ©es                   â”‚
â”‚  â€¢ Status: COMPLETED, is_locked=True                           â”‚
â”‚  â€¢ Copie non modifiable                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“‹ Ã‰tape 1 : Liste des Copies Ã  Corriger

### Objectif

L'enseignant accÃ¨de Ã  la **liste des copies** qui lui sont assignÃ©es pour correction.

### API Endpoint

**GET /api/grading/copies/**

**Query Parameters** :
- `exam_id` (optionnel) : Filtrer par examen
- `status` (optionnel) : READY | IN_PROGRESS | COMPLETED

**RÃ©ponse** :

```json
[
  {
    "id": "uuid-copy-1",
    "exam": {
      "id": "uuid-exam-1",
      "name": "Bac Blanc MathÃ©matiques 2026",
      "date": "2026-02-03"
    },
    "anonymous_id": "A3-001",
    "student": null,  // Anonyme durant correction
    "status": "READY",
    "corrector": {
      "id": 2,
      "username": "test_prof"
    },
    "total_score": null,
    "is_locked": false,
    "created_at": "2026-02-03T10:30:00Z"
  },
  {
    "id": "uuid-copy-2",
    "exam": {...},
    "anonymous_id": "A3-002",
    "status": "IN_PROGRESS",
    "total_score": 12.5,
    "is_locked": false,
    "created_at": "2026-02-03T10:31:00Z"
  }
]
```

### Backend (Django)

**Fichier** : `backend/grading/views.py`

```python
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from exams.models import Copy
from grading.serializers import CopySerializer

class CopyViewSet(viewsets.ModelViewSet):
    """ViewSet pour la correction des copies."""

    serializer_class = CopySerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        """
        Filtrer les copies selon le rÃ´le.

        - Admin: toutes les copies
        - Teacher: copies assignÃ©es uniquement
        """
        user = self.request.user

        if user.is_superuser:
            # Admin voit tout
            queryset = Copy.objects.all()
        else:
            # Enseignant voit ses copies assignÃ©es
            queryset = Copy.objects.filter(corrector=user)

        # Filtres optionnels
        exam_id = self.request.query_params.get('exam_id')
        if exam_id:
            queryset = queryset.filter(exam_id=exam_id)

        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)

        # Ordonner par exam + anonymous_id
        return queryset.select_related('exam', 'corrector').order_by('exam__date', 'anonymous_id')
```

### Frontend (Vue.js)

**Composant** : `frontend/src/views/teacher/DashboardTeacher.vue`

```vue
<template>
  <div class="teacher-dashboard">
    <h1>Mes Copies Ã  Corriger</h1>

    <!-- Filtres -->
    <div class="filters">
      <select v-model="selectedExam" @change="loadCopies">
        <option value="">Tous les examens</option>
        <option v-for="exam in exams" :key="exam.id" :value="exam.id">
          {{ exam.name }}
        </option>
      </select>

      <select v-model="statusFilter" @change="loadCopies">
        <option value="">Tous les statuts</option>
        <option value="READY">Ã€ corriger</option>
        <option value="IN_PROGRESS">En cours</option>
        <option value="COMPLETED">TerminÃ©es</option>
      </select>
    </div>

    <!-- Statistiques -->
    <div class="stats-grid">
      <StatCard title="Ã€ corriger" :value="stats.ready" color="orange" />
      <StatCard title="En cours" :value="stats.in_progress" color="blue" />
      <StatCard title="TerminÃ©es" :value="stats.completed" color="green" />
    </div>

    <!-- Liste des copies -->
    <div class="copies-list">
      <CopyCard
        v-for="copy in copies"
        :key="copy.id"
        :copy="copy"
        @click="openCopy(copy.id)"
      />
    </div>

    <!-- Empty state -->
    <div v-if="copies.length === 0" class="empty-state">
      <p>Aucune copie Ã  corriger</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed } from 'vue'
import { useRouter } from 'vue-router'
import api from '@/services/api'
import type { Copy, Exam } from '@/types'

const router = useRouter()

const copies = ref<Copy[]>([])
const exams = ref<Exam[]>([])
const selectedExam = ref('')
const statusFilter = ref('')

const stats = computed(() => ({
  ready: copies.value.filter(c => c.status === 'READY').length,
  in_progress: copies.value.filter(c => c.status === 'IN_PROGRESS').length,
  completed: copies.value.filter(c => c.status === 'COMPLETED').length
}))

onMounted(async () => {
  await loadExams()
  await loadCopies()
})

async function loadExams() {
  const response = await api.get('/api/exams/')
  exams.value = response.data
}

async function loadCopies() {
  const params: any = {}
  if (selectedExam.value) params.exam_id = selectedExam.value
  if (statusFilter.value) params.status = statusFilter.value

  const response = await api.get('/api/grading/copies/', { params })
  copies.value = response.data
}

function openCopy(copyId: string) {
  router.push(`/teacher/copies/${copyId}`)
}
</script>
```

---

## ğŸ“„ Ã‰tape 2 : Charger une Copie

### API Endpoint

**GET /api/grading/copies/{id}/**

**RÃ©ponse** :

```json
{
  "id": "uuid-copy-1",
  "exam": {
    "id": "uuid-exam-1",
    "name": "Bac Blanc MathÃ©matiques 2026",
    "grading_structure": [
      {
        "question": "1",
        "title": "Ã‰tude de fonction",
        "max_score": 5.0,
        "sub_questions": [
          {
            "id": "1.a",
            "title": "Limites",
            "max_score": 1.5
          },
          {
            "id": "1.b",
            "title": "DÃ©rivÃ©e",
            "max_score": 2.0
          },
          {
            "id": "1.c",
            "title": "Tableau de variations",
            "max_score": 1.5
          }
        ]
      },
      {
        "question": "2",
        "title": "ProbabilitÃ©s",
        "max_score": 4.0,
        "sub_questions": [...]
      }
    ]
  },
  "anonymous_id": "A3-001",
  "status": "READY",
  "pdf_url": "http://localhost:8088/media/copies/pdfs/copy_uuid.pdf",
  "pages": [
    {
      "id": "uuid-page-1",
      "page_number": 1,
      "image_url": "http://localhost:8088/media/copies/pages/page_1.jpg"
    },
    {
      "id": "uuid-page-2",
      "page_number": 2,
      "image_url": "http://localhost:8088/media/copies/pages/page_2.jpg"
    }
  ],
  "grades": [
    {
      "question_id": "1.a",
      "score": 1.5,
      "max_score": 1.5,
      "comment": "Parfait"
    }
  ],
  "annotations": [
    {
      "id": "uuid-annot-1",
      "page_id": "uuid-page-1",
      "type": "HIGHLIGHT",
      "coordinates": {"x": 100, "y": 200, "width": 150, "height": 20},
      "color": "#FFFF00"
    }
  ],
  "total_score": 1.5,
  "is_locked": false
}
```

### Backend

```python
class CopyViewSet(viewsets.ModelViewSet):

    def retrieve(self, request, pk=None):
        """RÃ©cupÃ©rer une copie avec toutes ses donnÃ©es."""

        copy = self.get_object()

        # VÃ©rifier permissions
        if not request.user.is_superuser and copy.corrector != request.user:
            return Response({'error': 'Not your copy'}, status=403)

        serializer = CopyDetailSerializer(copy)
        return Response(serializer.data)
```

---

## ğŸ–Šï¸ Ã‰tape 3 : Visualisation PDF et Annotations

### PDF.js Viewer

**Composant** : `frontend/src/components/shared/PDFViewer.vue`

```vue
<template>
  <div class="pdf-viewer">
    <!-- Toolbar -->
    <div class="toolbar">
      <button @click="zoomIn">ğŸ”+</button>
      <button @click="zoomOut">ğŸ”-</button>
      <button @click="fitWidth">Ajuster largeur</button>

      <div class="page-nav">
        <button @click="previousPage" :disabled="currentPage === 1">â—€</button>
        <span>{{ currentPage }} / {{ totalPages }}</span>
        <button @click="nextPage" :disabled="currentPage === totalPages">â–¶</button>
      </div>

      <!-- Outils annotation -->
      <div class="annotation-tools">
        <button
          :class="{ active: annotationMode === 'highlight' }"
          @click="setAnnotationMode('highlight')"
        >
          ğŸ–ï¸ Surligner
        </button>
        <button
          :class="{ active: annotationMode === 'comment' }"
          @click="setAnnotationMode('comment')"
        >
          ğŸ’¬ Commenter
        </button>
        <button
          :class="{ active: annotationMode === 'stamp' }"
          @click="setAnnotationMode('stamp')"
        >
          âœ“ Tampon
        </button>

        <input
          v-if="annotationMode === 'highlight'"
          type="color"
          v-model="highlightColor"
        />
      </div>
    </div>

    <!-- Canvas PDF -->
    <div class="canvas-container" ref="containerRef">
      <canvas
        ref="canvasRef"
        @mousedown="startAnnotation"
        @mousemove="drawAnnotation"
        @mouseup="endAnnotation"
      ></canvas>

      <!-- Overlay annotations existantes -->
      <div class="annotations-overlay">
        <div
          v-for="annotation in pageAnnotations"
          :key="annotation.id"
          class="annotation"
          :class="`annotation-${annotation.type.toLowerCase()}`"
          :style="{
            left: `${annotation.coordinates.x}px`,
            top: `${annotation.coordinates.y}px`,
            width: `${annotation.coordinates.width}px`,
            height: `${annotation.coordinates.height}px`,
            backgroundColor: annotation.color,
          }"
        >
          <span v-if="annotation.type === 'COMMENT'" class="comment-text">
            {{ annotation.content }}
          </span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import * as pdfjsLib from 'pdfjs-dist'
import type { Annotation } from '@/types'

const props = defineProps<{
  src: string  // URL du PDF
  annotations: Annotation[]
}>()

const emit = defineEmits<{
  (e: 'annotate', annotation: Omit<Annotation, 'id'>): void
}>()

// PDF.js setup
const canvasRef = ref<HTMLCanvasElement | null>(null)
const containerRef = ref<HTMLDivElement | null>(null)

let pdfDoc: any = null
const currentPage = ref(1)
const totalPages = ref(0)
const scale = ref(1.5)

// Annotation state
const annotationMode = ref<'highlight' | 'comment' | 'stamp' | null>(null)
const highlightColor = ref('#FFFF00')
const isDrawing = ref(false)
const startCoords = ref({ x: 0, y: 0 })

const pageAnnotations = computed(() => {
  return props.annotations.filter(a => a.page_number === currentPage.value)
})

onMounted(async () => {
  await loadPDF()
})

async function loadPDF() {
  pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdf.worker.js'

  const loadingTask = pdfjsLib.getDocument(props.src)
  pdfDoc = await loadingTask.promise

  totalPages.value = pdfDoc.numPages
  await renderPage(currentPage.value)
}

async function renderPage(pageNum: number) {
  const page = await pdfDoc.getPage(pageNum)

  const viewport = page.getViewport({ scale: scale.value })
  const canvas = canvasRef.value!
  const context = canvas.getContext('2d')!

  canvas.height = viewport.height
  canvas.width = viewport.width

  const renderContext = {
    canvasContext: context,
    viewport: viewport,
  }

  await page.render(renderContext).promise
}

function zoomIn() {
  scale.value += 0.25
  renderPage(currentPage.value)
}

function zoomOut() {
  if (scale.value > 0.5) {
    scale.value -= 0.25
    renderPage(currentPage.value)
  }
}

function fitWidth() {
  const containerWidth = containerRef.value!.clientWidth
  const canvas = canvasRef.value!
  scale.value = containerWidth / canvas.width
  renderPage(currentPage.value)
}

function previousPage() {
  if (currentPage.value > 1) {
    currentPage.value--
    renderPage(currentPage.value)
  }
}

function nextPage() {
  if (currentPage.value < totalPages.value) {
    currentPage.value++
    renderPage(currentPage.value)
  }
}

function setAnnotationMode(mode: 'highlight' | 'comment' | 'stamp') {
  annotationMode.value = annotationMode.value === mode ? null : mode
}

function startAnnotation(event: MouseEvent) {
  if (!annotationMode.value) return

  isDrawing.value = true
  const rect = canvasRef.value!.getBoundingClientRect()
  startCoords.value = {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top,
  }
}

function drawAnnotation(event: MouseEvent) {
  if (!isDrawing.value || annotationMode.value !== 'highlight') return

  // Dessiner preview surlignage (optionnel)
}

function endAnnotation(event: MouseEvent) {
  if (!isDrawing.value || !annotationMode.value) return

  isDrawing.value = false
  const rect = canvasRef.value!.getBoundingClientRect()
  const endCoords = {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top,
  }

  // CrÃ©er annotation
  const annotation: Omit<Annotation, 'id'> = {
    page_number: currentPage.value,
    type: annotationMode.value.toUpperCase() as 'HIGHLIGHT' | 'COMMENT' | 'STAMP',
    coordinates: {
      x: Math.min(startCoords.value.x, endCoords.x),
      y: Math.min(startCoords.value.y, endCoords.y),
      width: Math.abs(endCoords.x - startCoords.value.x),
      height: Math.abs(endCoords.y - startCoords.value.y),
    },
    color: highlightColor.value,
    content: annotationMode.value === 'comment' ? prompt('Commentaire :') || '' : '',
  }

  emit('annotate', annotation)
}
</script>

<style scoped>
.pdf-viewer {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.toolbar {
  display: flex;
  gap: 1rem;
  padding: 0.5rem;
  background: #f5f5f5;
  border-bottom: 1px solid #ddd;
}

.canvas-container {
  position: relative;
  flex: 1;
  overflow: auto;
  background: #525252;
  display: flex;
  justify-content: center;
  align-items: center;
}

canvas {
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.annotations-overlay {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
}

.annotation {
  position: absolute;
  opacity: 0.4;
}

.annotation-highlight {
  background: yellow;
}

.annotation-comment {
  background: rgba(255, 0, 0, 0.2);
  border: 2px solid red;
  pointer-events: auto;
  cursor: pointer;
}

.comment-text {
  position: absolute;
  top: 100%;
  left: 0;
  background: white;
  border: 1px solid red;
  padding: 0.5rem;
  z-index: 10;
  white-space: nowrap;
}
</style>
```

---

## ğŸ“ Ã‰tape 4 : Attribution des Notes

### Sidebar de Notation

**Composant** : `frontend/src/views/teacher/CopyGrading.vue`

```vue
<template>
  <div class="copy-grading">
    <!-- Sidebar: Notation -->
    <aside class="grading-sidebar">
      <div class="header">
        <h2>Copie {{ copy?.anonymous_id }}</h2>
        <p class="exam-name">{{ copy?.exam.name }}</p>
      </div>

      <div class="grading-form">
        <!-- Pour chaque question principale -->
        <div
          v-for="question in exam?.grading_structure"
          :key="question.question"
          class="question-block"
        >
          <div class="question-header">
            <h3>{{ question.question }}. {{ question.title }}</h3>
            <span class="max-score">/ {{ question.max_score }} pts</span>
          </div>

          <!-- Sous-questions -->
          <div
            v-for="sub in question.sub_questions"
            :key="sub.id"
            class="sub-question"
          >
            <label>{{ sub.id }}. {{ sub.title }}</label>

            <div class="score-input">
              <input
                type="number"
                v-model.number="grades[sub.id]"
                :max="sub.max_score"
                step="0.25"
                @input="onGradeChange"
              />
              <span class="max">/ {{ sub.max_score }}</span>
            </div>

            <!-- Indicateur visuel note -->
            <div class="score-bar">
              <div
                class="fill"
                :style="{
                  width: `${(grades[sub.id] / sub.max_score) * 100}%`,
                  backgroundColor: getScoreColor(grades[sub.id], sub.max_score),
                }"
              ></div>
            </div>
          </div>

          <!-- Commentaire question -->
          <textarea
            v-model="comments[question.question]"
            placeholder="Commentaire gÃ©nÃ©ral sur la question..."
            @input="onGradeChange"
          ></textarea>
        </div>
      </div>

      <!-- Total -->
      <div class="total-score">
        <strong>Total:</strong>
        <span class="score" :class="{ complete: isComplete }">
          {{ totalScore.toFixed(2) }} / {{ maxScore }}
        </span>
        <div class="progress-bar">
          <div
            class="fill"
            :style="{ width: `${(totalScore / maxScore) * 100}%` }"
          ></div>
        </div>
      </div>

      <!-- Actions -->
      <div class="actions">
        <button @click="saveDraft" class="btn-secondary" :disabled="isSaving">
          ğŸ’¾ {{ isSaving ? 'Sauvegarde...' : 'Sauvegarder' }}
        </button>
        <button
          @click="finalize"
          class="btn-primary"
          :disabled="!isComplete || isLocked"
        >
          ğŸ”’ Finaliser et Verrouiller
        </button>
      </div>

      <!-- Auto-save indicator -->
      <div class="auto-save-indicator" v-if="lastSaved">
        <small>âœ“ SauvegardÃ© {{ lastSavedText }}</small>
      </div>
    </aside>

    <!-- Main: PDF Viewer -->
    <main class="pdf-viewer-container">
      <PDFViewer
        v-if="copy"
        :src="copy.pdf_url"
        :annotations="annotations"
        @annotate="handleAnnotation"
      />
    </main>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import api from '@/services/api'
import PDFViewer from '@/components/shared/PDFViewer.vue'
import type { Copy, Exam, Annotation } from '@/types'

const route = useRoute()
const router = useRouter()
const copyId = route.params.id as string

const copy = ref<Copy | null>(null)
const exam = ref<Exam | null>(null)
const grades = ref<Record<string, number>>({})
const comments = ref<Record<string, string>>({})
const annotations = ref<Annotation[]>([])

const isSaving = ref(false)
const lastSaved = ref<Date | null>(null)
const isLocked = ref(false)

let autoSaveTimeout: ReturnType<typeof setTimeout> | null = null

onMounted(async () => {
  await loadCopy()
})

async function loadCopy() {
  const response = await api.get(`/api/grading/copies/${copyId}/`)
  copy.value = response.data
  exam.value = response.data.exam
  isLocked.value = response.data.is_locked

  // Charger notes existantes
  if (copy.value.grades) {
    copy.value.grades.forEach(g => {
      grades.value[g.question_id] = g.score
      const mainQuestionId = g.question_id.split('.')[0]
      comments.value[mainQuestionId] = g.comment || ''
    })
  }

  // Charger annotations
  annotations.value = copy.value.annotations || []
}

const totalScore = computed(() => {
  return Object.values(grades.value).reduce((sum, score) => sum + (score || 0), 0)
})

const maxScore = computed(() => {
  if (!exam.value) return 0
  return exam.value.grading_structure.reduce((sum, q) => {
    return sum + q.sub_questions.reduce((subSum, sub) => subSum + sub.max_score, 0)
  }, 0)
})

const isComplete = computed(() => {
  if (!exam.value) return false

  const allQuestionIds = exam.value.grading_structure.flatMap(q =>
    q.sub_questions.map(sub => sub.id)
  )

  return allQuestionIds.every(qId => qId in grades.value && grades.value[qId] !== null)
})

const lastSavedText = computed(() => {
  if (!lastSaved.value) return ''
  const seconds = Math.floor((Date.now() - lastSaved.value.getTime()) / 1000)
  if (seconds < 60) return `il y a ${seconds}s`
  const minutes = Math.floor(seconds / 60)
  return `il y a ${minutes}min`
})

function getScoreColor(score: number, maxScore: number): string {
  const ratio = score / maxScore
  if (ratio >= 0.8) return '#4caf50'  // Vert
  if (ratio >= 0.5) return '#ff9800'  // Orange
  return '#f44336'  // Rouge
}

function onGradeChange() {
  // Debounce auto-save
  if (autoSaveTimeout) clearTimeout(autoSaveTimeout)

  autoSaveTimeout = setTimeout(async () => {
    await saveDraft()
  }, 2000)  // 2 secondes aprÃ¨s derniÃ¨re modification
}

async function saveDraft() {
  if (isLocked.value) return

  isSaving.value = true

  try {
    // Construire grades array
    const gradesArray = Object.entries(grades.value).map(([questionId, score]) => ({
      question_id: questionId,
      score: score || 0,
      max_score: getMaxScoreForQuestion(questionId),
      comment: comments.value[questionId.split('.')[0]] || '',
    }))

    await api.patch(`/api/grading/copies/${copyId}/`, {
      grades: gradesArray,
      annotations: annotations.value,
      status: 'IN_PROGRESS',
    })

    lastSaved.value = new Date()
  } catch (error) {
    console.error('Save failed:', error)
    alert('Erreur lors de la sauvegarde')
  } finally {
    isSaving.value = false
  }
}

async function finalize() {
  if (!isComplete.value) {
    alert('Veuillez noter toutes les questions avant de finaliser')
    return
  }

  if (!confirm('Confirmer la finalisation ? La copie sera verrouillÃ©e et non modifiable.')) {
    return
  }

  try {
    // Sauvegarder d'abord
    await saveDraft()

    // Verrouiller
    await api.post(`/api/grading/copies/${copyId}/lock/`)

    alert('Copie finalisÃ©e et verrouillÃ©e âœ“')
    router.push('/teacher/dashboard')
  } catch (error: any) {
    console.error('Finalize failed:', error)
    alert(error.response?.data?.error || 'Erreur lors de la finalisation')
  }
}

function handleAnnotation(annotation: Omit<Annotation, 'id'>) {
  // Ajouter localement (l'ID sera gÃ©nÃ©rÃ© par le backend)
  annotations.value.push({ id: Date.now().toString(), ...annotation })

  // DÃ©clencher auto-save
  onGradeChange()
}

function getMaxScoreForQuestion(questionId: string): number {
  for (const q of exam.value!.grading_structure) {
    for (const sub of q.sub_questions) {
      if (sub.id === questionId) return sub.max_score
    }
  }
  return 0
}
</script>

<style scoped>
.copy-grading {
  display: flex;
  height: 100vh;
}

.grading-sidebar {
  width: 350px;
  background: #f5f5f5;
  border-right: 1px solid #ddd;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

.grading-form {
  flex: 1;
  padding: 1rem;
}

.question-block {
  background: white;
  padding: 1rem;
  margin-bottom: 1rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.question-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 2px solid #2196f3;
}

.sub-question {
  margin: 0.75rem 0;
}

.score-input {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.score-input input {
  width: 80px;
  padding: 0.5rem;
  font-size: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.score-bar {
  height: 6px;
  background: #e0e0e0;
  border-radius: 3px;
  overflow: hidden;
  margin-top: 0.25rem;
}

.score-bar .fill {
  height: 100%;
  transition: width 0.3s, background-color 0.3s;
}

textarea {
  width: 100%;
  min-height: 60px;
  margin-top: 0.5rem;
  padding: 0.5rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-family: inherit;
}

.total-score {
  padding: 1rem;
  background: #e3f2fd;
  border-top: 2px solid #2196f3;
}

.total-score .score {
  font-size: 1.5rem;
  font-weight: bold;
  color: #1976d2;
}

.total-score .score.complete {
  color: #4caf50;
}

.progress-bar {
  height: 10px;
  background: #ccc;
  border-radius: 5px;
  overflow: hidden;
  margin-top: 0.5rem;
}

.progress-bar .fill {
  height: 100%;
  background: linear-gradient(to right, #2196f3, #4caf50);
  transition: width 0.3s;
}

.actions {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.auto-save-indicator {
  padding: 0.5rem 1rem;
  text-align: center;
  color: #4caf50;
}

.pdf-viewer-container {
  flex: 1;
  position: relative;
}
</style>
```

---

## ğŸ’¾ Ã‰tape 5 : Sauvegarde Automatique

### Backend API

**PATCH /api/grading/copies/{id}/**

```python
class CopyViewSet(viewsets.ModelViewSet):

    def partial_update(self, request, pk=None):
        """
        Sauvegarder progression de correction (draft).

        Body:
            {
                "grades": [
                    {"question_id": "1.a", "score": 1.5, "max_score": 1.5, "comment": "Bien"},
                    {"question_id": "1.b", "score": 1.0, "max_score": 2.0}
                ],
                "annotations": [...],
                "status": "IN_PROGRESS"
            }
        """
        copy = self.get_object()

        # VÃ©rifier permissions
        if not request.user.is_superuser and copy.corrector != request.user:
            return Response({'error': 'Not your copy'}, status=403)

        # VÃ©rifier que copie n'est pas verrouillÃ©e
        if copy.is_locked:
            return Response({'error': 'Copy is locked'}, status=403)

        # Mettre Ã  jour les notes
        grades_data = request.data.get('grades', [])
        for grade_data in grades_data:
            Grade.objects.update_or_create(
                copy=copy,
                question_id=grade_data['question_id'],
                defaults={
                    'grader': request.user,
                    'score': Decimal(str(grade_data['score'])),
                    'max_score': Decimal(str(grade_data['max_score'])),
                    'comment': grade_data.get('comment', ''),
                }
            )

        # Mettre Ã  jour annotations
        annotations_data = request.data.get('annotations', [])
        # Clear existing annotations
        copy.annotations.all().delete()
        for annot_data in annotations_data:
            Annotation.objects.create(
                copy=copy,
                author=request.user,
                page_id=annot_data.get('page_id'),
                annotation_type=annot_data['type'],
                content=annot_data.get('content', ''),
                coordinates=annot_data['coordinates'],
                color=annot_data.get('color', '#FFFF00'),
            )

        # Calculer total
        total = sum(g.score for g in copy.grades.all())
        copy.total_score = total

        # Mettre Ã  jour status
        copy.status = request.data.get('status', copy.status)
        copy.save()

        return Response(CopyDetailSerializer(copy).data)
```

---

## ğŸ”’ Ã‰tape 6 : Finalisation et Verrouillage

### API Endpoint

**POST /api/grading/copies/{id}/lock/**

**RÃ©ponse** :

```json
{
  "success": true,
  "copy": {
    "id": "uuid-copy-1",
    "status": "COMPLETED",
    "is_locked": true,
    "total_score": 18.5,
    "corrected_at": "2026-02-03T16:45:00Z"
  },
  "message": "Copy locked successfully"
}
```

### Backend

```python
from django.utils import timezone
from decimal import Decimal

class CopyViewSet(viewsets.ModelViewSet):

    @action(detail=True, methods=['post'])
    def lock(self, request, pk=None):
        """
        Verrouiller une copie aprÃ¨s correction complÃ¨te.

        VÃ©rifications:
        - Toutes les questions sont notÃ©es
        - Copie pas dÃ©jÃ  verrouillÃ©e
        """
        copy = self.get_object()

        # VÃ©rifier permissions
        if not request.user.is_superuser and copy.corrector != request.user:
            return Response({'error': 'Not your copy'}, status=403)

        # VÃ©rifier si dÃ©jÃ  verrouillÃ©e
        if copy.is_locked:
            return Response({'error': 'Copy already locked'}, status=400)

        # VÃ©rifier que toutes les questions sont notÃ©es
        exam_questions = self._extract_all_question_ids(copy.exam.grading_structure)
        graded_questions = set(copy.grades.values_list('question_id', flat=True))

        missing_questions = set(exam_questions) - graded_questions

        if missing_questions:
            return Response({
                'error': 'All questions must be graded before locking',
                'missing_questions': list(missing_questions)
            }, status=400)

        # Verrouiller
        copy.is_locked = True
        copy.status = Copy.Status.COMPLETED
        copy.corrected_at = timezone.now()
        copy.save()

        return Response({
            'success': True,
            'copy': CopySerializer(copy).data,
            'message': 'Copy locked successfully'
        })

    def _extract_all_question_ids(self, grading_structure: list) -> list[str]:
        """Extraire tous les IDs de sous-questions du barÃ¨me."""
        question_ids = []
        for question in grading_structure:
            for sub in question.get('sub_questions', []):
                question_ids.append(sub['id'])
        return question_ids

    @action(detail=True, methods=['post'])
    def unlock(self, request, pk=None):
        """
        DÃ©verrouiller une copie (admin uniquement).
        """
        if not request.user.is_superuser:
            return Response({'error': 'Admin only'}, status=403)

        copy = self.get_object()
        copy.is_locked = False
        copy.status = Copy.Status.IN_PROGRESS
        copy.save()

        return Response({
            'success': True,
            'message': 'Copy unlocked'
        })
```

---

## ğŸ“Š MÃ©triques et Performance

### Temps de Correction

**Estimations** :
- Temps moyen par copie : **10-15 minutes**
- Temps sauvegarde draft : **< 500ms**
- Temps chargement PDF : **< 2s**

### Optimisations

1. **Auto-save debounced** : Sauvegarder 2s aprÃ¨s derniÃ¨re modification (Ã©viter requÃªtes trop frÃ©quentes)
2. **Lazy loading PDF** : Charger pages Ã  la demande (pas toutes d'un coup)
3. **Compression annotations** : Stocker en JSON compact
4. **Cache Redis** : Mettre en cache grading_structure de l'examen

---

## ğŸ“ Conclusion

Le workflow de correction offre une expÃ©rience fluide et intuitive pour les enseignants, avec sauvegarde automatique et outils d'annotation puissants.

**Points clÃ©s** :
- Interface split (sidebar notation + PDF viewer)
- Annotations riches (surlignage, commentaires, tampons)
- Auto-save toutes les 2s
- Validation avant verrouillage
- Calcul automatique du total

---

**Document rÃ©digÃ© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 FÃ©vrier 2026
