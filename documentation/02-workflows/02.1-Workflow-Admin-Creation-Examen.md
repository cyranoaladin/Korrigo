# 02.1 - Workflow Complet : Cr√©ation d'Examen par l'Administrateur

**Auteur** : Alaeddine BEN RHOUMA
**Date** : 3 F√©vrier 2026
**Version** : 2.0

---

## üéØ Vue d'Ensemble

Ce workflow d√©crit **√©tape par √©tape** comment un administrateur cr√©e un nouvel examen dans Korrigo, depuis la configuration initiale jusqu'au traitement des copies scann√©es.

**Dur√©e totale** : 15-30 minutes (selon volume de scans)
**Pr√©requis** : Compte administrateur actif, fichiers pr√©par√©s (CSV √©l√®ves, PDF scans)

---

## üìã Pr√©requis et Pr√©paration

### Fichiers N√©cessaires

#### 1. Liste des √âl√®ves (CSV)

**Format attendu** :
```csv
√âl√®ves,N√©(e) le,Adresse E-mail,Classe
DUPONT Jean,01/02/2008,jean.dupont@ecole.tn,T.01
MARTIN Marie,15/03/2008,marie.martin@ecole.tn,T.01
```

**Colonnes obligatoires** :
- `√âl√®ves` : NOM Pr√©nom (espace entre nom et pr√©nom)
- `N√©(e) le` : DD/MM/YYYY
- `Adresse E-mail` : email@domain.tn
- `Classe` : Code classe (optionnel)

**Validation** :
‚úì Encodage : UTF-8
‚úì S√©parateur : virgule (,)
‚úì Pas de lignes vides
‚úì Emails uniques

#### 2. Scans des Copies (PDF)

**Formats support√©s** :
- **A4** : 21 x 29.7 cm (595 x 842 pixels @ 72 DPI)
- **A3** : 29.7 x 42 cm (1190 x 1684 pixels @ 72 DPI)

**Organisation** :
- Un seul PDF contenant toutes les copies
- Pages dans l'ordre de scan
- R√©solution minimale : 150 DPI (recommand√© : 300 DPI)
- Noir et blanc ou couleur
- Taille max : 200 MB par fichier

**Cas A3 (CMEN Batch)** :
```
Format: 2 feuilles A3 recto-verso par √©l√®ve = 4 pages A4

Organisation physique (scan):
Sheet 1 (A3):
  - Left half: Page 4
  - Right half: Page 1
Sheet 2 (A3):
  - Left half: Page 2
  - Right half: Page 3

R√©sultat attendu apr√®s traitement:
  Page 1, Page 2, Page 3, Page 4 (ordre logique)
```

---

## üöÄ Workflow D√©taill√©

### √âTAPE 1 : Connexion Admin

```
URL: http://localhost:8088 (ou https://korrigo.labomths.tn)
Username: test_admin
Password: admin123
```

**Actions** :
1. Ouvrir navigateur
2. Aller sur URL Korrigo
3. Cliquer "Connexion"
4. Entrer identifiants admin
5. Cliquer "Se connecter"

**API Call** :
```http
POST /api/login/
Content-Type: application/json

{
  "username": "test_admin",
  "password": "admin123"
}

Response 200 OK:
{
  "message": "Login successful",
  "must_change_password": false
}

Cookies:
  - sessionid=<session_token>
  - csrftoken=<csrf_token>
```

**V√©rifications** :
‚úì Redirection vers dashboard
‚úì Menu "Cr√©er Examen" visible
‚úì R√¥le = "Admin" dans profil

---

### √âTAPE 2 : Cr√©er un Nouvel Examen

**Navigation** :
```
Dashboard ‚Üí Menu "Examens" ‚Üí Bouton "Cr√©er un Examen"
```

**Formulaire de Cr√©ation** :

#### 2.1 Informations G√©n√©rales

| Champ | Type | Obligatoire | Exemple |
|-------|------|-------------|---------|
| **Nom de l'examen** | Texte | ‚úì | "Bac Blanc Math√©matiques 2026" |
| **Date** | Date picker | ‚úì | 03/02/2026 |
| **Mati√®re** | Select | ‚úì | Math√©matiques |
| **Niveau** | Select | ‚úì | Terminale |
| **Dur√©e** | Number | ‚úì | 4 heures |
| **Coefficient** | Number | ‚úì | 7 |

```javascript
// Frontend: ExamCreate.vue
const examData = {
  name: "Bac Blanc Math√©matiques 2026",
  date: "2026-02-03",
  subject: "mathematics",
  level: "terminale",
  duration: 240,  // minutes
  coefficient: 7
}
```

#### 2.2 Structure de Notation (Bar√®me)

**D√©finir les questions et sous-questions** :

```javascript
// Exemple de structure
gradingStructure: [
  {
    question: "1",
    title: "√âtude de fonction",
    max_score: 5.0,
    sub_questions: [
      { id: "1.a", label: "D√©riv√©e", max_score: 2.0 },
      { id: "1.b", label: "Tableau de variation", max_score: 2.0 },
      { id: "1.c", label: "Courbe", max_score: 1.0 }
    ]
  },
  {
    question: "2",
    title: "Probabilit√©s",
    max_score: 4.0,
    sub_questions: [
      { id: "2.a", label: "Loi normale", max_score: 2.0 },
      { id: "2.b", label: "Intervalle de confiance", max_score: 2.0 }
    ]
  },
  {
    question: "3",
    title: "G√©om√©trie dans l'espace",
    max_score: 6.0,
    // Sans sous-questions
  },
  {
    question: "4",
    title: "Algorithme",
    max_score: 5.0,
    sub_questions: [
      { id: "4.a", label: "√âcriture algorithme", max_score: 3.0 },
      { id: "4.b", label: "Complexit√©", max_score: 2.0 }
    ]
  }
]

// Total: 5 + 4 + 6 + 5 = 20 points
```

**Interface** :
- Bouton "+ Ajouter Question"
- Pour chaque question :
  - Num√©ro (auto-incr√©ment√©)
  - Titre
  - Score maximum
  - Option "+ Sous-question"
- Calcul automatique du total
- Validation : Total doit √™tre coh√©rent (g√©n√©ralement 20 points)

#### 2.3 Sauvegarder l'Examen

**Bouton** : "Cr√©er l'Examen"

**API Call** :
```http
POST /api/exams/
Content-Type: application/json
Authorization: Cookie sessionid=...

{
  "name": "Bac Blanc Math√©matiques 2026",
  "date": "2026-02-03",
  "subject": "mathematics",
  "level": "terminale",
  "duration": 240,
  "coefficient": 7,
  "grading_structure": [
    {
      "question": "1",
      "title": "√âtude de fonction",
      "max_score": 5.0,
      "sub_questions": [...]
    },
    ...
  ]
}

Response 201 Created:
{
  "id": "136db0b7-c496-4bd4-b662-d4dacee35ef4",
  "name": "Bac Blanc Math√©matiques 2026",
  "date": "2026-02-03",
  "is_processed": false,
  "booklet_count": 0,
  "correctors": [],
  "created_at": "2026-02-03T09:00:00Z"
}
```

**Base de Donn√©es** :
```sql
-- Table: exams_exam
INSERT INTO exams_exam (
  id,
  name,
  date,
  subject,
  level,
  duration,
  coefficient,
  creator_id,
  is_processed,
  created_at
) VALUES (
  '136db0b7-c496-4bd4-b662-d4dacee35ef4',
  'Bac Blanc Math√©matiques 2026',
  '2026-02-03',
  'mathematics',
  'terminale',
  240,
  7,
  15,  -- admin user_id
  false,
  NOW()
);

-- Table: exams_gradingstructure (une ligne par question)
INSERT INTO exams_gradingstructure (id, exam_id, question, title, max_score, sub_questions)
VALUES
  (1, '136db0b7...', '1', '√âtude de fonction', 5.0, '[{"id":"1.a","label":"D√©riv√©e","max_score":2.0}...]'),
  (2, '136db0b7...', '2', 'Probabilit√©s', 4.0, '[...]'),
  (3, '136db0b7...', '3', 'G√©om√©trie dans l'espace', 6.0, NULL),
  (4, '136db0b7...', '4', 'Algorithme', 5.0, '[...]');
```

**R√©sultat** :
‚úì Examen cr√©√© avec UUID unique
‚úì Statut initial : `is_processed=False`
‚úì Pr√™t pour upload des fichiers

---

### √âTAPE 3 : Import Liste des √âl√®ves (CSV)

**Navigation** :
```
Dashboard ‚Üí Examen cr√©√© ‚Üí Onglet "√âl√®ves" ‚Üí Bouton "Importer CSV"
```

**Actions** :
1. Cliquer "Parcourir" ou drag & drop
2. S√©lectionner fichier CSV (UTF-8)
3. Pr√©visualiser (affichage des 5 premi√®res lignes)
4. Valider et importer

**API Call** :
```http
POST /api/students/import/
Content-Type: multipart/form-data
Authorization: Cookie sessionid=...

Form Data:
  - file: students.csv (binary)
  - exam_id: 136db0b7-c496-4bd4-b662-d4dacee35ef4

Response 200 OK:
{
  "success": true,
  "imported": 50,
  "errors": [],
  "warnings": [
    "Ligne 12: email d√©j√† existant, √©l√®ve ignor√©"
  ]
}
```

**Backend Processing** :
```python
# students/views.py - import_students()
def import_students(request):
    csv_file = request.FILES['file']
    exam_id = request.POST['exam_id']

    # Parse CSV
    df = pd.read_csv(csv_file, encoding='utf-8')

    # Validation
    required_columns = ['√âl√®ves', 'N√©(e) le', 'Adresse E-mail']
    for col in required_columns:
        if col not in df.columns:
            return Response({'error': f'Missing column {col}'}, status=400)

    # Import chaque ligne
    imported_count = 0
    for index, row in df.iterrows():
        # Parse nom/pr√©nom
        full_name = row['√âl√®ves'].strip()
        parts = full_name.split(' ', 1)
        last_name = parts[0]
        first_name = parts[1] if len(parts) > 1 else ''

        # Parse date
        dob_str = row['N√©(e) le']
        dob = datetime.strptime(dob_str, '%d/%m/%Y').date()

        # Cr√©er Student
        student, created = Student.objects.get_or_create(
            email=row['Adresse E-mail'],
            defaults={
                'first_name': first_name,
                'last_name': last_name,
                'date_of_birth': dob,
                'classe': row.get('Classe', '')
            }
        )

        if created:
            imported_count += 1

    return Response({
        'success': True,
        'imported': imported_count
    })
```

**Base de Donn√©es** :
```sql
-- Table: students_student
INSERT INTO students_student (email, first_name, last_name, date_of_birth, classe)
VALUES
  ('jean.dupont@ecole.tn', 'Jean', 'DUPONT', '2008-02-01', 'T.01'),
  ('marie.martin@ecole.tn', 'Marie', 'MARTIN', '2008-03-15', 'T.01'),
  ...
  -- Total: 50 √©l√®ves
```

**R√©sultat** :
‚úì 50 √©l√®ves import√©s
‚úì Visibles dans l'onglet "√âl√®ves" de l'examen
‚úì Whitelist pr√™te pour OCR matching

---

### √âTAPE 4 : Upload des Scans PDF

**Navigation** :
```
Dashboard ‚Üí Examen ‚Üí Onglet "Copies" ‚Üí Bouton "Uploader Scans"
```

#### 4.1 S√©lection du Fichier

**Interface** :
- Zone drag & drop
- Bouton "Parcourir"
- Barre de progression
- Estimation temps restant

**Actions** :
1. S√©lectionner `scans_bac_blanc_2026.pdf` (120 MB, 200 pages)
2. Cocher "Mode Batch A3" (si applicable)
3. Cocher "Avec CSV √©l√®ves" (pour OCR auto)
4. Cliquer "Uploader et Traiter"

#### 4.2 Upload Progressif

**Frontend** :
```javascript
// Chunked upload pour gros fichiers
const uploadPDF = async (file) => {
  const chunkSize = 1024 * 1024 * 5; // 5 MB chunks
  const totalChunks = Math.ceil(file.size / chunkSize);

  for (let i = 0; i < totalChunks; i++) {
    const chunk = file.slice(
      i * chunkSize,
      Math.min((i + 1) * chunkSize, file.size)
    );

    const formData = new FormData();
    formData.append('chunk', chunk);
    formData.append('chunkIndex', i);
    formData.append('totalChunks', totalChunks);
    formData.append('filename', file.name);

    await axios.post('/api/exams/upload-chunk/', formData, {
      onUploadProgress: (progressEvent) => {
        const percentCompleted = Math.round(
          ((i + progressEvent.loaded / progressEvent.total) / totalChunks) * 100
        );
        updateProgress(percentCompleted);
      }
    });
  }

  // Finalize upload
  await axios.post('/api/exams/finalize-upload/', {
    exam_id: examId,
    filename: file.name,
    batch_mode: isBatchA3,
    with_csv: true
  });
};
```

**API Calls** :
```http
POST /api/exams/upload-chunk/
Content-Type: multipart/form-data

Form Data:
  - chunk: <binary>
  - chunkIndex: 0
  - totalChunks: 24
  - filename: scans_bac_blanc_2026.pdf

Response 200 OK:
{
  "chunk_received": 0,
  "total_chunks": 24
}

... (r√©p√©t√© 24 fois) ...

POST /api/exams/finalize-upload/
Content-Type: application/json

{
  "exam_id": "136db0b7-c496-4bd4-b662-d4dacee35ef4",
  "filename": "scans_bac_blanc_2026.pdf",
  "batch_mode": true,
  "with_csv": true
}

Response 202 Accepted:
{
  "message": "Upload finalized, processing started",
  "task_id": "abc-123-def-456",
  "estimated_time": "5-10 minutes"
}
```

#### 4.3 Sauvegarde et D√©clenchement du Traitement

**Backend** :
```python
# exams/views.py - finalize_upload()
@api_view(['POST'])
def finalize_upload(request):
    exam_id = request.data['exam_id']
    filename = request.data['filename']
    batch_mode = request.data.get('batch_mode', False)
    with_csv = request.data.get('with_csv', False)

    # Reconstituer le fichier √† partir des chunks
    final_path = os.path.join(MEDIA_ROOT, 'exams', 'source', f'exam_{exam_id}.pdf')
    chunks_dir = os.path.join(TEMP_DIR, filename)

    with open(final_path, 'wb') as final_file:
        for i in range(total_chunks):
            chunk_path = os.path.join(chunks_dir, f'chunk_{i}')
            with open(chunk_path, 'rb') as chunk_file:
                final_file.write(chunk_file.read())
            os.remove(chunk_path)  # Cleanup

    # Sauvegarder dans DB
    exam = Exam.objects.get(id=exam_id)
    exam.pdf_source = final_path
    exam.save()

    # D√©clencher traitement asynchrone (Celery)
    if batch_mode:
        task = process_batch_a3.delay(exam_id, with_csv)
    else:
        task = process_standard_pdf.delay(exam_id)

    return Response({
        'message': 'Upload finalized, processing started',
        'task_id': str(task.id),
        'estimated_time': '5-10 minutes'
    }, status=202)
```

**Stockage** :
```bash
/media/exams/source/exam_136db0b7-c496-4bd4-b662-d4dacee35ef4.pdf
  Size: 120 MB
  Pages: 200
  Format: A3
```

**R√©sultat** :
‚úì PDF sauvegard√© dans `/media/exams/source/`
‚úì T√¢che Celery lanc√©e
‚úì Interface affiche "Traitement en cours..."

---

### √âTAPE 5 : Traitement Asynchrone (Celery)

**Task Celery** : `process_batch_a3.delay(exam_id, with_csv)`

#### 5.1 D√©tection Format

```python
# processing/services/batch_processor.py
def is_a3_format(pdf_path):
    doc = fitz.open(pdf_path)
    page = doc.load_page(0)
    width, height = page.rect.width, page.rect.height

    # A3: ~1190 x 1684 pixels (¬± 50 pixels de tol√©rance)
    is_a3 = (1140 < width < 1240) and (1634 < height < 1734)

    doc.close()
    return is_a3
```

**R√©sultat** :
‚úì Format d√©tect√© : **A3**
‚úì Algorithme : BatchA3Processor

#### 5.2 Split et Rotation des Pages A3

**Objectif** : Transformer chaque feuille A3 en 2 pages A4

```python
def _split_a3_to_a4(self, a3_image):
    """
    Split une image A3 en 2 moiti√©s A4 (gauche et droite).

    Input: a3_image (H x W x C) - ex: 1684 x 1190 pixels
    Output: (left_a4, right_a4) - chacune 1684 x 595 pixels
    """
    height, width = a3_image.shape[:2]
    mid_width = width // 2

    # Left half
    left = a3_image[:, :mid_width].copy()

    # Right half
    right = a3_image[:, mid_width:].copy()

    return left, right
```

**Traitement pour 88 pages A3** :
```
Page A3 #1 ‚Üí [Page A4 #1-left, Page A4 #1-right]
Page A3 #2 ‚Üí [Page A4 #2-left, Page A4 #2-right]
...
Page A3 #88 ‚Üí [Page A4 #88-left, Page A4 #88-right]

Total: 88 pages A3 ‚Üí 176 pages A4
```

#### 5.3 R√©organisation selon Organisation Physique

**Pour CMEN Batch** :

Chaque √©l√®ve a 2 feuilles A3 recto-verso = 4 pages A3 scann√©es = 8 demi-pages

**Mapping physique ‚Üí logique** :
```python
def _reorder_pages_per_sheet(self, pages_a4):
    """
    R√©organise les pages A4 selon l'ordre logique.

    Organisation physique (scan):
    A3#1-left  = Page 4
    A3#1-right = Page 1
    A3#2-left  = Page 2
    A3#2-right = Page 3

    Ordre logique souhait√©: Page 1, 2, 3, 4
    """
    sheets = []
    for i in range(0, len(pages_a4), 4):  # 4 pages A3 = 1 copie
        sheet_pages = pages_a4[i:i+4]

        # R√©organisation
        reordered = [
            sheet_pages[1],  # A3#1-right = Page 1
            sheet_pages[2],  # A3#2-left  = Page 2
            sheet_pages[3],  # A3#2-right = Page 3
            sheet_pages[0],  # A3#1-left  = Page 4
        ]

        sheets.append(reordered)

    return sheets
```

**R√©sultat** :
‚úì 88 pages A3 ‚Üí 176 pages A4
‚úì R√©organis√©es en 44 copies (4 pages par copie)

#### 5.4 Segmentation par √âtudiant

**OCR du Header** :

```python
def _ocr_header(self, page_image):
    """
    Extrait nom/pr√©nom/date depuis le header de la page.
    Utilise OCR multi-layer pour robustesse.
    """
    # 1. Extraction de la zone header (200 premiers pixels)
    header_zone = page_image[:200, :]

    # 2. OCR multi-layer
    ocr_engine = MultiLayerOCR()
    ocr_result = ocr_engine.extract_text_with_candidates(
        header_zone,
        csv_whitelist=self.students_whitelist
    )

    # 3. Matching avec CSV
    if ocr_result.top_candidates:
        top_match = ocr_result.top_candidates[0]
        if top_match.confidence > 0.7:
            # AUTO mode
            return top_match
        elif top_match.confidence > 0.4:
            # SEMI-AUTO mode (top 5 candidates)
            return ('SEMI_AUTO', ocr_result.top_candidates[:5])
        else:
            # MANUAL mode
            return ('MANUAL', None)

    return ('MANUAL', None)
```

**Pour chaque copie (4 pages)** :

```python
# Page 1 (premi√®re page de la copie)
ocr_result = _ocr_header(page1_image)

if ocr_result confidence > 0.7:
    # Attribution automatique
    student = Student.objects.get(email=ocr_result.email)
    copy = Copy.objects.create(
        exam_id=exam_id,
        student=student,
        is_identified=True,
        anonymous_id=generate_anonymous_id()
    )
else:
    # Marqu√© pour identification manuelle
    copy = Copy.objects.create(
        exam_id=exam_id,
        student=None,
        is_identified=False,
        needs_review=True,
        ocr_candidates=ocr_result.top_candidates  # Pour SEMI-AUTO
    )
```

**R√©sultat** :
‚úì 44 copies cr√©√©es
‚úì ~30-35 copies identifi√©es automatiquement (AUTO)
‚úì ~8-10 copies en mode SEMI-AUTO (top 5 candidats)
‚úì ~1-4 copies en mode MANUAL

#### 5.5 Cr√©ation des Booklets et Pages

```python
for copy_index, pages in enumerate(segmented_copies):
    # Cr√©er Copy
    copy = Copy.objects.create(
        exam=exam,
        student=match.student if match else None,
        is_identified=match is not None,
        anonymous_id=generate_anonymous_id(),
        status='STAGING'  # En attente identification finale
    )

    # Cr√©er Booklet (cahier)
    booklet = Booklet.objects.create(
        copy=copy,
        sequence=1
    )

    # Sauvegarder PDF du booklet
    booklet_pdf_path = f'/media/copies/booklets/copy_{copy.id}/booklet_1.pdf'
    save_images_as_pdf(pages, booklet_pdf_path)
    booklet.pdf_file = booklet_pdf_path
    booklet.save()

    # Cr√©er Page entries
    for page_num, page_image in enumerate(pages, start=1):
        Page.objects.create(
            booklet=booklet,
            page_number=page_num,
            image_path=f'/media/exams/pages/copy_{copy.id}/page_{page_num}.png'
        )

        # Sauvegarder image
        cv2.imwrite(page.image_path, page_image)
```

**Base de Donn√©es** :
```sql
-- 44 copies cr√©√©es
INSERT INTO grading_copy (id, exam_id, student_id, anonymous_id, is_identified, status)
VALUES
  ('uuid1', 'exam_id', 'student1_id', 'COPY-001', true, 'STAGING'),
  ('uuid2', 'exam_id', 'student2_id', 'COPY-002', true, 'STAGING'),
  ...
  ('uuid44', 'exam_id', NULL, 'COPY-044', false, 'STAGING');  -- Non identifi√©

-- 44 booklets
INSERT INTO grading_booklet (copy_id, sequence, pdf_file)
VALUES
  ('uuid1', 1, '/media/copies/booklets/copy_uuid1/booklet_1.pdf'),
  ...

-- 176 pages (44 copies √ó 4 pages)
INSERT INTO grading_page (booklet_id, page_number, image_path)
VALUES
  (booklet1_id, 1, '/media/exams/pages/copy_uuid1/page_1.png'),
  (booklet1_id, 2, '/media/exams/pages/copy_uuid1/page_2.png'),
  ...
```

**Stockage** :
```bash
/media/
‚îú‚îÄ‚îÄ exams/pages/
‚îÇ   ‚îú‚îÄ‚îÄ copy_{uuid1}/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page_1.png  (500 KB)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page_2.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page_3.png
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page_4.png
‚îÇ   ‚îî‚îÄ‚îÄ ... (44 copies)
‚îÇ
‚îî‚îÄ‚îÄ copies/booklets/
    ‚îú‚îÄ‚îÄ copy_{uuid1}/
    ‚îÇ   ‚îî‚îÄ‚îÄ booklet_1.pdf  (4 pages, 2 MB)
    ‚îî‚îÄ‚îÄ ... (44 booklets)

Total: ~300 MB
```

**R√©sultat** :
‚úì 44 copies cr√©√©es
‚úì 44 booklets g√©n√©r√©s
‚úì 176 pages sauvegard√©es
‚úì ~250-300 MB de stockage

---

### √âTAPE 6 : Desk d'Identification (pour copies non identifi√©es)

**Navigation** :
```
Dashboard ‚Üí Examen ‚Üí Onglet "Identification" ‚Üí "Desk d'Identification"
```

**Interface** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Desk d'Identification - Bac Blanc Maths 2026               ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  Copies √† identifier: 12 / 44 (AUTO: 30, SEMI: 8, MANUAL: 4)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Copie COPY-015     ‚îÇ  ‚îÇ  Suggestions OCR (SEMI-AUTO)     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ  ‚îÇ                                  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ  ‚îÇ  ‚îÇ  1. ‚úì MARTIN Marie (78%)         ‚îÇ
‚îÇ  ‚îÇ   [Preview]   ‚îÇ  ‚îÇ  ‚îÇ     Email: marie.martin@...      ‚îÇ
‚îÇ  ‚îÇ   Page 1      ‚îÇ  ‚îÇ  ‚îÇ     DOB: 15/03/2008              ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ  ‚îÇ  ‚îÇ     [S√©lectionner]               ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  ‚îÇ                                  ‚îÇ
‚îÇ                     ‚îÇ  ‚îÇ  2. MARTINEZ Maria (65%)          ‚îÇ
‚îÇ  OCR d√©tect√©:       ‚îÇ  ‚îÇ     Email: maria.martinez@...    ‚îÇ
‚îÇ  "MARTIN Marie"     ‚îÇ  ‚îÇ     [S√©lectionner]               ‚îÇ
‚îÇ  "15/03/2008"       ‚îÇ  ‚îÇ                                  ‚îÇ
‚îÇ                     ‚îÇ  ‚îÇ  3. MARTINS Marie (52%)           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ     [S√©lectionner]               ‚îÇ
                         ‚îÇ                                  ‚îÇ
                         ‚îÇ  ‚îÄ‚îÄ‚îÄ Ou ‚îÄ‚îÄ‚îÄ                      ‚îÇ
                         ‚îÇ                                  ‚îÇ
                         ‚îÇ  [Recherche Manuelle...]         ‚îÇ
                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Actions Admin** :

1. **SEMI-AUTO** : Cliquer sur candidat sugg√©r√© (ex: "MARTIN Marie 78%")
2. **MANUAL** : Recherche par nom/email, puis s√©lection

**API Call** :
```http
POST /api/identification/copies/{copy_id}/select-candidate/
Content-Type: application/json

{
  "rank": 1,  # ou student_id pour recherche manuelle
  "student_id": "student_uuid"
}

Response 200 OK:
{
  "success": true,
  "copy_id": "copy_uuid",
  "student": {
    "id": "student_uuid",
    "first_name": "Marie",
    "last_name": "MARTIN",
    "email": "marie.martin@ecole.tn"
  }
}
```

**Backend** :
```python
# identification/views.py
@api_view(['POST'])
def select_ocr_candidate(request, copy_id):
    copy = Copy.objects.get(id=copy_id)
    rank = request.data.get('rank')
    student_id = request.data.get('student_id')

    # R√©cup√©rer le candidat OCR s√©lectionn√©
    if rank:
        ocr_result = OCRResult.objects.get(copy=copy)
        candidate = ocr_result.top_candidates[rank - 1]
        student = Student.objects.get(id=candidate['student_id'])
    else:
        student = Student.objects.get(id=student_id)

    # Assigner l'√©tudiant √† la copie
    copy.student = student
    copy.is_identified = True
    copy.status = 'READY'  # Pr√™t pour distribution
    copy.save()

    # Audit trail
    ocr_result.selected_candidate_rank = rank
    ocr_result.manual_override = (rank is None)
    ocr_result.save()

    return Response({'success': True, 'student': student.to_dict()})
```

**Base de Donn√©es** :
```sql
-- Update Copy
UPDATE grading_copy
SET
  student_id = 'student_uuid',
  is_identified = true,
  status = 'READY'
WHERE id = 'copy_uuid';

-- Audit OCRResult
UPDATE identification_ocrresult
SET
  selected_candidate_rank = 1,
  manual_override = false
WHERE copy_id = 'copy_uuid';
```

**R√©sultat** :
‚úì Toutes les 44 copies identifi√©es
‚úì Statut = 'READY'
‚úì Pr√™t pour distribution aux correcteurs

---

### √âTAPE 7 : Attribution aux Correcteurs

**Navigation** :
```
Dashboard ‚Üí Examen ‚Üí Onglet "Correcteurs" ‚Üí "Distribuer les Copies"
```

**Interface** :

| Correcteur | Copies attribu√©es | Action |
|------------|-------------------|--------|
| Prof. DURAND | 0 / 44 | [Attribuer...] |
| Prof. LAMBERT | 0 / 44 | [Attribuer...] |
| Prof. ROUSSEAU | 0 / 44 | [Attribuer...] |

**Distribution** :

```javascript
// Option 1: Distribution automatique (√©quitable)
const distributeCopies = (copies, correctors) => {
  const copiesPerCorrector = Math.ceil(copies.length / correctors.length);

  correctors.forEach((corrector, index) => {
    const start = index * copiesPerCorrector;
    const end = Math.min(start + copiesPerCorrector, copies.length);
    const assignedCopies = copies.slice(start, end);

    assignedCopies.forEach(copy => {
      copy.corrector_id = corrector.id;
      copy.status = 'ASSIGNED';
    });
  });
};

// Option 2: Attribution manuelle
// Admin s√©lectionne copies et correcteur
```

**API Call** :
```http
POST /api/exams/{exam_id}/distribute-copies/
Content-Type: application/json

{
  "distribution": [
    {
      "corrector_id": "prof_durand_id",
      "copy_ids": ["copy_uuid1", "copy_uuid2", ..., "copy_uuid15"]
    },
    {
      "corrector_id": "prof_lambert_id",
      "copy_ids": ["copy_uuid16", ..., "copy_uuid30"]
    },
    {
      "corrector_id": "prof_rousseau_id",
      "copy_ids": ["copy_uuid31", ..., "copy_uuid44"]
    }
  ]
}

Response 200 OK:
{
  "success": true,
  "distributed": 44,
  "correctors": 3
}
```

**Base de Donn√©es** :
```sql
-- Update copies avec corrector_id
UPDATE grading_copy
SET
  corrector_id = 'prof_durand_id',
  status = 'ASSIGNED'
WHERE id IN ('copy_uuid1', 'copy_uuid2', ...);

-- Notification aux correcteurs (via Celery)
INSERT INTO notifications (user_id, message, type, created_at)
VALUES
  ('prof_durand_id', '15 copies assign√©es pour Bac Blanc Maths', 'ASSIGNMENT', NOW()),
  ...
```

**R√©sultat** :
‚úì 44 copies distribu√©es √† 3 correcteurs (~15 chacun)
‚úì Notifications envoy√©es
‚úì Correcteurs peuvent commencer la correction

---

## üìä R√©sum√© et Statistiques

### Temps de Traitement

| √âtape | Dur√©e | Status |
|-------|-------|--------|
| **Cr√©ation examen** | 5 min | ‚úÖ Compl√©t√© |
| **Import CSV (50 √©l√®ves)** | 30 sec | ‚úÖ Compl√©t√© |
| **Upload PDF (120 MB)** | 2 min | ‚úÖ Compl√©t√© |
| **Traitement batch (88 A3 ‚Üí 44 copies)** | 8-10 min | ‚úÖ Compl√©t√© |
| **Identification desk (12 copies)** | 5-10 min | ‚úÖ Compl√©t√© |
| **Distribution correcteurs** | 1 min | ‚úÖ Compl√©t√© |
| **TOTAL** | **22-30 min** | ‚úÖ **Pr√™t pour correction** |

### √âtat Final

**Examen** :
- ID: 136db0b7-c496-4bd4-b662-d4dacee35ef4
- Nom: Bac Blanc Math√©matiques 2026
- Date: 03/02/2026
- Statut: `is_processed=True`

**Copies** :
- Total: 44 copies
- Identifi√©es: 44 (100%)
- Distribu√©es: 44 (100%)
- Statut: `ASSIGNED`

**Stockage** :
- PDF source: 120 MB
- Pages extraites: 88 MB
- Booklets: 176 MB
- **Total: ~380 MB**

**Prochaine √©tape** :
‚Üí Voir [02.6-Workflow-Correction.md](./02.6-Workflow-Correction.md) pour le workflow de correction par les enseignants.

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
