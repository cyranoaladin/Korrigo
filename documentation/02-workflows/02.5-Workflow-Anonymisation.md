# 02.5 - Workflow Anonymisation des Copies

**Projet** : Korrigo - SystÃ¨me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 FÃ©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## ğŸ¯ Objectif

Ce workflow dÃ©crit le processus d'**anonymisation des copies** pour garantir une correction impartiale :
1. GÃ©nÃ©ration d'identifiants anonymes
2. Masquage des informations personnelles sur les PDF
3. Affectation alÃ©atoire aux correcteurs
4. Correction en mode aveugle
5. DÃ©sanonymisation aprÃ¨s validation

---

## ğŸ“‹ Vue d'Ensemble

### Principe d'Anonymisation

L'anonymisation garantit que **le correcteur ne connaÃ®t pas l'identitÃ© de l'Ã©tudiant** pendant la correction :

- **ID Anonyme** : `A001`, `A002`, ..., `A999`
- **Header MasquÃ©** : Nom/prÃ©nom remplacÃ©s par ID anonyme sur PDF
- **Base de DonnÃ©es** : Mapping `anonymous_id â†” student_id` en base
- **Permissions** : Correcteur voit uniquement `anonymous_id`

---

## ğŸ”„ Diagramme Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  WORKFLOW ANONYMISATION                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Copies          â”‚
â”‚  IdentifiÃ©es     â”‚
â”‚  (aprÃ¨s OCR)     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GÃ©nÃ©ration      â”‚
â”‚  ID Anonymes     â”‚
â”‚  A001, A002, ... â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Masquage PDF    â”‚
â”‚  - OCR header    â”‚
â”‚  - Overlay blanc â”‚
â”‚  - Ã‰crire ID     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Sauvegarde      â”‚
â”‚  PDF AnonymisÃ©   â”‚
â”‚  media/copies/   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Affectation     â”‚
â”‚  AlÃ©atoire       â”‚
â”‚  Correcteurs     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Correction      â”‚
â”‚  Mode Aveugle    â”‚
â”‚  (anonymous_id)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Validation      â”‚
â”‚  Enseignant      â”‚
â”‚  (chef d'Ã©quipe) â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Publication     â”‚
â”‚  RÃ©sultats       â”‚
â”‚  (dÃ©sanonymise)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ Ã‰tapes DÃ©taillÃ©es

### Ã‰tape 1 : GÃ©nÃ©ration des ID Anonymes

**DÃ©clencheur** : AprÃ¨s identification des copies

**Logique** :
- ID sÃ©quentiels : `A001`, `A002`, ..., `A999`
- Format : `A` + numÃ©ro sur 3 chiffres (zero-padded)
- Unique par examen
- Ordre alÃ©atoire (shuffle) pour Ã©viter biais temporel

**Code Backend** :

```python
# copies/services/anonymizer.py

import random
from typing import List
from copies.models import Copy

class CopyAnonymizer:
    """Service pour anonymiser copies."""

    @staticmethod
    def generate_anonymous_ids(exam_id: int) -> dict:
        """
        GÃ©nÃ©rer IDs anonymes pour toutes les copies d'un examen.

        Returns:
            dict {copy_id: anonymous_id}
        """
        copies = Copy.objects.filter(exam_id=exam_id, is_identified=True)

        if not copies.exists():
            raise ValueError("No identified copies to anonymize")

        # GÃ©nÃ©rer IDs sÃ©quentiels
        anonymous_ids = [f"A{i:03d}" for i in range(1, copies.count() + 1)]

        # Shuffle pour ordre alÃ©atoire
        random.shuffle(anonymous_ids)

        # Mapping copy â†’ anonymous_id
        mapping = {}
        for copy, anon_id in zip(copies, anonymous_ids):
            copy.anonymous_id = anon_id
            copy.save()
            mapping[copy.id] = anon_id

        logger.info(f"Generated {len(mapping)} anonymous IDs for exam {exam_id}")

        return mapping
```

**Exemple** :

| copy_id | student_id | anonymous_id |
|---------|------------|--------------|
| 156 | 42 (Jean DUPONT) | A023 |
| 157 | 43 (Marie MARTIN) | A001 |
| 158 | 44 (Luc BERNARD) | A015 |

---

### Ã‰tape 2 : Masquage du Header PDF

**Objectif** : Remplacer nom/prÃ©nom par ID anonyme sur le PDF

**Approche** :

1. **DÃ©tecter zone header** (5 cm haut de page)
2. **Overlay blanc** sur zone nom/prÃ©nom
3. **Ã‰crire ID anonyme** avec police standard

**Code** :

```python
# copies/services/anonymizer.py

import fitz  # PyMuPDF
import cv2
import numpy as np

class CopyAnonymizer:
    """Service pour anonymiser copies."""

    HEADER_HEIGHT_CM = 5  # 5 cm depuis le haut
    DPI = 300

    def anonymize_pdf(self, copy: Copy) -> str:
        """
        Anonymiser PDF d'une copie.

        Returns:
            Chemin vers PDF anonymisÃ©
        """
        # Ouvrir PDF original
        doc = fitz.open(copy.pdf_file.path)

        for page_num in range(len(doc)):
            page = doc[page_num]

            # Calculer zone header (5 cm = ~590 pixels @ 300 DPI)
            page_height = page.rect.height
            header_height = (self.HEADER_HEIGHT_CM / 2.54) * self.DPI

            header_rect = fitz.Rect(
                0,  # x0
                0,  # y0
                page.rect.width,  # x1
                header_height  # y1
            )

            # Overlay blanc
            page.draw_rect(header_rect, color=(1, 1, 1), fill=(1, 1, 1))

            # Ã‰crire ID anonyme (centrÃ©)
            text = f"Copie : {copy.anonymous_id}"
            text_point = fitz.Point(page.rect.width / 2 - 100, header_height / 2)

            page.insert_text(
                text_point,
                text,
                fontsize=20,
                fontname="helv",  # Helvetica
                color=(0, 0, 0)  # Noir
            )

        # Sauvegarder PDF anonymisÃ©
        output_path = self._get_anonymized_path(copy)
        doc.save(output_path)
        doc.close()

        # Mettre Ã  jour Copy
        copy.pdf_anonymized = output_path
        copy.is_anonymized = True
        copy.save()

        logger.info(f"Anonymized PDF for copy {copy.id}: {output_path}")

        return output_path

    def _get_anonymized_path(self, copy: Copy) -> str:
        """Chemin vers PDF anonymisÃ©."""
        return f"media/copies/{copy.exam_id}/anonymized/copy_{copy.anonymous_id}.pdf"
```

**Exemple Visuel** :

**Avant Anonymisation** :
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Nom : DUPONT                           â”‚
â”‚  PrÃ©nom : Jean                          â”‚
â”‚  Date de naissance : 15/05/2008         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  Question 1: ...                        â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**AprÃ¨s Anonymisation** :
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                         â”‚
â”‚         Copie : A023                    â”‚
â”‚                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  Question 1: ...                        â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Ã‰tape 3 : Affectation AlÃ©atoire aux Correcteurs

**Objectif** : Distribuer copies Ã©quitablement entre correcteurs

**StratÃ©gies** :

1. **Round-Robin** : Alternance circulaire
2. **Random** : Affectation alÃ©atoire
3. **Load Balancing** : Ã‰quilibrer charge (nombre de copies par correcteur)

**Code** :

```python
# copies/services/assigner.py

from typing import List
from django.contrib.auth import get_user_model
from copies.models import Copy
import random

User = get_user_model()

class CopyAssigner:
    """Service pour affecter copies aux correcteurs."""

    @staticmethod
    def assign_copies_round_robin(exam_id: int, grader_ids: List[int]):
        """
        Affecter copies en round-robin.

        Args:
            exam_id: ID examen
            grader_ids: Liste IDs correcteurs
        """
        copies = Copy.objects.filter(
            exam_id=exam_id,
            is_anonymized=True,
            assigned_to__isnull=True
        ).order_by('anonymous_id')

        graders = User.objects.filter(id__in=grader_ids)

        if not graders.exists():
            raise ValueError("No graders provided")

        # Round-robin
        grader_cycle = itertools.cycle(graders)

        for copy in copies:
            grader = next(grader_cycle)
            copy.assigned_to = grader
            copy.status = 'ASSIGNED'
            copy.save()

            logger.info(f"Assigned copy {copy.anonymous_id} to {grader.username}")

    @staticmethod
    def assign_copies_random(exam_id: int, grader_ids: List[int]):
        """Affecter copies alÃ©atoirement."""
        copies = Copy.objects.filter(
            exam_id=exam_id,
            is_anonymized=True,
            assigned_to__isnull=True
        )

        graders = list(User.objects.filter(id__in=grader_ids))

        for copy in copies:
            grader = random.choice(graders)
            copy.assigned_to = grader
            copy.status = 'ASSIGNED'
            copy.save()

    @staticmethod
    def assign_copies_load_balanced(exam_id: int, grader_ids: List[int]):
        """
        Affecter copies en Ã©quilibrant la charge.

        Chaque correcteur reÃ§oit ~mÃªme nombre de copies.
        """
        copies = list(Copy.objects.filter(
            exam_id=exam_id,
            is_anonymized=True,
            assigned_to__isnull=True
        ))

        graders = list(User.objects.filter(id__in=grader_ids))

        # Shuffle copies pour Ã©viter biais
        random.shuffle(copies)

        # Calculer copies par correcteur
        copies_per_grader = len(copies) // len(graders)
        remainder = len(copies) % len(graders)

        # Distribuer
        copy_idx = 0
        for grader_idx, grader in enumerate(graders):
            # Calculer nombre de copies pour ce correcteur
            num_copies = copies_per_grader + (1 if grader_idx < remainder else 0)

            # Affecter copies
            for _ in range(num_copies):
                if copy_idx < len(copies):
                    copy = copies[copy_idx]
                    copy.assigned_to = grader
                    copy.status = 'ASSIGNED'
                    copy.save()
                    copy_idx += 1

        logger.info(f"Assigned {len(copies)} copies to {len(graders)} graders (load balanced)")
```

**Exemple** :

**3 correcteurs, 10 copies** :
- Correcteur 1 : A001, A004, A007, A010 (4 copies)
- Correcteur 2 : A002, A005, A008 (3 copies)
- Correcteur 3 : A003, A006, A009 (3 copies)

---

### Ã‰tape 4 : Correction en Mode Aveugle

**Interface Correcteur** : `CorrectionDesk.vue`

**Affichage** :
- **Visible** : ID anonyme (A023), PDF anonymisÃ©, questions, formulaire notes
- **CachÃ©** : Nom Ã©tudiant, prÃ©nom, email, classe

**Code Frontend** :

```vue
<template>
  <div class="correction-desk">
    <!-- Header anonyme -->
    <header class="copy-header">
      <h2>ğŸ“ Correction - Copie {{ copy.anonymous_id }}</h2>
      <span class="status">{{ copy.status }}</span>
    </header>

    <!-- PDF Viewer -->
    <div class="pdf-viewer">
      <iframe
        :src="`/api/grading/copies/${copyId}/pdf/`"
        width="100%"
        height="800px"
      ></iframe>
    </div>

    <!-- Grille de Correction -->
    <div class="grading-form">
      <h3>Notes</h3>

      <div v-for="question in questions" :key="question.id" class="question-grade">
        <label>{{ question.question_number }}. {{ question.title }}</label>

        <input
          v-model.number="grades[question.id]"
          type="number"
          :max="question.points"
          step="0.5"
          placeholder="0"
        />

        <span class="max-points">/ {{ question.points }}</span>

        <textarea
          v-model="comments[question.id]"
          placeholder="Commentaire (optionnel)"
          rows="2"
        ></textarea>
      </div>

      <!-- Commentaire global -->
      <div class="global-comment">
        <label>Commentaire GÃ©nÃ©ral</label>
        <textarea
          v-model="globalComment"
          placeholder="ApprÃ©ciation globale..."
          rows="4"
        ></textarea>
      </div>

      <!-- Actions -->
      <div class="actions">
        <button @click="saveDraft" :disabled="saving">
          ğŸ’¾ Sauvegarder Brouillon
        </button>

        <button @click="lockCopy" :disabled="!isComplete" class="btn-primary">
          âœ… Valider et Verrouiller
        </button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import api from '@/services/api'

const props = defineProps<{ copyId: number }>()

const copy = ref(null)
const questions = ref([])
const grades = ref<Record<number, number>>({})
const comments = ref<Record<number, string>>({})
const globalComment = ref('')
const saving = ref(false)

onMounted(async () => {
  // Charger copie (anonymisÃ©e)
  const response = await api.get(`/api/grading/copies/${props.copyId}/`)
  copy.value = response.data

  // Charger questions
  const questionsResponse = await api.get(`/api/exams/${copy.value.exam.id}/questions/`)
  questions.value = questionsResponse.data.results

  // Charger notes existantes
  if (response.data.grades) {
    response.data.grades.forEach(grade => {
      grades.value[grade.question_id] = grade.score
      comments.value[grade.question_id] = grade.comment || ''
    })
  }

  globalComment.value = response.data.teacher_comment || ''
})

const isComplete = computed(() => {
  // Toutes les questions doivent avoir une note
  return questions.value.every(q => grades.value[q.id] !== undefined)
})

async function saveDraft() {
  saving.value = true

  try {
    // Construire payload
    const payload = {
      grades: Object.entries(grades.value).map(([questionId, score]) => ({
        question_id: parseInt(questionId),
        score,
        comment: comments.value[parseInt(questionId)] || ''
      })),
      teacher_comment: globalComment.value
    }

    await api.patch(`/api/grading/copies/${props.copyId}/`, payload)

    showSuccess('Brouillon sauvegardÃ©')
  } catch (error) {
    showError('Erreur sauvegarde')
  } finally {
    saving.value = false
  }
}

async function lockCopy() {
  if (!confirm('Verrouiller cette copie ? Elle ne sera plus modifiable.')) {
    return
  }

  try {
    await saveDraft()

    // Verrouiller copie
    await api.post(`/api/grading/copies/${props.copyId}/lock/`)

    showSuccess('Copie verrouillÃ©e âœ…')

    // Rediriger vers liste
    router.push('/grading')
  } catch (error) {
    showError('Erreur verrouillage')
  }
}
</script>
```

**Points clÃ©s** :
- âŒ Aucune info identifiante affichÃ©e
- âœ… Uniquement `anonymous_id` visible
- âœ… Correction impartiale garantie

---

### Ã‰tape 5 : Validation par Chef d'Ã‰quipe

**RÃ´le** : Enseignant principal (crÃ©ateur examen)

**Actions** :
- Consulter toutes les copies corrigÃ©es
- VÃ©rifier cohÃ©rence des notes
- Valider ou rejeter corrections
- Forcer dÃ©sanonymisation si nÃ©cessaire

**Code** :

```python
# copies/views.py

from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from .models import Copy
from .permissions import IsExamOwner

class CopyViewSet(viewsets.ModelViewSet):
    """ViewSet copies."""

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated, IsExamOwner])
    def validate_correction(self, request, pk=None):
        """
        Valider correction par chef d'Ã©quipe.

        Args:
            approved (bool): True = validÃ©, False = rejetÃ©
            comment (str): Commentaire validation
        """
        copy = self.get_object()

        if not copy.is_locked:
            return Response(
                {'error': 'Copy must be locked before validation'},
                status=400
            )

        approved = request.data.get('approved', False)
        comment = request.data.get('comment', '')

        if approved:
            copy.status = 'GRADED'
            copy.validation_comment = comment
            copy.validated_by = request.user
            copy.validated_at = timezone.now()
            copy.save()

            return Response({'success': True, 'message': 'Copy validated'})

        else:
            # Rejeter â†’ dÃ©verrouiller pour re-correction
            copy.is_locked = False
            copy.status = 'ASSIGNED'
            copy.validation_comment = comment
            copy.save()

            return Response({'success': True, 'message': 'Copy rejected, unlocked for re-grading'})
```

---

### Ã‰tape 6 : DÃ©sanonymisation et Publication

**DÃ©clencheur** : Toutes les copies validÃ©es

**Actions** :
1. Marquer exam comme `FINALIZED`
2. RÃ©vÃ©ler identitÃ©s (dÃ©sanonymisation)
3. Publier rÃ©sultats aux Ã©tudiants
4. Envoyer notifications

**Code** :

```python
# exams/views.py

from rest_framework.decorators import action
from rest_framework.response import Response
from copies.models import Copy

class ExamViewSet(viewsets.ModelViewSet):
    """ViewSet examens."""

    @action(detail=True, methods=['post'])
    def publish_results(self, request, pk=None):
        """
        Publier rÃ©sultats (dÃ©sanonymiser + rendre visible aux Ã©tudiants).

        Requires:
            - Toutes copies validÃ©es (status=GRADED)
        """
        exam = self.get_object()

        # VÃ©rifier que toutes les copies sont corrigÃ©es
        pending_copies = Copy.objects.filter(
            exam=exam,
            status__in=['UPLOADED', 'ASSIGNED', 'GRADING']
        ).count()

        if pending_copies > 0:
            return Response(
                {'error': f'{pending_copies} copies not yet graded'},
                status=400
            )

        # Publier toutes les copies
        Copy.objects.filter(exam=exam, status='GRADED').update(
            status='PUBLISHED',
            published_at=timezone.now()
        )

        # Marquer examen finalisÃ©
        exam.status = 'FINALIZED'
        exam.published_at = timezone.now()
        exam.save()

        # Envoyer notifications aux Ã©tudiants
        self._send_result_notifications(exam)

        logger.info(f"Exam {exam.id} results published")

        return Response({
            'success': True,
            'message': 'Results published successfully',
            'published_copies': Copy.objects.filter(exam=exam, status='PUBLISHED').count()
        })

    def _send_result_notifications(self, exam):
        """Envoyer emails aux Ã©tudiants."""
        from django.core.mail import send_mass_mail

        copies = Copy.objects.filter(exam=exam, status='PUBLISHED').select_related('student')

        emails = []
        for copy in copies:
            if copy.student and copy.student.email:
                subject = f"RÃ©sultats disponibles - {exam.title}"
                message = f"""
Bonjour {copy.student.first_name},

Vos rÃ©sultats pour l'examen "{exam.title}" sont maintenant disponibles.

Note : {copy.total_score} / {copy.max_score}

Connectez-vous pour consulter votre copie corrigÃ©e :
https://korrigo.korrigo.local/student/login

Cordialement,
L'Ã©quipe enseignante
                """.strip()

                emails.append((subject, message, 'noreply@korrigo.local', [copy.student.email]))

        # Envoi batch
        send_mass_mail(emails, fail_silently=True)

        logger.info(f"Sent {len(emails)} result notifications")
```

---

## ğŸ” SÃ©curitÃ© et ConfidentialitÃ©

### Permissions

| Action | Admin | Teacher (Owner) | Teacher (Other) | Student |
|--------|-------|-----------------|-----------------|---------|
| Voir anonymous_id | âœ… | âœ… | âœ… | âŒ |
| Voir student_id | âœ… | âœ… (aprÃ¨s publication) | âŒ | âœ… (soi-mÃªme) |
| Corriger copie | âœ… | âœ… (si assignÃ©) | âœ… (si assignÃ©) | âŒ |
| Valider correction | âœ… | âœ… (si owner) | âŒ | âŒ |
| Publier rÃ©sultats | âœ… | âœ… (si owner) | âŒ | âŒ |

### Audit Trail

**ModÃ¨le Copy** : Tracking complet des actions

```python
class Copy(models.Model):
    """Copie examen."""

    # Anonymisation
    anonymous_id = models.CharField(max_length=10, unique=True)
    is_anonymized = models.BooleanField(default=False)
    pdf_anonymized = models.FileField(upload_to='copies/anonymized/', null=True)

    # Affectation
    assigned_to = models.ForeignKey(User, on_delete=SET_NULL, null=True, related_name='assigned_copies')
    assigned_at = models.DateTimeField(null=True)

    # Correction
    graded_by = models.ForeignKey(User, on_delete=SET_NULL, null=True, related_name='graded_copies')
    graded_at = models.DateTimeField(null=True)
    is_locked = models.BooleanField(default=False)

    # Validation
    validated_by = models.ForeignKey(User, on_delete=SET_NULL, null=True, related_name='validated_copies')
    validated_at = models.DateTimeField(null=True)
    validation_comment = models.TextField(blank=True)

    # Publication
    published_at = models.DateTimeField(null=True)
```

**Logs** :

```python
# Exemple de log
logger.info(
    f"Copy {copy.anonymous_id} graded by {grader.username} "
    f"(score: {copy.total_score}/{copy.max_score})"
)
```

---

## âœ… Tests

### Test Anonymisation

```python
# copies/tests/test_anonymizer.py

from django.test import TestCase
from copies.models import Copy
from copies.services.anonymizer import CopyAnonymizer

class AnonymizerTestCase(TestCase):
    def setUp(self):
        self.exam = Exam.objects.create(title='Test Exam')
        self.student = Student.objects.create(
            first_name='Jean',
            last_name='DUPONT',
            email='jean@test.com'
        )

        self.copy = Copy.objects.create(
            exam=self.exam,
            student=self.student,
            is_identified=True
        )

    def test_generate_anonymous_ids(self):
        """Test gÃ©nÃ©ration IDs anonymes."""
        anonymizer = CopyAnonymizer()
        mapping = anonymizer.generate_anonymous_ids(self.exam.id)

        self.assertIn(self.copy.id, mapping)
        self.assertRegex(mapping[self.copy.id], r'^A\d{3}$')

        # VÃ©rifier sauvegarde
        self.copy.refresh_from_db()
        self.assertIsNotNone(self.copy.anonymous_id)

    def test_anonymize_pdf(self):
        """Test masquage PDF."""
        self.copy.anonymous_id = 'A001'
        self.copy.save()

        anonymizer = CopyAnonymizer()
        output_path = anonymizer.anonymize_pdf(self.copy)

        self.assertTrue(os.path.exists(output_path))

        self.copy.refresh_from_db()
        self.assertTrue(self.copy.is_anonymized)
```

---

## ğŸ“Š Statistiques

### Exemple Tableau de Bord Admin

```python
# exams/views.py

@action(detail=True, methods=['get'])
def anonymization_stats(self, request, pk=None):
    """Statistiques anonymisation."""
    exam = self.get_object()

    copies = Copy.objects.filter(exam=exam)

    stats = {
        'total_copies': copies.count(),
        'anonymized': copies.filter(is_anonymized=True).count(),
        'assigned': copies.filter(assigned_to__isnull=False).count(),
        'graded': copies.filter(status='GRADED').count(),
        'published': copies.filter(status='PUBLISHED').count(),
        'graders': User.objects.filter(
            assigned_copies__exam=exam
        ).distinct().count()
    }

    return Response(stats)
```

**Output** :

```json
{
  "total_copies": 44,
  "anonymized": 44,
  "assigned": 44,
  "graded": 38,
  "published": 0,
  "graders": 3
}
```

---

## ğŸ“ Conclusion

L'anonymisation garantit une correction impartiale en masquant l'identitÃ© des Ã©tudiants jusqu'Ã  la publication des rÃ©sultats. Le systÃ¨me supporte l'affectation automatique aux correcteurs avec Ã©quilibrage de charge.

**Points clÃ©s** :
- IDs anonymes sÃ©quentiels (`A001`, `A002`, ...)
- Masquage PDF automatique (overlay + ID)
- Affectation alÃ©atoire ou load-balanced
- Correction en mode aveugle (anonymous_id uniquement)
- DÃ©sanonymisation aprÃ¨s validation
- Audit trail complet

---

**Document rÃ©digÃ© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 FÃ©vrier 2026
