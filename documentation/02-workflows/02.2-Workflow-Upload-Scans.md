# 02.2 - Workflow Upload et Traitement des Scans

**Projet** : Korrigo - SystÃ¨me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 FÃ©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## ğŸ¯ Objectif

Ce workflow dÃ©crit le processus complet d'**upload et traitement des PDF scannÃ©s** :
1. Upload PDF + CSV
2. Validation fichiers
3. Traitement batch (split A4, OCR, segmentation)
4. CrÃ©ation des copies Django
5. PrÃªt pour identification

---

## ğŸ“‹ Vue d'Ensemble

### Diagramme Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WORKFLOW UPLOAD SCANS                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Enseignant  â”‚
â”‚   Upload     â”‚
â”‚ PDF + CSV    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Validation      â”‚
â”‚  - Format PDF    â”‚ â—„â”€â”€â”€ Si erreur: 400 Bad Request
â”‚  - Taille < 100MBâ”‚
â”‚  - CSV valide    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Sauvegarde      â”‚
â”‚  Fichiers        â”‚
â”‚  media/exams/    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Celery Task     â”‚
â”‚  Async Processingâ”‚ â—„â”€â”€â”€ Task ID retournÃ©
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                             â”‚
       â–¼                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PDF Split A4 â”‚            â”‚ Import CSV       â”‚
â”‚ (A3 â†’ 2xA4)  â”‚            â”‚ Students         â”‚
â”‚ Deskew       â”‚            â”‚ Whitelist        â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  OCR Header      â”‚
â”‚  Multi-layer     â”‚
â”‚  (Tesseract +    â”‚
â”‚   EasyOCR +      â”‚
â”‚   PaddleOCR)     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Segmentation    â”‚
â”‚  par Ã‰tudiant    â”‚
â”‚  (fusion sheets) â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CrÃ©ation Copies â”‚
â”‚  Django          â”‚
â”‚  - Copy model    â”‚
â”‚  - OCRResult     â”‚
â”‚  - Status        â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Notification    â”‚
â”‚  Enseignant      â”‚
â”‚  "PrÃªt pour      â”‚
â”‚   identification"â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ Ã‰tapes DÃ©taillÃ©es

### Ã‰tape 1 : Upload Fichiers

**Acteur** : Enseignant (admin ou teacher)

**Interface** : Vue.js `ExamUpload.vue`

**Actions** :
1. SÃ©lectionner PDF scannÃ© (copie complÃ¨te agrafÃ©e)
2. SÃ©lectionner CSV liste Ã©tudiants
3. Choisir mode batch (A3 ou A4)
4. Cliquer "Upload"

**Frontend Code** :

```vue
<template>
  <div class="upload-form">
    <h2>ğŸ“¤ Upload Copies ScannÃ©es</h2>

    <form @submit.prevent="handleUpload">
      <!-- PDF Upload -->
      <div class="form-group">
        <label>ğŸ“„ PDF ScannÃ© (copies agrafÃ©es)</label>
        <input
          type="file"
          accept=".pdf"
          @change="onPDFChange"
          required
        />
        <p v-if="pdfFile" class="file-info">
          {{ pdfFile.name }} ({{ formatFileSize(pdfFile.size) }})
        </p>
      </div>

      <!-- CSV Upload -->
      <div class="form-group">
        <label>ğŸ“Š CSV Liste Ã‰tudiants</label>
        <input
          type="file"
          accept=".csv"
          @change="onCSVChange"
          required
        />
        <p v-if="csvFile" class="file-info">
          {{ csvFile.name }}
        </p>
      </div>

      <!-- Batch Mode -->
      <div class="form-group">
        <label>ğŸ“ Format Papier</label>
        <select v-model="batchMode" required>
          <option value="A3">A3 (recto-verso agrafÃ©)</option>
          <option value="A4">A4 (recto simple)</option>
        </select>
        <p class="help-text">
          A3 : 1 feuille A3 recto-verso = 4 faces A4<br>
          A4 : 1 feuille A4 recto = 1 face
        </p>
      </div>

      <!-- Submit -->
      <button type="submit" :disabled="uploading">
        {{ uploading ? 'Upload en cours...' : 'Uploader et Traiter' }}
      </button>

      <!-- Progress -->
      <div v-if="uploadProgress > 0" class="progress-bar">
        <div class="progress" :style="{ width: uploadProgress + '%' }"></div>
        <span>{{ uploadProgress }}%</span>
      </div>
    </form>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import api from '@/services/api'

const router = useRouter()

const pdfFile = ref<File | null>(null)
const csvFile = ref<File | null>(null)
const batchMode = ref('A3')
const uploading = ref(false)
const uploadProgress = ref(0)

function onPDFChange(event: Event) {
  const target = event.target as HTMLInputElement
  if (target.files && target.files[0]) {
    pdfFile.value = target.files[0]

    // Validation taille (100 MB max)
    const maxSize = 100 * 1024 * 1024
    if (pdfFile.value.size > maxSize) {
      alert('Fichier trop volumineux (max 100 MB)')
      pdfFile.value = null
      target.value = ''
    }
  }
}

function onCSVChange(event: Event) {
  const target = event.target as HTMLInputElement
  if (target.files && target.files[0]) {
    csvFile.value = target.files[0]
  }
}

async function handleUpload() {
  if (!pdfFile.value || !csvFile.value) {
    alert('Veuillez sÃ©lectionner PDF et CSV')
    return
  }

  uploading.value = true
  uploadProgress.value = 0

  // FormData
  const formData = new FormData()
  formData.append('pdf_file', pdfFile.value)
  formData.append('students_csv', csvFile.value)
  formData.append('batch_mode', batchMode.value)

  try {
    const response = await api.post('/api/exams/upload/', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      onUploadProgress: (progressEvent) => {
        if (progressEvent.total) {
          uploadProgress.value = Math.round(
            (progressEvent.loaded * 100) / progressEvent.total
          )
        }
      }
    })

    // Rediriger vers page traitement
    router.push(`/exams/${response.data.exam_id}/processing`)

  } catch (error: any) {
    alert(error.response?.data?.error || 'Upload Ã©chouÃ©')
  } finally {
    uploading.value = false
  }
}

function formatFileSize(bytes: number): string {
  if (bytes < 1024) return bytes + ' B'
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB'
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB'
}
</script>
```

**API Endpoint** : `POST /api/exams/upload/`

---

### Ã‰tape 2 : Validation Fichiers

**Backend** : `ExamUploadView` (Django)

**Validations** :

1. **PDF** :
   - Format : `.pdf`
   - Taille : < 100 MB
   - Non corrompu (PyPDF2 peut ouvrir)

2. **CSV** :
   - Format : `.csv`
   - Taille : < 10 MB
   - Colonnes obligatoires : `nom`, `prenom`, `email`, `date_naissance`
   - Format email valide
   - Dates de naissance valides (DD/MM/YYYY)
   - Pas de doublons email

**Code Backend** :

```python
# exams/views.py

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.core.files.uploadedfile import UploadedFile
from django.core.exceptions import ValidationError
from .models import Exam
from .serializers import ExamSerializer
from processing.tasks import process_batch_pdf
from students.utils import parse_student_csv
import PyPDF2
import logging

logger = logging.getLogger(__name__)

class ExamViewSet(viewsets.ModelViewSet):
    """ViewSet pour gestion examens."""

    queryset = Exam.objects.all()
    serializer_class = ExamSerializer
    permission_classes = [IsAuthenticated]

    @action(detail=False, methods=['post'])
    def upload(self, request):
        """
        Upload PDF + CSV et lancer traitement batch.

        Returns:
            {
                'exam_id': int,
                'task_id': str,
                'message': str
            }
        """
        # RÃ©cupÃ©rer fichiers
        pdf_file = request.FILES.get('pdf_file')
        csv_file = request.FILES.get('students_csv')
        batch_mode = request.data.get('batch_mode', 'A3')

        if not pdf_file or not csv_file:
            return Response(
                {'error': 'PDF and CSV files required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Validation PDF
        try:
            self._validate_pdf(pdf_file)
        except ValidationError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Validation CSV
        try:
            students = parse_student_csv(csv_file.temporary_file_path())
        except ValidationError as e:
            return Response(
                {'error': f'CSV validation failed: {str(e)}'},
                status=status.HTTP_422_UNPROCESSABLE_ENTITY
            )

        # CrÃ©er examen
        exam = Exam.objects.create(
            title=request.data.get('title', 'Examen sans titre'),
            subject=request.data.get('subject', 'Non spÃ©cifiÃ©'),
            created_by=request.user,
            pdf_file=pdf_file,
            students_csv=csv_file,
            batch_mode=batch_mode,
            status='PROCESSING'
        )

        logger.info(f"Exam {exam.id} created by {request.user.username}")

        # Lancer traitement async
        task = process_batch_pdf.delay(exam.id)

        return Response({
            'exam_id': exam.id,
            'task_id': task.id,
            'message': 'Upload successful, processing started',
            'student_count': len(students)
        }, status=status.HTTP_201_CREATED)

    def _validate_pdf(self, pdf_file: UploadedFile):
        """Valider fichier PDF."""
        # Taille max (100 MB)
        max_size = 100 * 1024 * 1024
        if pdf_file.size > max_size:
            raise ValidationError(
                f'File too large: {pdf_file.size} bytes (max: {max_size})'
            )

        # Extension
        if not pdf_file.name.lower().endswith('.pdf'):
            raise ValidationError('Invalid file type: must be PDF')

        # Tenter ouverture avec PyPDF2
        try:
            pdf_reader = PyPDF2.PdfReader(pdf_file)
            page_count = len(pdf_reader.pages)

            if page_count == 0:
                raise ValidationError('PDF has no pages')

            logger.info(f"PDF validated: {page_count} pages")

        except Exception as e:
            raise ValidationError(f'Corrupted PDF: {str(e)}')
```

**Erreurs Possibles** :

| Erreur | Code HTTP | Message |
|--------|-----------|---------|
| Fichier manquant | 400 | "PDF and CSV files required" |
| PDF trop volumineux | 400 | "File too large" |
| PDF corrompu | 400 | "Corrupted PDF" |
| CSV invalide | 422 | "CSV validation failed: [details]" |

---

### Ã‰tape 3 : Traitement Batch Async (Celery)

**Task Celery** : `process_batch_pdf`

**Fichier** : `backend/processing/tasks.py`

```python
from celery import shared_task
from django.core.exceptions import ObjectDoesNotExist
from .services.batch_processor import BatchA3Processor
import logging

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3)
def process_batch_pdf(self, exam_id: int):
    """
    Traiter PDF batch en async.

    Args:
        exam_id: ID examen Django

    Returns:
        {
            'exam_id': int,
            'copies_created': int,
            'duration': float
        }
    """
    from exams.models import Exam

    try:
        exam = Exam.objects.get(id=exam_id)
    except ObjectDoesNotExist:
        logger.error(f"Exam {exam_id} not found")
        raise

    logger.info(f"Starting batch processing for exam {exam_id}")

    # Mettre Ã  jour statut
    exam.status = 'PROCESSING'
    exam.save()

    start_time = time.time()

    try:
        # Instancier processor
        processor = BatchA3Processor(
            pdf_path=exam.pdf_file.path,
            csv_path=exam.students_csv.path if exam.students_csv else None
        )

        # Traiter
        student_copies = processor.process()

        # CrÃ©er copies Django
        copies_created = processor.create_copies_from_batch(exam, student_copies)

        # SuccÃ¨s
        exam.status = 'READY'
        exam.copies_count = copies_created
        exam.save()

        duration = time.time() - start_time

        logger.info(
            f"Batch processing completed for exam {exam_id}: "
            f"{copies_created} copies in {duration:.2f}s"
        )

        return {
            'exam_id': exam_id,
            'copies_created': copies_created,
            'duration': duration
        }

    except Exception as e:
        logger.exception(f"Batch processing failed for exam {exam_id}: {str(e)}")

        exam.status = 'ERROR'
        exam.error_message = str(e)
        exam.save()

        # Retry si possible
        raise self.retry(exc=e, countdown=60)  # Retry aprÃ¨s 1 min
```

**Pipeline Traitement** :

1. **Split A4** : Convertir A3 â†’ 2x A4 avec rotation
2. **OCR Header** : Extraire nom + date de naissance (multi-layer)
3. **Segmentation** : Grouper pages par Ã©tudiant
4. **Fusion Sheets** : Fusionner feuilles multi-pages
5. **Matching CSV** : Fuzzy match avec whitelist
6. **CrÃ©ation Copies** : Sauvegarder dans Django

---

### Ã‰tape 4 : Split A4 (Batch A3)

**Service** : `BatchA3Processor._split_a3_to_a4()`

**Logique** :

- Page A3 impaire (recto) â†’ split vertical â†’ [A4 gauche, A4 droit]
- Page A3 paire (verso) â†’ split vertical + rotation 180Â° â†’ [A4 gauche, A4 droit]

**Code** :

```python
# processing/services/batch_processor.py

import fitz  # PyMuPDF
import numpy as np
import cv2

class BatchA3Processor:
    """Processor pour batch A3 recto-verso."""

    def _split_a3_to_a4(self, pdf_path: str) -> List[PageInfo]:
        """
        Split pages A3 en pages A4.

        Returns:
            Liste de PageInfo (numÃ©ro page, image, orientation)
        """
        doc = fitz.open(pdf_path)
        a4_pages = []
        page_counter = 1

        for a3_page_num in range(len(doc)):
            a3_page = doc[a3_page_num]

            # Render A3 page en image (300 DPI)
            pix = a3_page.get_pixmap(dpi=300)
            img = np.frombuffer(pix.samples, dtype=np.uint8).reshape(
                pix.height, pix.width, pix.n
            )

            # Convertir RGB â†’ Grayscale
            if img.shape[2] == 3:
                img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
            else:
                img_gray = img[:, :, 0]

            height, width = img_gray.shape

            # Split vertical (milieu)
            mid_x = width // 2

            # Page RECTO (impaire) â†’ split normal
            if a3_page_num % 2 == 0:
                left_page = img_gray[:, :mid_x]
                right_page = img_gray[:, mid_x:]

                a4_pages.append(PageInfo(
                    page_number=page_counter,
                    image=left_page,
                    orientation='RECTO_LEFT'
                ))
                page_counter += 1

                a4_pages.append(PageInfo(
                    page_number=page_counter,
                    image=right_page,
                    orientation='RECTO_RIGHT'
                ))
                page_counter += 1

            # Page VERSO (paire) â†’ split + rotation 180Â°
            else:
                left_page = img_gray[:, :mid_x]
                right_page = img_gray[:, mid_x:]

                # Rotation 180Â° pour les versos
                left_page_rotated = cv2.rotate(left_page, cv2.ROTATE_180)
                right_page_rotated = cv2.rotate(right_page, cv2.ROTATE_180)

                # Inverser ordre (verso imprimÃ© Ã  l'envers)
                a4_pages.append(PageInfo(
                    page_number=page_counter,
                    image=right_page_rotated,
                    orientation='VERSO_RIGHT'
                ))
                page_counter += 1

                a4_pages.append(PageInfo(
                    page_number=page_counter,
                    image=left_page_rotated,
                    orientation='VERSO_LEFT'
                ))
                page_counter += 1

        doc.close()
        logger.info(f"Split {len(doc)} A3 pages â†’ {len(a4_pages)} A4 pages")

        return a4_pages
```

**Exemple** :

- **Input** : 88 pages A3 (44 feuilles recto-verso)
- **Output** : 176 pages A4

---

### Ã‰tape 5 : OCR Header Multi-Layer

**Service** : `BatchA3Processor._ocr_header()`

**Moteurs OCR UtilisÃ©s** :

1. **Tesseract** (PSM 6, French) â†’ Bon pour texte imprimÃ©
2. **EasyOCR** (fr, en) â†’ Bon pour Ã©criture manuscrite
3. **PaddleOCR** (lang=fr) â†’ Robuste et rapide

**Consensus Voting** :

- Chaque moteur OCR extrait texte
- Fuzzy match avec CSV whitelist
- AgrÃ©gation scores â†’ Top-5 candidats
- Confiance > 0.7 â†’ AUTO
- Confiance 0.4-0.7 â†’ SEMI-AUTO (top-5)
- Confiance < 0.4 â†’ MANUAL

**Code** :

```python
from processing.services.ocr_engine import MultiLayerOCR

def _ocr_header(self, header_image: np.ndarray) -> OCRResult:
    """
    OCR multi-layer sur header.

    Returns:
        OCRResult avec top_candidates
    """
    # Instancier OCR multi-layer
    ocr_engine = MultiLayerOCR()

    # Extraire texte (tous moteurs + consensus)
    result = ocr_engine.extract_text_with_candidates(
        header_image,
        csv_whitelist=self.students
    )

    return result
```

---

### Ã‰tape 6 : Segmentation par Ã‰tudiant

**Service** : `BatchA3Processor._segment_by_student()`

**Logique** :

- DÃ©tecter headers (zone 5 cm haut de page)
- Grouper pages entre 2 headers = 1 copie Ã©tudiant
- GÃ©rer multi-feuilles (ex: 4 pages par Ã©tudiant)

**Code** :

```python
def _segment_by_student(self, a4_pages: List[PageInfo]) -> List[StudentCopy]:
    """
    Segmenter pages A4 par Ã©tudiant.

    Retourne:
        Liste de StudentCopy (student_match, pages, header_crops, ocr_mode)
    """
    student_copies = []
    current_copy_pages = []
    current_header_crops = []

    for page in a4_pages:
        # DÃ©tecter header
        has_header = self._detect_header(page.image)

        if has_header:
            # Fin de la copie prÃ©cÃ©dente
            if current_copy_pages:
                student_copies.append(self._create_student_copy(
                    current_copy_pages,
                    current_header_crops
                ))

            # Nouvelle copie
            current_copy_pages = [page]
            header_crop = self._extract_header(page.image)
            current_header_crops = [header_crop]

        else:
            # Ajouter Ã  copie courante
            current_copy_pages.append(page)

    # DerniÃ¨re copie
    if current_copy_pages:
        student_copies.append(self._create_student_copy(
            current_copy_pages,
            current_header_crops
        ))

    logger.info(f"Segmented {len(a4_pages)} pages â†’ {len(student_copies)} student copies")

    return student_copies

def _create_student_copy(self, pages: List[PageInfo],
                         header_crops: List[np.ndarray]) -> StudentCopy:
    """
    CrÃ©er StudentCopy avec OCR du premier header.
    """
    # OCR sur premier header
    ocr_result = self._ocr_header(header_crops[0])

    # DÃ©terminer mode
    if ocr_result.top_candidates:
        top_confidence = ocr_result.top_candidates[0].confidence

        if top_confidence > 0.7:
            ocr_mode = 'AUTO'
            student_match = ocr_result.top_candidates[0]
        elif top_confidence > 0.4:
            ocr_mode = 'SEMI_AUTO'
            student_match = None  # Attendre sÃ©lection manuelle
        else:
            ocr_mode = 'MANUAL'
            student_match = None
    else:
        ocr_mode = 'MANUAL'
        student_match = None

    return StudentCopy(
        pages=pages,
        header_crops=header_crops,
        student_match=student_match,
        ocr_result=ocr_result,
        ocr_mode=ocr_mode
    )
```

---

### Ã‰tape 7 : CrÃ©ation Copies Django

**Service** : `BatchA3Processor.create_copies_from_batch()`

**ModÃ¨les CrÃ©Ã©s** :

- `Copy` : Copie Django avec status, student, anonymous_id
- `OCRResult` : RÃ©sultats OCR avec top_candidates
- `Page` : Pages individuelles de la copie

**Code** :

```python
def create_copies_from_batch(self, exam: Exam,
                              student_copies: List[StudentCopy]) -> int:
    """
    CrÃ©er copies Django depuis StudentCopy.

    Returns:
        Nombre de copies crÃ©Ã©es
    """
    from copies.models import Copy
    from identification.models import OCRResult

    created_count = 0

    for idx, student_copy in enumerate(student_copies, 1):
        # GÃ©nÃ©rer ID anonyme
        anonymous_id = f"A{idx:03d}"

        # DÃ©terminer status initial
        if student_copy.ocr_mode == 'AUTO':
            initial_status = 'READY'
            student = student_copy.student_match.student
        else:
            initial_status = 'UPLOADED'
            student = None

        # CrÃ©er Copy
        copy = Copy.objects.create(
            exam=exam,
            anonymous_id=anonymous_id,
            student=student,
            status=initial_status,
            is_identified=(student is not None),
            page_count=len(student_copy.pages),
            created_by=exam.created_by
        )

        # Sauvegarder OCR result
        OCRResult.objects.create(
            copy=copy,
            detected_text=student_copy.ocr_result.top_candidates[0].text if student_copy.ocr_result.top_candidates else '',
            confidence=student_copy.ocr_result.top_candidates[0].confidence if student_copy.ocr_result.top_candidates else 0.0,
            top_candidates=[c.to_dict() for c in student_copy.ocr_result.top_candidates],
            ocr_mode=student_copy.ocr_mode
        )

        # Sauvegarder pages individuelles
        for page_info in student_copy.pages:
            # Convertir image â†’ PDF page
            page_pdf_path = self._save_page_as_pdf(page_info.image, copy.id, page_info.page_number)

            Page.objects.create(
                copy=copy,
                page_number=page_info.page_number,
                pdf_file=page_pdf_path
            )

        created_count += 1

    logger.info(f"Created {created_count} copies for exam {exam.id}")

    return created_count
```

---

### Ã‰tape 8 : Notification Enseignant

**WebSocket** : Notification temps rÃ©el via Django Channels

**Code** :

```python
# consumers.py

from channels.generic.websocket import AsyncJsonWebsocketConsumer

class ProcessingConsumer(AsyncJsonWebsocketConsumer):
    """Consumer pour notifications traitement batch."""

    async def connect(self):
        self.exam_id = self.scope['url_route']['kwargs']['exam_id']
        self.room_group_name = f'exam_{self.exam_id}_processing'

        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )

        await self.accept()

    async def processing_complete(self, event):
        """Envoyer notification de fin."""
        await self.send_json({
            'type': 'processing_complete',
            'exam_id': event['exam_id'],
            'copies_created': event['copies_created'],
            'duration': event['duration']
        })
```

**Frontend** :

```typescript
// composables/useProcessingStatus.ts

import { ref, onMounted, onUnmounted } from 'vue'

export function useProcessingStatus(examId: number) {
  const status = ref('PROCESSING')
  const copiesCreated = ref(0)
  let ws: WebSocket | null = null

  onMounted(() => {
    // Connexion WebSocket
    ws = new WebSocket(`ws://localhost:8088/ws/exams/${examId}/processing/`)

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data)

      if (data.type === 'processing_complete') {
        status.value = 'READY'
        copiesCreated.value = data.copies_created
      }
    }
  })

  onUnmounted(() => {
    ws?.close()
  })

  return { status, copiesCreated }
}
```

---

## â±ï¸ Performance

### Benchmarks

**Hardware** : i5-12400F, 16 GB RAM

| MÃ©trique | Valeur | Notes |
|----------|--------|-------|
| **Upload** | ~5s pour 50 MB | DÃ©pend connexion |
| **Split A3 â†’ A4** | ~2s pour 88 pages | PyMuPDF rapide |
| **OCR par page** | ~3-5s | Multi-layer (3 moteurs) |
| **Segmentation** | ~1s pour 176 pages | Header detection |
| **CrÃ©ation Django** | ~10s pour 44 copies | I/O database |
| **Total** | **~8-12 min** pour 88 A3 pages (28 Ã©tudiants) | Batch complet |

### Optimisations

1. **Celery Worker Pool** : 4 workers en parallÃ¨le
2. **OCR Caching** : Ã‰viter re-OCR si dÃ©jÃ  traitÃ©
3. **Bulk Insert Django** : `bulk_create()` au lieu de boucle
4. **Redis Cache** : RÃ©sultats intermÃ©diaires

---

## âœ… Tests

### Test Upload API

```python
# exams/tests/test_upload.py

from django.core.files.uploadedfile import SimpleUploadedFile
from rest_framework.test import APITestCase
from rest_framework import status
from django.contrib.auth import get_user_model

User = get_user_model()

class ExamUploadTestCase(APITestCase):
    def setUp(self):
        self.teacher = User.objects.create_user(
            username='teacher',
            password='pass',
            role='TEACHER'
        )
        self.client.force_authenticate(user=self.teacher)

    def test_upload_valid_files(self):
        """Test upload PDF + CSV valides."""
        # CrÃ©er PDF fake
        pdf_content = b'%PDF-1.4 fake pdf content'
        pdf_file = SimpleUploadedFile('exam.pdf', pdf_content, content_type='application/pdf')

        # CrÃ©er CSV fake
        csv_content = b'nom,prenom,email,date_naissance\nDUPONT,Jean,jean@test.com,15/05/2008'
        csv_file = SimpleUploadedFile('students.csv', csv_content, content_type='text/csv')

        response = self.client.post('/api/exams/upload/', {
            'pdf_file': pdf_file,
            'students_csv': csv_file,
            'batch_mode': 'A3',
            'title': 'Test Exam'
        }, format='multipart')

        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertIn('exam_id', response.data)
        self.assertIn('task_id', response.data)

    def test_upload_missing_pdf(self):
        """Test upload sans PDF."""
        csv_file = SimpleUploadedFile('students.csv', b'nom,prenom\n', content_type='text/csv')

        response = self.client.post('/api/exams/upload/', {
            'students_csv': csv_file
        }, format='multipart')

        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
```

---

## ğŸ“ Conclusion

Le workflow d'upload et traitement des scans est entiÃ¨rement automatisÃ© via Celery. Le systÃ¨me supporte des PDF volumineux (100 MB) et traite efficacement les formats A3 recto-verso avec OCR multi-layer.

**Points clÃ©s** :
- Upload async avec progress bar
- Validation stricte (PDF + CSV)
- Traitement batch Celery
- OCR multi-layer avec consensus voting
- Modes AUTO / SEMI-AUTO / MANUAL
- Notification temps rÃ©el (WebSocket)

---

**Document rÃ©digÃ© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 FÃ©vrier 2026
