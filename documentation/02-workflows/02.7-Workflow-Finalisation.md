# 02.7 - Workflow de Finalisation et Publication

**Projet** : Korrigo - Syst√®me de Correction d'Examens
**Version** : 2.0 (PRD-19)
**Date** : 3 F√©vrier 2026
**Auteur** : **Alaeddine BEN RHOUMA**

---

## üéØ Objectif

Le workflow de finalisation permet √† l'**administrateur** de :
1. V√©rifier que toutes les copies sont corrig√©es
2. Calculer les notes finales
3. D√©sanonymiser les copies
4. Publier les r√©sultats (rendre visible aux √©tudiants)
5. Exporter les statistiques

---

## üìä Vue d'Ensemble du Workflow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       √âTAPE 1: V√âRIFICATION EXHAUSTIVIT√â                       ‚îÇ
‚îÇ  ‚Ä¢ Toutes copies identifi√©es ?                                 ‚îÇ
‚îÇ  ‚Ä¢ Toutes copies corrig√©es et verrouill√©es ?                   ‚îÇ
‚îÇ  ‚Ä¢ Pas de copies en statut PENDING ou IN_PROGRESS ?            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       √âTAPE 2: CALCUL NOTES FINALES                            ‚îÇ
‚îÇ  ‚Ä¢ V√©rifier somme notes = total attendu                        ‚îÇ
‚îÇ  ‚Ä¢ Recalculer total_score pour chaque copie                    ‚îÇ
‚îÇ  ‚Ä¢ D√©tecter anomalies (notes > max_score)                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       √âTAPE 3: D√âSANONYMISATION                                ‚îÇ
‚îÇ  ‚Ä¢ Lier anonymous_id ‚Üí student_id                              ‚îÇ
‚îÇ  ‚Ä¢ G√©n√©rer rapport notes (CSV)                                 ‚îÇ
‚îÇ  ‚Ä¢ Sauvegarder historique corrections                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       √âTAPE 4: PUBLICATION                                     ‚îÇ
‚îÇ  POST /api/exams/{id}/publish/                                 ‚îÇ
‚îÇ  ‚Ä¢ is_published = True                                         ‚îÇ
‚îÇ  ‚Ä¢ Copies: status ‚Üí PUBLISHED                                  ‚îÇ
‚îÇ  ‚Ä¢ Notification √©tudiants (optionnel)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       √âTAPE 5: EXPORT STATISTIQUES                             ‚îÇ
‚îÇ  ‚Ä¢ Export CSV notes                                            ‚îÇ
‚îÇ  ‚Ä¢ Statistiques descriptives (moyenne, m√©diane, √©cart-type)    ‚îÇ
‚îÇ  ‚Ä¢ Distribution notes (histogramme)                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚úÖ √âtape 1 : V√©rification Exhaustivit√©

### Objectif

V√©rifier que **toutes les copies** sont pr√™tes pour publication.

### Crit√®res de V√©rification

| Crit√®re | Description | Statut Requis |
|---------|-------------|---------------|
| **Identification** | Toutes copies identifi√©es | `is_identified=True` |
| **Correction** | Toutes copies corrig√©es | `is_locked=True` |
| **Status** | Aucune copie en cours | `status=COMPLETED` |
| **Notes** | Toutes questions not√©es | Grades complets |

### Implementation Backend

**Fichier** : `backend/exams/views.py`

```python
from django.db.models import Count, Q
from rest_framework.decorators import action
from rest_framework.response import Response

class ExamViewSet(viewsets.ModelViewSet):

    @action(detail=True, methods=['get'])
    def readiness_check(self, request, pk=None):
        """
        V√©rifier si examen est pr√™t pour publication.

        Returns:
            {
                "ready": true/false,
                "issues": [...],
                "statistics": {...}
            }
        """
        exam = self.get_object()

        issues = []
        total_copies = exam.copies.count()

        # 1. V√©rifier identification
        unidentified = exam.copies.filter(is_identified=False).count()
        if unidentified > 0:
            issues.append({
                'type': 'UNIDENTIFIED',
                'count': unidentified,
                'message': f'{unidentified} copies not identified'
            })

        # 2. V√©rifier correction
        uncorrected = exam.copies.filter(is_locked=False).count()
        if uncorrected > 0:
            issues.append({
                'type': 'UNCORRECTED',
                'count': uncorrected,
                'message': f'{uncorrected} copies not corrected'
            })

        # 3. V√©rifier status
        invalid_status = exam.copies.exclude(
            status__in=[Copy.Status.COMPLETED, Copy.Status.PUBLISHED]
        ).count()

        if invalid_status > 0:
            issues.append({
                'type': 'INVALID_STATUS',
                'count': invalid_status,
                'message': f'{invalid_status} copies in invalid status'
            })

        # 4. V√©rifier notes compl√®tes
        copies_with_incomplete_grades = self._check_incomplete_grades(exam)
        if copies_with_incomplete_grades:
            issues.append({
                'type': 'INCOMPLETE_GRADES',
                'count': len(copies_with_incomplete_grades),
                'message': f'{len(copies_with_incomplete_grades)} copies with incomplete grades',
                'copy_ids': copies_with_incomplete_grades
            })

        # Statistiques
        statistics = {
            'total_copies': total_copies,
            'identified': total_copies - unidentified,
            'corrected': total_copies - uncorrected,
            'ready_for_publication': total_copies - len(issues)
        }

        return Response({
            'ready': len(issues) == 0,
            'issues': issues,
            'statistics': statistics
        })

    def _check_incomplete_grades(self, exam):
        """V√©rifier que toutes questions sont not√©es pour chaque copie."""
        # Extraire tous les IDs de sous-questions du bar√®me
        expected_question_ids = set()
        for question in exam.grading_structure:
            for sub in question.get('sub_questions', []):
                expected_question_ids.add(sub['id'])

        copies_with_issues = []

        for copy in exam.copies.filter(is_locked=True):
            # R√©cup√©rer questions not√©es
            graded_question_ids = set(
                copy.grades.values_list('question_id', flat=True)
            )

            # V√©rifier exhaustivit√©
            if not expected_question_ids.issubset(graded_question_ids):
                missing = expected_question_ids - graded_question_ids
                copies_with_issues.append({
                    'copy_id': str(copy.id),
                    'anonymous_id': copy.anonymous_id,
                    'missing_questions': list(missing)
                })

        return copies_with_issues
```

### Frontend Component

**Composant** : `frontend/src/views/admin/ExamFinalization.vue`

```vue
<template>
  <div class="exam-finalization">
    <h1>Finalisation Examen</h1>
    <h2>{{ exam?.name }}</h2>

    <!-- √âtape 1: V√©rification -->
    <section class="verification-step">
      <h3>1. V√©rification Exhaustivit√©</h3>

      <button @click="runReadinessCheck" class="btn-secondary">
        üîç V√©rifier l'√âtat
      </button>

      <div v-if="readinessResult" class="readiness-report">
        <div v-if="readinessResult.ready" class="status-ok">
          ‚úÖ Examen pr√™t pour publication
        </div>

        <div v-else class="status-issues">
          ‚ö†Ô∏è {{ readinessResult.issues.length }} probl√®me(s) d√©tect√©(s):

          <ul>
            <li v-for="issue in readinessResult.issues" :key="issue.type">
              <strong>{{ issue.type }}:</strong> {{ issue.message }}
            </li>
          </ul>
        </div>

        <!-- Statistiques -->
        <div class="statistics">
          <StatCard title="Total Copies" :value="readinessResult.statistics.total_copies" />
          <StatCard title="Identifi√©es" :value="readinessResult.statistics.identified" />
          <StatCard title="Corrig√©es" :value="readinessResult.statistics.corrected" />
        </div>
      </div>
    </section>

    <!-- √âtape 2: Publication -->
    <section v-if="readinessResult?.ready" class="publication-step">
      <h3>2. Publication des R√©sultats</h3>

      <div class="warning-box">
        ‚ö†Ô∏è <strong>Attention:</strong> La publication rendra les r√©sultats visibles
        par tous les √©tudiants. Cette action est <strong>irr√©versible</strong>.
      </div>

      <button
        @click="publishExam"
        class="btn-primary btn-large"
        :disabled="isPublishing"
      >
        {{ isPublishing ? 'Publication en cours...' : 'üöÄ Publier les R√©sultats' }}
      </button>
    </section>

    <!-- √âtape 3: Export -->
    <section v-if="exam?.is_published" class="export-step">
      <h3>3. Export Statistiques</h3>

      <button @click="exportCSV" class="btn-secondary">
        üì• Exporter Notes (CSV)
      </button>

      <button @click="exportStatistics" class="btn-secondary">
        üìä Exporter Statistiques
      </button>
    </section>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import api from '@/services/api'
import type { Exam, ReadinessResult } from '@/types'

const route = useRoute()
const router = useRouter()
const examId = route.params.id as string

const exam = ref<Exam | null>(null)
const readinessResult = ref<ReadinessResult | null>(null)
const isPublishing = ref(false)

onMounted(async () => {
  await loadExam()
  await runReadinessCheck()
})

async function loadExam() {
  const response = await api.get(`/api/exams/${examId}/`)
  exam.value = response.data
}

async function runReadinessCheck() {
  const response = await api.get(`/api/exams/${examId}/readiness_check/`)
  readinessResult.value = response.data
}

async function publishExam() {
  if (!confirm('Confirmer la publication des r√©sultats ? Cette action est irr√©versible.')) {
    return
  }

  isPublishing.value = true

  try {
    await api.post(`/api/exams/${examId}/publish/`)
    alert('‚úÖ R√©sultats publi√©s avec succ√®s!')
    await loadExam()
  } catch (error: any) {
    alert(`Erreur: ${error.response?.data?.error || 'Publication √©chou√©e'}`)
  } finally {
    isPublishing.value = false
  }
}

async function exportCSV() {
  const response = await api.get(`/api/exams/${examId}/export_grades/`, {
    responseType: 'blob'
  })

  // T√©l√©charger fichier
  const blob = new Blob([response.data], { type: 'text/csv' })
  const url = window.URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = `notes_${exam.value?.name}_${new Date().toISOString()}.csv`
  link.click()
}

async function exportStatistics() {
  const response = await api.get(`/api/exams/${examId}/statistics/`)
  console.log('Statistics:', response.data)
  // Afficher dans UI ou t√©l√©charger JSON
}
</script>
```

---

## üßÆ √âtape 2 : Calcul Notes Finales

### Objectif

Recalculer et valider les **notes finales** de chaque copie.

### Validation

```python
@action(detail=True, methods=['post'])
def recalculate_scores(self, request, pk=None):
    """
    Recalculer toutes les notes finales.

    V√©rifie coh√©rence et d√©tecte anomalies.
    """
    exam = self.get_object()

    anomalies = []

    for copy in exam.copies.filter(is_locked=True):
        # Calculer total depuis grades
        calculated_total = sum(
            grade.score for grade in copy.grades.all()
        )

        # Comparer avec total_score enregistr√©
        if abs(calculated_total - (copy.total_score or 0)) > 0.01:
            anomalies.append({
                'copy_id': str(copy.id),
                'anonymous_id': copy.anonymous_id,
                'recorded_total': float(copy.total_score or 0),
                'calculated_total': float(calculated_total),
                'difference': float(calculated_total - (copy.total_score or 0))
            })

            # Corriger
            copy.total_score = calculated_total
            copy.save()

        # V√©rifier scores individuels
        for grade in copy.grades.all():
            if grade.score > grade.max_score:
                anomalies.append({
                    'copy_id': str(copy.id),
                    'question_id': grade.question_id,
                    'score': float(grade.score),
                    'max_score': float(grade.max_score),
                    'issue': 'Score exceeds maximum'
                })

    return Response({
        'recalculated_count': exam.copies.filter(is_locked=True).count(),
        'anomalies': anomalies
    })
```

---

## üé≠ √âtape 3 : D√©sanonymisation

### Objectif

G√©n√©rer un **rapport de notes** avec les noms r√©els des √©tudiants (d√©sanonymisation).

### Export CSV

```python
import csv
from django.http import HttpResponse

@action(detail=True, methods=['get'])
def export_grades(self, request, pk=None):
    """
    Exporter notes au format CSV.

    Format:
        Nom, Pr√©nom, Email, Note, Note/20, Observations
    """
    exam = self.get_object()

    # Cr√©er r√©ponse CSV
    response = HttpResponse(content_type='text/csv; charset=utf-8')
    response['Content-Disposition'] = f'attachment; filename="notes_{exam.name}.csv"'

    # BOM UTF-8 pour Excel
    response.write('\ufeff')

    writer = csv.writer(response, delimiter=';')

    # Header
    writer.writerow([
        'Nom',
        'Pr√©nom',
        'Email',
        'Date Naissance',
        'Anonymous ID',
        'Note',
        'Note/20',
        'Correcteur',
        'Date Correction',
        'Observations'
    ])

    # Calculer score max
    max_score = sum(q['max_score'] for q in exam.grading_structure)

    # Rows
    for copy in exam.copies.filter(is_locked=True).select_related('student', 'corrector'):
        if not copy.student:
            continue

        student = copy.student
        score_sur_20 = (copy.total_score / max_score) * 20 if max_score > 0 else 0

        # Observations
        observations = []
        if copy.total_score < max_score * 0.5:
            observations.append('R√©sultats insuffisants')
        elif copy.total_score >= max_score * 0.8:
            observations.append('Tr√®s bien')

        writer.writerow([
            student.last_name,
            student.first_name,
            student.email,
            student.date_of_birth.strftime('%d/%m/%Y'),
            copy.anonymous_id,
            f"{copy.total_score:.2f}",
            f"{score_sur_20:.2f}",
            copy.corrector.username if copy.corrector else '',
            copy.corrected_at.strftime('%d/%m/%Y %H:%M') if copy.corrected_at else '',
            ', '.join(observations)
        ])

    return response
```

**Exemple CSV G√©n√©r√©** :

```csv
Nom;Pr√©nom;Email;Date Naissance;Anonymous ID;Note;Note/20;Correcteur;Date Correction;Observations
DUPONT;Jean;jean.dupont@korrigo.local;15/05/2008;A3-001;16.50;16.50;test_prof;05/02/2026 16:30;Tr√®s bien
MARTIN;Marie;marie.martin@korrigo.local;03/12/2007;A3-002;12.00;12.00;test_prof;05/02/2026 17:00;
BERNARD;Luc;luc.bernard@korrigo.local;22/08/2008;A3-003;8.50;8.50;prof1;06/02/2026 10:15;R√©sultats insuffisants
```

---

## üöÄ √âtape 4 : Publication

### API Endpoint

**POST /api/exams/{id}/publish/**

**Backend Implementation** :

```python
from django.utils import timezone

@action(detail=True, methods=['post'])
def publish(self, request, pk=None):
    """
    Publier r√©sultats examen.

    Actions:
    1. V√©rifier exhaustivit√©
    2. Marquer exam.is_published = True
    3. Mettre √† jour status copies ‚Üí PUBLISHED
    4. Logger action
    5. (Optionnel) Envoyer notifications
    """
    exam = self.get_object()

    # Permissions
    if not request.user.is_superuser:
        return Response({'error': 'Admin only'}, status=403)

    # V√©rifier exhaustivit√©
    uncorrected = exam.copies.filter(is_locked=False).count()
    if uncorrected > 0:
        return Response({
            'error': f'Cannot publish: {uncorrected} copies not corrected'
        }, status=400)

    # V√©rifier pas d√©j√† publi√©
    if exam.is_published:
        return Response({
            'error': 'Exam already published'
        }, status=400)

    # Publier
    exam.is_published = True
    exam.published_at = timezone.now()
    exam.published_by = request.user
    exam.save()

    # Mettre √† jour copies
    published_count = exam.copies.filter(is_locked=True).update(
        status=Copy.Status.PUBLISHED
    )

    # Logger
    logger.info(
        f"Exam {exam.id} published by {request.user.username} "
        f"({published_count} copies)"
    )

    # (Optionnel) Notifications
    # self._send_publication_notifications(exam)

    return Response({
        'success': True,
        'exam_id': str(exam.id),
        'published_copies_count': published_count,
        'published_at': exam.published_at.isoformat(),
        'message': 'Exam published successfully'
    })
```

### Notifications (Optionnel)

```python
def _send_publication_notifications(self, exam):
    """Envoyer notifications aux √©tudiants."""

    from django.core.mail import send_mass_mail

    messages = []

    for copy in exam.copies.filter(status=Copy.Status.PUBLISHED, student__isnull=False):
        student = copy.student

        if student.email:
            subject = f"R√©sultats disponibles - {exam.name}"
            message = f"""
Bonjour {student.first_name},

Les r√©sultats de l'examen "{exam.name}" sont maintenant disponibles.

Vous pouvez consulter votre copie corrig√©e sur le portail Korrigo :
http://localhost:8088/student/portal

Note obtenue: {copy.total_score:.2f} / {self._calculate_max_score(exam)}

Cordialement,
L'√©quipe Korrigo
            """

            messages.append((
                subject,
                message,
                'noreply@korrigo.tn',
                [student.email]
            ))

    # Envoyer en masse
    if messages:
        send_mass_mail(messages, fail_silently=True)
        logger.info(f"Sent {len(messages)} publication notifications")
```

---

## üìä √âtape 5 : Statistiques

### Statistiques Descriptives

```python
@action(detail=True, methods=['get'])
def statistics(self, request, pk=None):
    """
    Calculer statistiques descriptives.

    Returns:
        {
            "total_copies": 28,
            "mean": 14.2,
            "median": 14.5,
            "std_dev": 3.1,
            "min": 6.0,
            "max": 19.5,
            "distribution": {...}
        }
    """
    import numpy as np
    from django.db.models import Avg, Min, Max, StdDev

    exam = self.get_object()

    # R√©cup√©rer toutes les notes
    scores = list(
        exam.copies.filter(is_locked=True)
        .values_list('total_score', flat=True)
    )

    if not scores:
        return Response({
            'error': 'No scores available'
        }, status=400)

    # Calculer statistiques
    stats = {
        'total_copies': len(scores),
        'mean': float(np.mean(scores)),
        'median': float(np.median(scores)),
        'std_dev': float(np.std(scores)),
        'min': float(min(scores)),
        'max': float(max(scores)),
        'quartiles': {
            'q1': float(np.percentile(scores, 25)),
            'q2': float(np.percentile(scores, 50)),  # median
            'q3': float(np.percentile(scores, 75))
        }
    }

    # Distribution (histogramme)
    max_score = sum(q['max_score'] for q in exam.grading_structure)
    bins = [0, 5, 10, 12, 14, 16, max_score]
    hist, _ = np.histogram(scores, bins=bins)

    stats['distribution'] = {
        'bins': bins,
        'counts': hist.tolist(),
        'labels': ['0-5', '5-10', '10-12', '12-14', '14-16', f'16-{max_score}']
    }

    # Notes par correcteur
    corrector_stats = []
    for corrector in exam.correctors.all():
        corrector_copies = exam.copies.filter(corrector=corrector, is_locked=True)
        corrector_scores = list(corrector_copies.values_list('total_score', flat=True))

        if corrector_scores:
            corrector_stats.append({
                'corrector': corrector.username,
                'copies_count': len(corrector_scores),
                'mean': float(np.mean(corrector_scores)),
                'std_dev': float(np.std(corrector_scores))
            })

    stats['by_corrector'] = corrector_stats

    return Response(stats)
```

### Visualisation Frontend

```vue
<template>
  <div class="statistics-view">
    <h2>Statistiques Examen</h2>

    <!-- M√©triques principales -->
    <div class="metrics-grid">
      <StatCard title="Moyenne" :value="stats.mean.toFixed(2)" />
      <StatCard title="M√©diane" :value="stats.median.toFixed(2)" />
      <StatCard title="√âcart-type" :value="stats.std_dev.toFixed(2)" />
      <StatCard title="Min" :value="stats.min.toFixed(2)" />
      <StatCard title="Max" :value="stats.max.toFixed(2)" />
    </div>

    <!-- Histogramme -->
    <div class="histogram">
      <h3>Distribution des Notes</h3>
      <canvas ref="chartCanvas"></canvas>
    </div>

    <!-- Par correcteur -->
    <div class="by-corrector">
      <h3>Statistiques par Correcteur</h3>
      <table>
        <thead>
          <tr>
            <th>Correcteur</th>
            <th>Copies</th>
            <th>Moyenne</th>
            <th>√âcart-type</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="c in stats.by_corrector" :key="c.corrector">
            <td>{{ c.corrector }}</td>
            <td>{{ c.copies_count }}</td>
            <td>{{ c.mean.toFixed(2) }}</td>
            <td>{{ c.std_dev.toFixed(2) }}</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { Chart } from 'chart.js/auto'
import api from '@/services/api'

const props = defineProps<{ examId: string }>()
const stats = ref<any>(null)
const chartCanvas = ref<HTMLCanvasElement | null>(null)

onMounted(async () => {
  const response = await api.get(`/api/exams/${props.examId}/statistics/`)
  stats.value = response.data

  renderChart()
})

function renderChart() {
  if (!chartCanvas.value || !stats.value) return

  new Chart(chartCanvas.value, {
    type: 'bar',
    data: {
      labels: stats.value.distribution.labels,
      datasets: [{
        label: 'Nombre d\'√©tudiants',
        data: stats.value.distribution.counts,
        backgroundColor: 'rgba(33, 150, 243, 0.6)',
        borderColor: 'rgba(33, 150, 243, 1)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      scales: {
        y: {
          beginAtZero: true,
          title: { display: true, text: 'Effectif' }
        },
        x: {
          title: { display: true, text: 'Intervalle de notes' }
        }
      }
    }
  })
}
</script>
```

---

## üìù Conclusion

Le workflow de finalisation permet √† l'administrateur de valider, publier et exporter les r√©sultats d'un examen de mani√®re s√©curis√©e et tra√ßable.

**Points cl√©s** :
- V√©rification exhaustivit√© avant publication
- Calcul et validation notes finales
- D√©sanonymisation avec export CSV
- Publication irr√©versible (protection)
- Statistiques descriptives compl√®tes
- Notifications √©tudiants (optionnel)

---

**Document r√©dig√© par :**
**Alaeddine BEN RHOUMA**
*Lead Senior Documentation & Architecture*
Date : 3 F√©vrier 2026
